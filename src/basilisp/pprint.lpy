(ns basilisp.pprint
  "Basilisp pretty printing functionality.

  References:
  - Oppen, Derek; \"Prettyprinting\"; October 1980
  - Waters, Richard; \"XP: A Common Lisp Pretty Printing System\"; March 1989"
  (:require
   [basilisp.string :as str]
   [basilisp.walk :as walk])
  (:import fractions
           io
           os
           threading))

(declare simple-dispatch code-dispatch write-out)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Dynamic Vars for Configuration ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def ^{:doc     "The base used for printing integer literals and rationals. Default is 10."
       :dynamic true}
  *print-base*
  10)

(def ^{:doc     "The dispatch function used for pretty printing.

                 Default is :lpy:fn:`simple-dispatch`."
       :dynamic true}
  *print-pprint-dispatch*
  nil)

(def ^{:doc     "If bound to ``true``, calls to :lpy:fn:`write` will use pretty printing.
                 Default is ``false``, but :lpy:fn:`pprint` binds the value to ``true``."
       :dynamic true}
  *print-pretty*
  false)

(def ^{:doc     "The soft upper limit for the length of the right margin. Default is 72."
       :dynamic true}
  *print-right-margin*
  72)

(def ^{:doc     "If ``true``, suppress printing symbol namespaces. This may be useful when
                 printing macroexpansions.

                 Default is ``nil``."
       :dynamic true}
  *print-suppress-namespaces*
  nil)

;;;;;;;;;;;;;;;;;;;
;; Private State ;;
;;;;;;;;;;;;;;;;;;;

(def ^:dynamic *current-level* 0)
(def ^:dynamic *current-length* nil)

;;;;;;;;;;;;;;;;;;;
;; Column Writer ;;
;;;;;;;;;;;;;;;;;;;

(def ^:dynamic ^:private *default-page-width* 72)

(defn ^:private get-column-writer
  "Return an :external:py:class:`io.TextIOBase` instance which keeps track of the
  current line and column it has printed.

  The ``max-columns`` input defaults to :lpy:var:`*default-page-width*`. This value
  is not used by the column writer, but may be introspected by callers.

  The current state can be fetched using :lpy:fn:`basilisp.core/deref`."
  ([writer]
   (get-column-writer writer *default-page-width*))
  ([writer max-columns]
   (let [lock  (threading/RLock)
         state (volatile! {:max max-columns :col 0 :line 0 :base writer})]
     (^:mutable reify
       basilisp.lang.interfaces/IDeref
       (deref [self]
         (with [_ lock]
               @state))

       ^:abstract
       ^{:abstract-members #{:flush :write}}
       io/TextIOBase
       (write [self s]
         (with [_ lock]
               (let [[init final] (.rsplit s os/linesep 1)]
                 (vswap! state
                         (fn [{:keys [col line] :as old-state}]
                           (if final
                             (let [nlines (count (.splitlines init))]
                               (-> old-state
                                   (assoc :col (count final))
                                   (assoc :line (+ line nlines))))
                             (assoc old-state :col (count init))))))
               (.write writer s)))

       (flush [self]
         (with [_ lock]
               (.flush writer)))

       (__repr__ [self]
         (str "<ColumnWriter wrapping " (repr writer) ">"))))))

;;;;;;;;;;;
;; Types ;;
;;;;;;;;;;;

(deftype LogicalBlock [parent prefix suffix ^:mutable indent ^:mutable force-nl?])

(deftype StartBlock [block start end])

(deftype EndBlock [block start end])

(deftype Blob [data trailing-white-space start end])

(deftype Indent [block relative-to offset start end])

(deftype Newline [block kind start end])

(defn debug-token
  [token]
  (condp instance? token
    StartBlock [":start" (python/id (.-block token))]
    EndBlock   [":end" (python/id (.-block token))]
    Blob       (.-data token)
    Newline    [(.-kind token) (python/id (.-block token))]))

;;;;;;;;;;;;;;;;;;;
;; Pretty Writer ;;
;;;;;;;;;;;;;;;;;;;

(defn ^:private buffer-length
  "Return the length of a given ``PrettyWriter`` buffer in characters."
  [buffer]
  (if-let [buf (seq buffer)]
    (- (.-end (last buf)) (.-start (first buf)))
    0))

(defn ^:private ancestor?
  "Return true if ``parent`` is an ancestor logical block of ``child``."
  [parent child]
  (loop [child (.-parent child)]
    (cond
      (nil? child)              false
      (identical? parent child) true
      :else                     (recur (.-parent child)))))

(defn ^:private split-queue-with
  "Split a queue ``buffer`` until ``(pred elem)`` returns ``true``\\.

  Return a two element vector with the first element being the elements coming
  before ``(pred elem)`` returned true, and the second element as a queue of all
  remaining elements."
  [pred buffer]
  (loop [before (queue)
         after  buffer]
    (if (seq after)
      (let [e (first after)]
        (if (not (pred e))
          (recur (conj before e)
                 (pop after))
          [before after]))
      [before after])))

(def ^:private split-at-newline
  "Split a queue at the first instance of a ``Newline`` token."
  (partial split-queue-with #(instance? Newline %)))

(defmacro pdebug
  [& args]
  `(do
     (.write *err* (str ~@args))
     (.write *err* \newline)))

(defn ^:private get-section
  "Get the section after a conditional newline, as defined by Waters:

     The section after a conditional newline consists of: all the output up to,
     but not including, (a) the next conditional newline imediately contained in
     the same logical block; or if (a) is not applicable, (b) the next newline
     that is at a lesser level of nesting in logical blocks; or if (b) is not
     applicable, (c) the end of the output as a whole.

     -- Waters, \"XP: A Common Lisp Pretty Printing System\", March 1989"
  [buffer]
  (let [nl    (first buffer)
        block (.-block nl)
        _ (pdebug "nl-block=" (python/id (.-block nl)) " " (.-block nl))
        comparator (fn [token]
                     (if (instance? Newline token)
                       (let [is-ancestor? (or #_(identical? (.-block token) block)
                                              (ancestor? (.-block token) block))]
                         (pdebug "token=" (debug-token token)
                                 " maybe-parent=" (python/id (.-block token))
                                 " is-ancestor?=" is-ancestor?)
                         is-ancestor?)
                       false))]
    #_#(and (instance? Newline %)
          (ancestor? (.-block %) block))
    (split-queue-with comparator
                      (pop buffer))))

(defprotocol PrettyWriter
  (start-block [this prefix suffix])
  (end-block [this])
  (pp-newline [this kind]))

(defn get-pretty-writer
  "Return a pretty writer instance, which is also an :external:py:class:`io.TextIOBase`.

  The current state can be fetched using :lpy:fn:`basilisp.core/deref`."
  [writer]
  (let [lock   (threading/RLock)
        writer (get-column-writer writer)
        state  (volatile! {:block                (LogicalBlock nil nil nil 0 false)
                           :buffer               (queue)
                           :pos                  0
                           :trailing-white-space nil})]
    (letfn [;; Private helpers can only be called while the lock is held

            ;; Return `true` if the given tokens will fit on the current line given
            ;; the max column width set for the base writer (if one is set).
            (tokens-fit? [tokens]
              (let [{:keys [col max]} @writer]
                (or (nil? max)
                    (pos? (- max (+ col (buffer-length tokens)))))))

            ;; Set `force-nl?` on the current logical block to ensure that any
            ;; remaining `:linear` newlines associated with the block are emitted.
            (set-block-force-nl! [block]
              (loop [block block]
                (when block
                  (when-not (.-force-nl? block)
                    (set! (.-force-nl? block) true)
                    (pdebug "force newline " block))
                  (recur (.-parent block)))))

            ;; Set the `indent` of the current logical block to match the current
            ;; column position of the base writer.
            (set-block-indent! [block prefix]
              (let [indent (+ (:col @writer) (count prefix))]
                #_(.write *err* (str "indent: " indent " block: " block))
                #_(.write *err* \newline)
                (set! (.-indent block) indent)))

            ;; Return `true` if the given newline type should be emitted.
            (emit-nl? [token]
              #_(.write *err* (str token))
              #_(.write *err* \newline)
              (condp = (.-kind token)
                :mandatory true
                :fill      nil
                :linear    (let [[section _] (get-section (:buffer @state))
                                 section-fits? (not (tokens-fit? section))
                                 should-emit-newline? (or (.-force-nl? (.-block token))
                                                          (let [[section _] (get-section (:buffer @state))]
                                                            (not (tokens-fit? section))))]
                             (pdebug "should-emit-newline?=" should-emit-newline?
                                     " buffer-length=" (buffer-length section)
                                     " writer=" @writer
                                     " not-section-fits?=" section-fits?
                                     " section=" (map debug-token section)
                                     " token=" token)
                             should-emit-newline?)
                :miser     nil))

            ;; Emit the newline token to the base writer unconditionally.
            ;; TODO: this is wrong
            (emit-nl [token]
              (pdebug "emitting nl=" token)
              (set-block-force-nl! (.-block token))
              (let [indent (or (.-indent (.-block token)) 0)]
                (str os/linesep (.ljust "" indent))))

            ;; Write a sequence of tokens to the base writer.
            (write-tokens [tokens]
              (doseq [token tokens]
                #_(.write *err* (str token))
                #_(.write *err* \newline)
                (when-let [s (condp instance? token
                               Blob       (.-data token)
                               Newline    (do
                                            #_(.write *err* (str token))
                                            #_(.write *err* \newline)
                                            (when (or (= (.-kind token) :mandatory)
                                                      (.-force-nl? (.-block token))) #_(emit-nl? token)
                                              (emit-nl token)))
                               StartBlock (let [block (.-block token)]
                                            (when-let [prefix (.-prefix block)]
                                              (set-block-indent! block prefix)
                                              prefix))
                               EndBlock   (.-suffix (.-block token)))]
                  (.write writer s))))

            ;; Write a single line and possibly emit a trailing conditional newline.
            (write-line []
              (let [{:keys [buffer]} @state
                    [s buf]          (split-at-newline buffer)]
                #_(pdebug {:buffer (map debug-token buf) :s (map debug-token s)})
                (when (seq s)
                  (write-tokens s))
                (vswap! state #(assoc % :buffer buf))
                ;; check if buffer still exceeds length; if so, we'll need to emit newlines
                (when buf
                  (let [[section remainder] (get-section buf)
                        _                   (pdebug {:section   (map debug-token section)
                                                     :remainder (map debug-token remainder)})
                        maybe-nl            (first buf)
                        buf                 (if (emit-nl? maybe-nl)
                                              (do
                                                (.write writer (emit-nl maybe-nl))
                                                (next buf))
                                              buf)]
                    (if-not (tokens-fit? buf)
                      (do
                        (pdebug "writing section " (map debug-token section))
                        (write-tokens section)
                        (vswap! state #(assoc % :buffer remainder)))
                      (vswap! state #(assoc % :bufer buf)))))))

            ;; Write tokens from the buffer to the base writer as long as the tokens
            ;; in the buffer won't fit on the current line.
            (write-lines []
              (loop [{:keys [buffer]} @state]
                (if-not (tokens-fit? buffer)
                  (write-line)
                  (recur @state))))

            ;; Add a token to the buffer and flush the buffer to the base writer if
            ;; the tokens do not fit on the base line.
            (add-to-buffer [token]
              (let [{:keys [buffer]} (vswap! state #(update % :buffer conj token))]
                (when-not (tokens-fit? buffer)
                  (write-lines))))

            ;; Update the current position in the state based on the given value,
            ;; returning a vector of the starting position and ending position.
            ;;
            ;; If the value is a string, the position will be incremented by the
            ;; length of the string. Otherwise, the position will be unchanged.
            (update-pos [v]
              (let [start-pos (:pos @state)]
                (when (string? v)
                  (vswap! state #(update % :pos + (count v))))
                [start-pos (:pos @state)]))]

      (^:mutable reify
       basilisp.lang.interfaces/IDeref
       (deref [self]
         (with [_ lock]
           @state))

       ^:abstract
       ^{:abstract-members #{:flush :write}}
       io/TextIOBase
       (write [self s]
         (with [_ lock]
           (if-not (seq (:buffer @state))
             (.write writer s)
             (do
               (let [[old-pos new-pos] (update-pos s)
                     blob              (Blob s nil old-pos new-pos)]
                 (add-to-buffer blob))))
           (count s)))

       (flush [self]
         (with [_ lock]
               (when-let [buf (:buffer @state)]
             (write-tokens buf))
           (.flush writer)))

       PrettyWriter
       (start-block [self prefix suffix]
         (with [_ lock]
               (let [current-block     (:block @state)
                     new-block         (LogicalBlock current-block prefix suffix 0 false)
                     [old-pos new-pos] (update-pos prefix)
                     start-block       (StartBlock new-block old-pos new-pos)]
                 (vswap! state #(-> %
                                    (assoc :block new-block)
                                    (assoc :pos new-pos)))
                 (add-to-buffer start-block)))
         nil)

       (end-block [self]
         (with [_ lock]
               (let [{:keys [block pos]} @state
                     suffix              (.-suffix block)
                     [old-pos new-pos]   (update-pos suffix)
                     end-block           (EndBlock block pos new-pos)]
                 (vswap! state #(assoc % :block (.-parent block)))
                 (add-to-buffer end-block)))
         nil)

       (pp-newline [self kind]
         (with [_ lock]
               (let [{:keys [block pos]} @state
                     nl                  (Newline block kind pos pos)]
                 (add-to-buffer nl)))
         nil)))))

;;;;;;;;;;;;;
;; Helpers ;;
;;;;;;;;;;;;;

(defmacro pprint-logical-block
  [& body]
  (let [flag-names   #{:prefix :per-line-prefix :suffix}
        [flags body] (loop [flags {}
                            body  body]
                       (if (flag-names (first body))
                         (recur (assoc flags (first body) (second body))
                                (nthrest body 2))
                         [flags body]))]
    `(with-bindings {#'*current-level* (inc *current-level*)}
       ~(let [{:keys [prefix suffix]} flags]
          `(start-block *out* ~prefix ~suffix))
       ~@body
       (end-block *out*))))

(defmacro print-length-loop
  ":lpy:fn:`loop` -like macro which loops at most :lpy:fn:`basilisp.core/*print-length*`
  times, which is often useful when defining custom pretty-printing functions."
  [bindings & body]
  (let [len-sym (gensym "len")
        body    (walk/postwalk
                 (fn [form]
                   (if (and (list? form) (= (first form) 'recur))
                     (apply list 'recur `(inc ~len-sym) (rest form))
                     form))
                 body)]
    `(loop [~len-sym 0
            ~@bindings]
       (if (or (not *print-length*) (< ~len-sym *print-length*))
         (do ~@body)
         (.write *out* "...")))))

(defn pprint-newline
  "Emit a newline to the output buffer.

  ``:kind`` must be one of the following:
  - ``:linear``
  - ``:mandatory``
  - ``:miser``
  - ``:fill``"
  [kind]
  (when-not (#{:linear :mandatory :miser :fill} kind)
    (throw
     (ex-info "Newline must be one of: :linear, :mandatory, :miser, :fill"
              {:kind kind})))
  (pp-newline *out* kind))

;;;;;;;;;;;;;;;;;;;;;
;; Simple Dispatch ;;
;;;;;;;;;;;;;;;;;;;;;

(defmulti simple-dispatch type)

(defmethod simple-dispatch :default
  [obj]
  (pr obj))

(defmethod simple-dispatch python/int
  [obj]
  (if-let [base (case *print-base*
                  2  "{0:b}"
                  8  "{0:o}"
                  10 "{}"
                  16 "{0:x}"
                  nil)]
    (print (.format base obj))
    (throw
     (ex-info "Invalid integral base" {:base *print-base*}))))

;; This `python/bool` override is required because Python `bool` types are also
;; instances of `python/int`, so they will be caught by the `int` dispatch otherwise.
(defmethod simple-dispatch python/bool
  [obj]
  (pr obj))

(defmethod simple-dispatch fractions/Fraction
  [obj]
  (*print-pprint-dispatch* (numerator obj))
  (print "/")
  (*print-pprint-dispatch* (denominator obj)))

(defmethod simple-dispatch basilisp.lang.symbol/Symbol
  [obj]
  (if *print-suppress-namespaces*
    (print (name obj))
    (pr obj)))

(defn ^:private print-simple-coll
  "Print a non-associative collection with the given prefix and suffix strings."
  [prefix suffix coll]
  (pprint-logical-block :prefix prefix :suffix suffix
                        (print-length-loop [v coll]
                                           (when (seq v)
                                             (write-out (first v))
                                             (when-let [more (seq (rest v))]
                                               (.write *out* " ")
                                               (pprint-newline :linear)
                                               (recur more))))))

(defmethod simple-dispatch basilisp.lang.interfaces/ISeq
  [obj]
  (print-simple-coll "(" ")" obj))

(defmethod simple-dispatch basilisp.lang.interfaces/IPersistentList
  [obj]
  (print-simple-coll "(" ")" obj))

(defmethod simple-dispatch basilisp.lang.interfaces/IPersistentSet
  [obj]
  (print-simple-coll "#{" "}" obj))

(defmethod simple-dispatch basilisp.lang.interfaces/IPersistentVector
  [obj]
  (print-simple-coll "[" "]" obj))

(defmethod simple-dispatch basilisp.lang.interfaces/IPersistentMap
  [obj]
  (pprint-logical-block :prefix "{" :suffix "}"
                        (print-length-loop [m obj]
                                           (when (seq m)
                                             (let [[k v] (first m)]
                                               (write-out k)
                                               (.write *out* " ")
                                               (write-out v)
                                               (pprint-newline :linear)
                                               (when-let [more (seq (rest m))]
                                                 (.write *out* " ")
                                                 (recur more)))))))

(alter-var-root #'*print-pprint-dispatch* (constantly simple-dispatch))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pretty Printing Public API ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn write-out
  [object]
  (let [length-reached? (and *current-length*
                             *print-length*
                             (>= *current-length* *print-length*))]
    (if *print-pretty*
      (if length-reached?
        (print "...")
        (do
          (when-let [l *current-length*]
            (set! *current-length* (inc l)))
          (*print-pprint-dispatch* object)))
      (pr object))))

(defn pprint
  "Pretty print ``object`` to the given ``writer``.

  If no ``writer`` is given, the value bound to :lpy:var:`basilisp.core/*out*` is
  used."
  ([object]
   (pprint object *out*))
  ([object writer]
   (binding [*out*          (get-pretty-writer writer)
             *print-pretty* true]
     (write-out object)
     (newline))))

(defn pp
  "Print the last thing output to the REPL.

  Equivalent to calling ``(pprint *1)``."
  []
  (pprint *1))

(defn print-table
  "Print a collection of maps as a table to the buffer currently bound to
  :lpy:var:`basilisp.core/*out*`.

  If there is at least one element in ``rows``, a header row will be printed
  followed by a single divider row followed by a line for each element in ``rows``.

  If no keys are given (as ``ks``), then use the keys returned from the first
  element in ``rows`` (as by ``(keys (first rows))``). Note that in this case,
  the order of headers in the resulting table is based on the order of keys
  returned by :lpy:fn:`basilisp.core/keys`."
  ([rows]
   (when (seq rows)
     (print-table (keys (first rows)) rows)))
  ([ks rows]
   (when (seq rows)
     (let [widths (persistent!
                   (reduce (fn [counts row]
                             (reduce (fn [counts [k col]]
                                       (if-let [cnt (get counts k)]
                                         (->> (max cnt (count (str col)))
                                              (assoc! counts k))
                                         counts))
                                     counts
                                     row))
                           (->> ks
                                (map (comp count str))
                                (zipmap ks)
                                transient)
                           rows))]
       (letfn [(fmt-row [start end joiner elems]
                 (as-> elems $
                   (str/join joiner $)
                   (str start $ end)))
               (row-str [row]
                 (->> (map #(str/lpad (str (get row %)) (get widths %)) ks)
                      (fmt-row "| " " |" " | ")))]
         (println (row-str (zipmap ks ks)))
         (->> (map #(apply str (repeat (get widths %) "-")) ks)
              (fmt-row "+-" "-+" "-+-")
              (println))
         (doseq [row rows]
           (println (row-str row))))))))
