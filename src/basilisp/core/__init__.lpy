(in-ns 'basilisp.core)

(def list
  (fn* list [& args] args))

(def
  ^{:doc "If o is a Seq, return the first element from o. If o is nil, return
          nil. Otherwise, coerces o to a Seq and returns the first."}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc "If o is a Seq, return the elements after the first in o. If o is nil,
          returns an empty seq. Otherwise, coerces o to a seq and returns the rest."}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc "Calls rest on o. If o returns an empty sequence or nil, returns nil.
          Otherwise, returns the elements after the first in o."}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc "Returns the second element in a Seq."}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc "Returns the first element in the first element of a Seq."}
  ffirst
  (fn* ffirst [seq] (first (first seq))))

(def
  ^{:doc "Creates a new sequence where o is the first element and seq is the rest.
    If seq is nil, return a list containing o. If seq is not a Seq, attempt
    to coerce it to a Seq and then cons o onto the resulting sequence."}
  cons
  (fn* cons [v seq] (basilisp.lang.runtime/cons v seq)))

(def meta
  (fn* meta [o]
       (.-meta o)))

(def with-meta
  (fn* with-meta [o meta]
       (.with-meta o meta)))

(def ^:macro ^:redef let
  (fn* let [&form & decl]
       (cons 'let* decl)))

(def ^:macro ^:redef loop
  (fn* loop [&form & decl]
       (cons 'loop* decl)))

(def ^:macro ^:redef fn
  (fn* fn [&form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def identity
  (fn identity [v] v))

(def
  ^{:doc "Return true if obj is an instance of class."}
  instance?
  (fn instance? [class obj]
    (builtins/isinstance obj class)))

(def
  ^{:doc "Return true if obj is a boolean."}
  boolean?
  (fn boolean? [o]
    (instance? builtins/bool o)))

(def
  ^{:doc "Return true if obj is a float."}
  float?
  (fn float? [o]
    (instance? builtins/float o)))

(def
  ^{:doc "Return true if obj is an integer."}
  integer?
  (fn integer? [o]
    (instance? builtins/int o)))

(def
  ^{:doc "Return true if obj is a string."}
  string?
  (fn string? [o]
    (instance? builtins/str o)))

(def
  ^{:doc "Return true if obj is a symbol."}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc "Return true if obj is a keyword."}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc "Return true if o is a list."}
  list?
  (fn list? [o]
    (instance? basilisp.lang.list/List o)))

(def
  ^{:doc "Return true if o is a map."}
  map?
  (fn map? [o]
    (instance? basilisp.lang.map/Map o)))

(def
  ^{:doc "Return true if o is a set."}
  set?
  (fn set? [o]
    (instance? basilisp.lang.set/Set o)))

(def
  ^{:doc "Return true if o is a vector."}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.vector/Vector o)))

(def
  ^{:doc "Return true if o implements Seq."}
  seq?
  (fn seq? [o]
    (instance? basilisp.lang.seq/Seq o)))

(def seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def
  ^{:doc "Create a hash map from pairs of input arguments."}
  hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def
  ^{:doc "Create a set from the input arguments."}
  hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def
  ^{:doc "Return a set with the contents of coll."}
  set
  (fn set
    [coll]
    (^:allow-builtins basilisp.lang.set/set coll)))

(def
  ^{:doc "Create a vector from the input arguments."}
  vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def
  ^{:doc "Return a vector with the contents of coll."}
  vec
  (fn vec
    [coll]
    (basilisp.lang.vector/vector coll)))

;;;;;;;;;;;; full support for syntax quote begins here ;;;;;;;;;;;;

(def count
  (fn count [coll]
    (try
      (builtins/len coll)
      (catch TypeError _
        (count (apply vector coll))))))

(def
  ^{:doc "Returns a basilisp.lang.exception/ExceptionInfo instance with
          the given message and data."}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:doc "Associate keys to values in associative data structure m. If m is nil,
          returns a new map with key-values kvs."}
  assoc
  (fn assoc [m & kvs]
    (apply basilisp.lang.runtime/assoc m kvs)))

(def
  ^{:doc "Conjoin xs to collection. New elements may be added in different positions
          depending on the type of coll. conj returns the same type as coll. If coll
          is nil, return a list with xs conjoined."}
  conj
  (fn conj [coll & xs]
    (apply basilisp.lang.runtime/conj coll xs)))

(def
  ^{:macro true
    :doc   "Define a new function with an optional docstring."}
  defn
  (fn defn [&form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (builtins/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          fname  (if doc
                   (with-meta name {:doc doc})
                   name)
          body   (if doc
                   (rest body)
                   body)
          multi? (list? (first body))
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))]
      `(def ~fname
         (fn ~fname
              ~@body)))))

(defn nth
  "Returns the ith element of coll (0-indexed), if it exists.
  nil otherwise. If i is out of bounds, throws an IndexError unless
  notfound is specified."
  ([coll i]
   (basilisp.lang.runtime/nth coll i))
  ([coll i notfound]
   (basilisp.lang.runtime/nth coll i notfound)))

(defn nthnext
  "Returns the nth next sequence of coll.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn nthrest
  "Returns the nth rest sequence of coll, or coll if i is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn last
  "Return the last item in a seq, or nil if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(defn str
  "Create a string representation of o."
  ([] "")
  ([o] (basilisp.lang.runtime/lstr o))
  ([o & args]
   (let [coerce (fn [in out]
                  (if (seq (rest in))
                    (recur (rest in)
                           (conj out (basilisp.lang.runtime/lstr (first in))))
                    (conj out (basilisp.lang.runtime/lstr (first in)))))
         strs   (coerce (conj args o) [])]
     (.join "" strs))))

(defn symbol
  "Create a new symbol with name and optional namespace ns."
  ([name]
   (basilisp.lang.symbol/symbol name))
  ([ns name]
   (basilisp.lang.symbol/symbol name ns)))

(defn keyword
  "Create a new keyword with name and optional namespace ns. Keywords
  will have the colon prefix added automatically, so it should not be
  provided."
  ([name]
   (basilisp.lang.keyword/keyword name))
  ([ns name]
   (basilisp.lang.keyword/keyword name ns)))

(defn name
  "Return the name of a string, symbol, or keyword."
  [v]
  (if (string? v)
    v
    (.-name v)))

(defn namespace
  "Return the namespace of a symbol or keyword, or nil if no namespace."
  [v]
  (.-ns v))

(def
  ^{:macro true
    :doc   "Define a new macro like defn. Macro functions are available to the
            compiler during macroexpansion."}
  defmacro
  (fn defmacro [&form name & body]
    (let [body  (concat body)
          doc   (if (string? (first body))
                  (first body)
                  nil)
          fname (with-meta (if doc
                             (with-meta name {:doc doc})
                             name)
                  {:macro true})
          body  (if doc
                  (rest body)
                  body)

          add-implicit-args (fn [body]
                              (cons
                               (if (vector? (first body))
                                 (apply vector (cons '&form (first body)))
                                 (throw
                                  (ex-info "Expected an argument vector"
                                           {:found (first body)})))
                               (rest body)))

          add-args-for-each (fn [in out]
                              (if (seq (rest in))
                                (recur (rest in)
                                       (conj out (add-implicit-args (first in))))
                                (conj out (add-implicit-args (first in)))))

          multi? (list? (first body))
          body   (if multi?
                   (add-args-for-each body [])
                   (add-implicit-args body))]
      `(defn ~fname
         ~@body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Comparisons & Macros ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro if-not
  "Evaluate cond and if it is true, return false-cond. Otherwise return
  true-cond."
  [cond true-cond false-cond]
  `(if ~cond
     ~false-cond
     ~true-cond))

(defmacro when
  "Evaluate cond and if it is true, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     (do ~@body)
     nil))

(defmacro when-not
  "Evaluate cond and if it is false, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     nil
     (do ~@body)))

(defmacro and
  "Evaluate the expressions from left to right. If all expressions are true,
  return the result of the final expression. Otherwise, returns the first
  false expression. Calling and with no arguments returns true."
  ([] true)
  ([& args]
   (if (seq (rest args))
     `(if ~(first args)
        (and ~@(rest args))
        ~(first args))
     (first args))))

(defmacro or
  "Evaluate the expressions from left to right. Returns the first true
  expression. Otherwise, returns the final falsy expression. Calling or
  with no arguments returns nil."
  ([] nil)
  ([& args]
   (if (seq (rest args))
     `(if ~(first args)
        ~(first args)
        (or ~@(rest args)))
     (first args))))

(defmacro cond
  "Given groups of test/expression pairs, evaluate each test and, if
  true, return the expression. Otherwise, continue through until reaching
  the final expression."
  [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw
             (ex-info "cond requires an even number of forms"
                      {:first (first clauses)})))
          (cons 'basilisp.core/cond (nthrest clauses 2)))))

(defn not
  "Return the logical negation of expr."
  [expr]
  (if expr false true))

(defn false?
  "Return true if x is false, otherwise false."
  [x]
  (operator/is- x false))

(defn true?
  "Return true if x is true, otherwise false."
  [x]
  (operator/is- x true))

(defn nil?
  "Return true if x is nil, otherwise false."
  [x]
  (operator/is- x nil))

(defn some?
  "Return true if x is not nil, otherwise false."
  [x]
  (not (nil? x)))

(defn any?
  "Return true for any x."
  [_]
  true)

(defn =
  "Return true if x and y are equal, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (basilisp.lang.runtime/equals x (first args))
       (recur (first args) (rest args))
       false)
     (basilisp.lang.runtime/equals x (first args)))))

(defn not=
  "Return true if x and y are not equal, otherwise false."
  [& args]
  (not (apply = args)))

(defn >
  "Return true if arguments are monotonically decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/gt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/gt x (first args)))))

(defn >=
  "Return true if arguments are decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/ge x (first args))
       (recur (first args) (rest args))
       false)
     (operator/ge x (first args)))))

(defn <
  "Return true if arguments are monotonically increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/lt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/lt x (first args)))))

(defn <=
  "Return true if arguments are increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/le x (first args))
       (recur (first args) (rest args))
       false)
     (operator/le x (first args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Management Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn deref
  "Dereference a delay or atom and returns its contents."
  [o]
  (basilisp.lang.runtime/deref o))

(defn compare-and-set!
  "Atomically set the value of atom to new-val if and only if old-val
  is the current value of the atom."
  [atom old-val new-val]
  (.compare-and-set atom old-val new-val))

(defn reset!
  "Reset the value of an atom to v without regard to the previous value.
  Return the new value."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      v
      (recur atom v))))

(defn swap!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return the new value."
  [atom f & args]
  (apply basilisp.lang.runtime/swap atom f args))

(defn atom
  "Return an Atom containing v. The value of an Atom at any point in time
  may be returned by deref'ing it. The value of an atom may be reset using
  reset! and may be swapped using swap!. All operations on an atom occur
  atomically."
  [v]
  (basilisp.lang.atom/Atom v))

(defn realized?
  "Return true if the delay or lazy sequence has been realized."
  [o]
  (.-is-realized o))

(defmacro delay
  "Takes a body of expressions producing any value. Will not produce a
  value until deref'ed. The result is cached and returned in future
  derefs."
  [& body]
  (list 'basilisp.lang.delay/Delay
        (concat '(fn* []) body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/add x (first args)) (rest args))
     (operator/add x (first args)))))

(defn -
  "Subtract the arguments. If one argument given, returns the negation
  of that argument."
  ([x] (operator/neg x))
  ([x & args]
   (if (seq (rest args))
     (recur (operator/sub x (first args)) (rest args))
     (operator/sub x (first args)))))

(defn *
  "Multiply the arguments. If no arguments given, returns 1."
  ([] 1)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/mul x (first args)) (rest args))
     (operator/mul x (first args)))))

(defn /
  "Divide the arguments. If no arguments given, returns the inverse of
  the argument."
  ([x] (basilisp.lang.runtime/divide 1 x))
  ([x & args]
   (if (seq (rest args))
     (recur (basilisp.lang.runtime/divide x (first args)) (rest args))
     (basilisp.lang.runtime/divide x (first args)))))

(defn mod
  "Returns the modulo of num and div."
  [num div]
  (operator/mod num div))

(defn quot
  "Returns the quotient of num and div."
  [num div]
  (basilisp.lang.runtime/quotient num div))

(defn rem
  "Returns the remainder of num and div."
  [num div]
  (- num (* div (quot num div))))

(defn inc
  "Increment the argument by 1."
  [x]
  (+ x 1))

(defn dec
  "Decrement the argument by 1."
  [x]
  (- x 1))

(defn pos?
  "Return true if x is positive."
  [x]
  (if (operator/gt x 0) true false))

(defn non-neg?
  "Return true if x is not negative."
  [x]
  (if (operator/ge x 0) true false))

(defn zero?
  "Return true if x is 0."
  [x]
  (= 0 x))

(defn neg?
  "Return true if x is negative."
  [x]
  (if (operator/lt x 0) true false))

(defn even?
  "Return true if x is even."
  [x]
  (if (= 0 (mod x 2)) true false))

(defn odd?
  "Return true if x is odd."
  [x]
  (if (= 1 (mod x 2)) true false))

(defn min
  "Return the minimum of the arguments."
  [& args]
  (builtins/min args))

(defn max
  "Return the maximum of the arguments."
  [& args]
  (builtins/max args))

(defn sort
  "Return a sorted sequence of the elements from coll."
  ([coll]
   (basilisp.lang.runtime/sort coll))
  ([cmp coll]
   (basilisp.lang.runtime/sort coll cmp)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn contains?
  "Return true if coll contains k. For vectors, k is an index. For maps, k is
  a key. For sets, k is a value in the set."
  [coll k]
  (basilisp.lang.runtime/contains coll k))

(defn disj
  "Return a new version of the set s without the given elements. If the elements
  don't exist in s, they are ignored."
  ([s] s)
  ([s & elems]
   (apply (.-disj s) elems)))

(defn dissoc
  "Return a new version of m without the given keys. If the keys
  don't exist in m, they are ignored."
  [m & ks]
  (apply (.-dissoc m) ks))

(defn get
  "Return the entry of m corresponding to k if it exists or nil/default otherwise."
  ([m k]
   (basilisp.lang.runtime/get m k))
  ([m k default]
   (basilisp.lang.runtime/get m k default)))

(defn update
  "Updates the value for key k in associative data structure m with the return value
  from calling (f old-v & args). If m is nil, use an empty map. If k is not in m,
  old-v will be nil."
  [m k f & args]
  (apply basilisp.lang.runtime/update m k f args))

(defn key
  "Return the key from a map entry."
  [entry]
  (.-key entry))

(defn val
  "Return the val from a map entry."
  [entry]
  (.-value entry))

(defn keys
  "Return a seq of the keys from a map."
  [m]
  (seq (.keys m)))

(defn vals
  "Return a seq of the values from a map."
  [m]
  (seq (.values m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher Order Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro lazy-seq
  "Takes a body of expressions which will produce a seq or nil. When
  seq is first called on the resulting lazy-seq, the sequence will be
  realized."
  [& body]
  (list 'basilisp.lang.seq/LazySeq
        (concat '(fn* []) body)))

(defn iterate
  "Returns a lazy sequence of (f x), (f (f x)) and so on."
  [f x]
  (lazy-seq
   (let [v (f x)]
     (when v
       (cons v (iterate f v))))))

(defn range
  "Return a range of integers from start. If end is specified, the
  sequence will terminate at end."
  ([]
   (iterate inc -1))
  ([end]
   (lazy-seq (cons 0 (range 1 end))))
  ([start end]
   (lazy-seq (cons start (when (< start (dec end))
                           (range (inc start) end)))))
  ([start end step]
   (lazy-seq (let [next-int (+ start step)]
               (cons start (when (< next-int (dec end))
                             (range next-int end step)))))))

(defn complement
  "Return a function which returns the logical complement of the return
  value of (apply f args)."
  [f]
  (fn [& args]
    (not (apply f args))))

(defn constantly
  "Returns a function that accepts any number of arguments and returns x."
  [x]
  (fn [& ^:no-warn-when-unused args] x))

(defn reduce
  "Reduce coll by f.

  If val is not supplied and coll has no elements, f will be called
  with no arguments and the result will be returned.

  If val is not supplied and coll has one element, the result of
  (f (first val)) is returned.

  If val is not supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll.

  If val is supplied and coll has no elements, the result of (f val)
  is returned.

  If val is supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll, starting with val."
  ([f coll]
   (if (seq coll)
     (if (seq (rest coll))
       (reduce f (first coll) (rest coll))
       (first coll))
     (f)))
  ([f val coll]
   (let [reduce-coll (fn [out in]
                       (if (seq in)
                         (recur (f out (first in)) (rest in))
                         out))]
     (if (seq coll)
       (reduce-coll val coll)
       (f val)))))

(defn comp
  "Return a function which is the composition of all the functions
  given as arguments. Note that, as in mathematical function composition,
  the argument functions are called from right to left."
  ([] identity)
  ([f] f)
  ([f & args]
   (let [composed (reduce (fn [f g]
                            (fn [& args]
                              (f (apply g args))))
                          f
                          args)]
     (fn [& inner-args]
       (apply composed inner-args)))))

(defn juxt
  "Return a function which takes any number of arguments and applies each of
  the argument functions to this function in order, returning a vector of the
  return values from each function."
  [& args]
  (fn [& inner-args]
    (reduce (fn [v f]
              (conj v (apply f inner-args)))
            []
            args)))

(defn partial
  "Return a function which is the partial application of f with args."
  [f & args]
  (apply basilisp.lang.runtime/partial f args))

(defn every?
  "Return true if every element in coll satisfies pred."
  [pred coll]
  (cond
    (nil? (seq coll))   true
    (pred (first coll)) (recur pred (rest coll))
    :else               false))

(def
  ^{:doc "Return true if not every element in coll satisfies pred."}
  not-every?
  (comp not every?))

(defn some
  "Return true if at least one element in coll satisfies pred."
  [pred coll]
  (when (seq coll)
    (or (pred (first coll))
        (recur pred (rest coll)))))

(def
  ^{:doc "Return true if no element in coll satisfies pred."}
  not-any?
  (comp not some))

(defn map
  "Return a lazy sequence of (f elem) for elements in coll."
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (cons (f (first coll)) (map f (rest coll))))))
  ([f coll & colls]
   (lazy-seq
    (when (and (seq coll) (every? seq colls))
      (cons (apply f (first coll) (map first colls))
            (apply map f (rest coll) (map rest colls)))))))

(defn map-indexed
  "Return a lazy sequence of (f idx elem) for elements in coll. The
  index starts at 0."
  [f coll]
  (map f (range) coll))

(defn mapcat
  "Return a lazy sequence of the concatenated results of mapping f over
  colls."
  [f & colls]
  (apply concat (apply map f colls)))

(defn filter
  "Return elements from coll where (pred elem) returns true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (cons (first coll) (filter pred (rest coll)))
       (filter pred (rest coll))))))

(defn remove
  "Return elements from coll where (pred elem) returns false."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (not (pred (first coll)))
       (cons (first coll) (remove pred (rest coll)))
       (remove pred (rest coll))))))

(defn take
  "Return the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (when (> n 0)
       (cons (first coll) (take (dec n) (rest coll)))))))

(defn take-while
  "Return elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (when (pred (first coll))
       (cons (first coll) (take-while pred (rest coll)))))))

(defn drop
  "Drop the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (> n 0)
       (drop (dec n) (rest coll))
       (seq coll)))))

(defn drop-while
  "Drop elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (drop-while pred (rest coll))
       (seq coll)))))

(defn drop-last
  "Drop all but the last n items of coll."
  ([coll]
   (drop-last 1 coll))
  ([n coll]
   (map (comp first vector) coll (drop n coll))))

(defn split-at
  "Split a collection at the nth item. Returns a vector of
  [(take n coll) (drop n coll)]."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Split a collection at the inflection point of pred. Returns a
  vector of [(take-while pred coll) (drop-while pred coll)]."
  [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

(defn group-by
  "Return a map whose keys are the result of calling f on each element
  in coll and whose values are vectors of the values which produced the
  corresponding key, in the order they were added."
  [f coll]
  (if-not (seq coll)
    {}
    (reduce (fn [m v]
              (let [group (f v)]
                (if (contains? m group)
                  (update m group conj v)
                  (assoc m group [v]))))
            {}
            coll)))

(defn interpose
  "Return a lazy sequence of elements of coll separated by sep. If
  coll is empty, return an empty sequence."
  [sep coll]
  (lazy-seq
   (when (seq coll)
     (if (seq (rest coll))
       (cons (first coll)
             (cons sep (interpose sep (rest coll))))
       (cons (first coll) nil)))))

(defn cycle
  "Cycle the items in coll infinitely."
  [coll]
  (let [coll-cycle (fn coll-cycle
                     [curr]
                     (lazy-seq
                      (if (seq curr)
                        (cons (first curr) (coll-cycle (rest curr)))
                        (coll-cycle coll))))]
    (coll-cycle coll)))

(defn repeat
  "Repeat x infinitely or n many times if n is specified. Returns a lazy
  sequence of the x."
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (lazy-seq
    (when (> n 0)
      (cons x (repeat (dec n) x))))))

(defn repeatedly
  "Call f infinitely or n many times if n is specified. Returns a lazy
  sequence of the return values."
  ([f]
   (lazy-seq (cons (f) (repeatedly f))))
  ([n f]
   (lazy-seq
    (when (> n 0)
      (cons (f) (repeatedly (dec n) f))))))

(defn take-nth
  "Return a lazy sequence of every nth element of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (<= n 0)
       (repeat (first coll))
       (cons (first coll)
             (take-nth n (drop (dec n) (rest coll))))))))

(defn partition
  "Return a lazy sequence of partitions of coll of size n at offsets
  of step elements. If step is not given, steps of size n will be used
  and there will be no overlap between partitions. If pad is given,
  partition will pull elements from pad until the final sequence is
  equal to size n."
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (cons (take n coll) (partition n step (drop step coll))))))
  ([n step pad coll]
   (lazy-seq
    (when (seq coll)
      (let [s  (take n coll)
            ns (count s)
            s  (if (< ns n)
                 (concat s (take (- n ns) pad))
                 s)]
        (cons s (partition n step pad (drop step coll))))))))

(defn merge
  "Merge maps together from left to right as by conj. If a duplicate key
  appears in a map, the rightmost map's value for that key will be taken."
  [& maps]
  (when (some identity maps)
    (reduce #(conj %1 %2)
            {}
            maps)))

;;;;;;;;;;;;;;;;;;;;
;; Utility Macros ;;
;;;;;;;;;;;;;;;;;;;;

(defmacro apply-method
  "Apply arguments to a method call. Equivalent to (apply (.-method o) args)."
  [o method & args]
  `(apply (.- ~o ~method) ~@args))

(defmacro comment
  "Ignore all the forms passed, returning nil."
  [& ^:no-warn-when-unused forms]
  nil)

(defmacro condp
  "Take a predicate and an expression and a series of clauses, call
  (pred test expr) on the first expression for each clause. The result
  expression from first the set of clauses for which this expression
  returns a truthy value will be returned from the condp expression.

  Clauses can take two forms:

  - test-expr result-expr
  - test-expr :>> result-fn, where :>> is a keyword literal

  For the ternary expression clause, the unary result-fn will be called
  with the result of the predicate."
  [pred expr & clauses]
  (when (seq clauses)
    (let [test-expr (first clauses)
          remaining (rest clauses)]
      (if (seq remaining)
        (let [result    (first remaining)
              remaining (rest remaining)]
          (cond
            (= result :>>) `(let [res# ~(list pred test-expr expr)]
                              (if res#
                                (~(first remaining) res#)
                                (condp ~pred ~expr ~@(rest remaining))))
            result         `(if ~(list pred test-expr expr)
                              ~result
                              (condp ~pred ~expr ~@remaining))
            :else          (throw
                            (ex-info "expected result expression"
                                     {:test test-expr}))))
        test-expr))))

(defmacro new
  "Create a new instance of class with args.

  New objects may be created as any of:
    (new builtins/str *args)
    (new builtins.str *args)
    (new builtins.str. *args)

  This is compatibility syntax for Clojure, since Python (and therefore
  Basilisp) do not require the new keyword for object instantiation."
  [class & args]
  (cond
    (not (symbol? class))
    (throw
     (ex-info "Expected a class name as a symbol"
              {:class-name class}))

    (namespace class)
    (let [n  (name class)
          ns (namespace class)
          s  (symbol (str ns "."
                          (if (.endswith n ".")
                            n
                            (str n "."))))]
      `(~s ~@args))

    :else
    (let [n (name class)
          s (symbol (if (.endswith n ".")
                      n
                      (str n ".")))]
      `(~s ~@args))))

(defmacro binding
  "Establish thread-local bindings for the vars given. The bindings are guaranteed
  to clear once execution passes outside the scope of this block."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [vvar (first bindings)
        val  (second bindings)]
    `(try
       (do
         (. (var ~vvar) ~'push-bindings ~val)
         ~@(if (nthnext bindings 2)
             [(concat
               (list 'binding (vec (nthrest bindings 2)))
               body)]
             body))
       (finally
         (. (var ~vvar) ~'pop-bindings)))))

(import* [time :as py-time])

(defn ^:private perf-counter
  []
  (py-time/perf-counter))

(defmacro time
  "Time the execution of expr. Return the result of expr and print the
  time execution took in milliseconds."
  [expr]
  `(let [start (perf-counter)]
     (try
       ~expr
       (finally
         (println (* 1000 (- (perf-counter) start)) "msecs")))))

;;;;;;;;;;;;;;;;;;;;;;
;; Threading Macros ;;
;;;;;;;;;;;;;;;;;;;;;;

(defmacro ->
  "Thread x through the forms. Places x in the second position of
  the first form, and then the resulting expression into the second
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->
        ~(if (seq? joining)
           (apply list (first joining) x (rest joining))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro ->>
  "Thread x through the forms. Places x in the last position of
  the first form, and then the resulting expression into the last
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->>
        ~(if (seq? joining)
           (concat joining (list x))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro some->
  "Thread x through the forms (as by ->) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (-> ~x ~(first forms))]
       (when-not (nil? result#)
         (some-> result# ~@(next forms))))
    x))

(defmacro some->>
  "Thread x through the forms (as by ->>) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (->> ~x ~(first forms))]
       (when-not (nil? result#)
         (some->> result# ~@(next forms))))
    x))

(defmacro cond->
  "Takes a test and form pair, threading x (as by ->) through each form for
  which the corresponding test evaluates as true. cond-> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (-> ~x ~(second clauses))
                ~x)]
       (cond-> e#
           ~@(nthnext clauses 2)))
    x))

(defmacro cond->>
  "Takes a test and form pair, threading x (as by ->>) through each form for
  which the corresponding test evaluates as true. cond->> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (->> ~x ~(second clauses))
                ~x)]
       (cond->> e#
         ~@(nthnext clauses 2)))
    x))

(defmacro as->
  "Bind x to name and thread it through the forms, replacing instances of name
  in forms with the threaded expression."
  [x name & forms]
  (if (seq forms)
    `(as->
         (let [~name ~x]
           ~(first forms))
         ~name
       ~@(next forms))
    x))

;;;;;;;;;;;;;;;;;;;;;;
;; Output Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;

(def ^:dynamic *in* sys/stdin)
(def ^:dynamic *out* sys/stdout)
(def ^:dynamic *err* sys/stderr)

(def ^:dynamic *print-sep* " ")

(defn repr
  "Return the reader representation of an object."
  [x]
  (basilisp.lang.runtime/lrepr x))

(defn flush
  "Flush the buffer currently bound to *out*."
  []
  (.flush *out*))

(defmacro with-out-str
  "Capture the contents of text sent to *out* and return the contents as a
  string."
  [& body]
  `(binding [*out* (io/StringIO)]
     ~@body
     (. *out* ~'getvalue)))

(defn pr
  "Print the arguments to the stream bound to *out* in a format which
  is readable by the reader. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space).

  Note that some dynamically created Basilisp forms (such keywords and
  symbols) and Python objects may not be readable again."
  ([] nil)
  ([x]
   (.write *out* (repr x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn prn
  "Same as pr, but appending a newline afterwards."
  ([]
   (.write *out* \newline)
   nil)
  ([x]
   (let [stdout *out*]
     (.write stdout (repr x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn pr-str
  "Return the contents of calling pr on the args as a string."
  [& args]
  (with-out-str
    (apply pr args)))

(defn prn-str
  "Return the contents of calling prn on the args as a string."
  [& args]
  (with-out-str
    (apply prn args)))

(defn print
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (print ""))
  ([x]
   (.write *out* (str x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn println
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (println ""))
  ([x]
   (let [stdout *out*]
     (.write stdout (str x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn print-str
  "Return the contents of calling print on the args as a string."
  [& args]
  (with-out-str
    (apply print args)))

(defn println-str
  "Return the contents of calling println on the args as a string."
  [& args]
  (with-out-str
    (apply println args)))

;;;;;;;;;;;;;;;;;;;;
;; REPL Utilities ;;
;;;;;;;;;;;;;;;;;;;;

(def
  ^{:doc "The default data readers used in reader macros. Overriding or
          attempting to change the root binding of this var will not
          change the default data readers."}
  default-data-readers
  (.--DATA-READERS basilisp.lang.reader/ReaderContext))

(def
  ^{:doc     "Data readers map which will be merged in to the default data
              reader map used by the reader. Mappings should be qualified
              symbols to functions taking one argument. The function will
              receive an unevaluated data structure and must return some
              value to the reader."
    :dynamic true}
  *data-readers*
  {})

(def
  ^{:doc     "Resolver used for resolving namespace aliases when reading
              forms using read, read-string, etc."
    :dynamic true}
  *resolver*
  basilisp.lang.runtime/resolve-alias)

(defn read-string
  "Read a string of Basilisp code.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  Note that read-string should not be used to read string input from
  untrusted sources."
  ([s]
   (read-string {:eof :eofthrow} s))
  ([opts s]
   (first (basilisp.lang.reader/read-str s
                                         *resolver*
                                         *data-readers*
                                         (:eof opts)
                                         (if (= (:eof opts) :eofthrow)
                                           true
                                           false)))))

(defn read
  "Read the next form from the stream. If no stream is specified, uses
  the value currently bound to *in*.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  The stream must satisfy the interface of io.TextIOBase, but does not require
  any pushback capabilities. The default basilisp.lang.reader.StreamReader can
  wrap any object implementing TextIOBase and provide pushback capabilities."
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([opts stream]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     (:eof opts)
                                     (if (= (:eof opts) :eofthrow)
                                       true
                                       false))))
  ([stream eof-error? eof-value]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     eof-value
                                     eof-error?))))

(defn eval
  "Evaluate a form (not a string) and return its result."
  [form]
  (let [ctx    (basilisp.lang.compiler.CompilerContext.)
        module (.-module *ns*)]
    (basilisp.lang.compiler/compile-and-exec-form form
                                                  ctx
                                                  module
                                                  "<Eval Input>")))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defn the-ns
  "If v is a symbol, return the Namespace named by that symbol if it
  exists. If v is a Namespace, return it. Otherwise, throw an exception."
  [v]
  (cond
    (symbol? v)
    (.get basilisp.lang.runtime/Namespace v)

    (instance? basilisp.lang.runtime/Namespace v)
    v

    :else
    (throw
     (ex-info "Expected a Symbol or a Namespace"
              {:value v
               :type  (builtins/type v)}))))

(defn create-ns
  "Create a Namespace with the name ns-sym or return the existing one
  if it already exists."
  [ns-sym]
  (.get-or-create basilisp.lang.runtime/Namespace ns-sym))

(defn ns-aliases
  "Return a map of Basilisp namespaces which are aliased in the current
  namespace."
  [ns]
  (reduce (fn [m entry]
            (let [alias     (key entry)
                  namespace (symbol (name (val entry)))]
              (if (= alias namespace)
                m
                (assoc m alias namespace))))
          {}
          (.-aliases ns)))

(defn ns-imports
  "Return a set of Python modules which are imported in the current
  namespace."
  [ns]
  (.-imports ns))

(defn ns-interns
  "Return a map of symbols to Vars which are interned in the current
  namespace."
  [ns]
  (.-interns ns))

(defn ns-publics
  "Return a map of symbols to public Vars which are interned in the
  current namespace.

  Public vars are Vars which are declared without :private metadata."
  [ns]
  (let [interns (ns-interns ns)]
    (if-not (seq interns)
      {}
      (reduce (fn [m entry]
                (if (:private (meta (val entry)))
                  m
                  (assoc m (key entry) (val entry))))
              {}
              interns))))

(defn ns-refers
  "Return a map of symbols to Vars which are referred in the current
  namespace."
  [ns]
  (.-refers ns))

(defn ns-map
  "Return a map of all the mapped symbols in the namespace.

  Includes the return values of ns-interns and ns-refers in one map."
  ([] (ns-map *ns*))
  ([ns]
   (merge
    (ns-interns ns)
    (ns-refers ns))))

(defn ns-resolve
  "Return the Var which will be resolved by the symbol in the given namespace."
  [ns sym]
  (basilisp.lang.runtime/resolve-var sym ns))

(defn resolve
  "Return the Var which will be resolved by the symbol in the namespace currently
  bound to *ns*."
  [sym]
  (ns-resolve *ns* sym))

(defmacro import
  "Import a Python module by name."
  [module]
  `(import* ~module))

(defn refer
  "Refer Vars from the namespace named by ns-sym, subject to the filters specified.

  Supported filters:
  - :only [sym1 sym2], to only refer the specified symbols
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name"
  [ns-sym & filters]
  (let [current-ns *ns*
        ns         (the-ns ns-sym)
        filter-map (apply hash-map filters)]
    (if-not (seq filters)
      (.refer-all current-ns ns)
      (let [only    (set (:only filter-map))
            exclude (set (:exclude filter-map))
            rename  (or (:rename filter-map) {})

            interns (if (seq only)
                      (filter (fn [entry]
                                (contains? only (key entry)))
                              (ns-interns ns))
                      (ns-interns ns))
            interns (if (seq exclude)
                      (remove (fn [entry]
                                (contains? exclude (key entry)))
                              interns)
                      interns)
            interns (if (seq rename)
                      (reduce (fn [m entry]
                                (if (rename (key entry))
                                  (assoc m (rename (key entry)) (val entry))
                                  m))
                              {}
                              interns)
                      interns)

            do-refer (fn [refers]
                       (when (seq refers)
                         (let [entry (first (seq refers))
                               sym   (key entry)
                               var   (val entry)]
                           (.add-refer current-ns sym var)
                           (recur (rest refers)))))]
        (do-refer interns)))))

(import importlib)

(defn ^:private add-refers
  "Refer all of the Vars named in syms from from-ns to to-ns."
  [to-ns from-ns syms]
  (when (seq syms)
    (let [var-sym (first syms)
          var     (get (ns-interns from-ns) var-sym)]
      (.add-refer to-ns var-sym var)
      (recur to-ns from-ns (rest syms)))))

(defn ^:private require-vec
  "Process a vector libspec for require."
  [current-ns v]
  (let [ns-sym (first v)
        opts   (apply hash-map (rest v))]
    (importlib/import-module (name ns-sym))
    (let [new-ns (the-ns ns-sym)]
      ;; Add the namespace alias
      (.add-alias current-ns (or (:as opts) ns-sym) new-ns)

      ;; Add refers
      (cond
        (= :all (:refer opts))
        (.refer-all current-ns new-ns)

        (:refer opts)
        (add-refers current-ns new-ns (:refer opts))

        :else nil))))

(defn ^:private require-sym
  "Process a symbol libspec for require."
  [s]
  (importlib/import-module (name s)))

(defn require
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:
  - symbols, which name fully qualified namespaces
  - vectors, which take the form [namespace-symbol & opts]

  Vector libspec arguments must be one of:
  - :as name, which will alias the imported namespace to the symbol name
  - :refer [& syms], which will refer syms in the local namespace directly"
  [& args]
  (let [current-ns *ns*

        do-require (fn [requires]
                     (when (seq requires)
                       (let [v (first requires)]
                         (cond
                           (vector? v) (require-vec current-ns v)
                           (symbol? v) (require-sym v)
                           :else             (throw
                                              (ex-info "Invalid libspec for require"
                                                       {:value v}))))
                       (recur (rest requires))))]
    (do-require args)
    (set! '*ns* current-ns)
    nil))

(defmacro ns
  "Use this namespace pre-amble at the top of every namespace to declare
  the namespace name and import necessary Python modules and require
  Basilisp namespaces.

  You may include an optional docstring for the namespace to describe its
  purpose.

  Example:
    (ns my.namespace
       \"My namespace with code\"
       (:require
         [basilisp.string :as str])
       (:import inspect))"
  [name & opts]
  (when-not (and (symbol? name) (nil? (namespace name)))
    (throw (ex-info "Namespace name must be a non-namespaced symbol"
                    {:name name})))
  (let [doc  (when (string? (first opts))
               (first opts))
        opts (if doc (rest opts) opts)
        opts (when (seq opts)
               (reduce (fn [m opt]
                         (let [opt-name (first opt)
                               options  (rest opt)]
                           (when-not (keyword? opt-name)
                             (throw (ex-info "Namespace option must be a keyword"
                                             {:option opt-name})))
                           (assoc m opt-name (vec options))))
                       {}
                       opts))

        requires (when (:require opts)
                   `(require ~@(map #(list 'quote %) (:require opts))))
        imports  (when (:import opts)
                   (map (fn [v]
                          `(import ~v))
                        (:import opts)))]
    `(do
       (in-ns (quote ~name))
       ~requires
       ~@imports)))

;;;;;;;;;;;;;;;;;;;;;
;; Regex Functions ;;
;;;;;;;;;;;;;;;;;;;;;

(import re)

(defn re-pattern
  "Return a new re.Pattern instance."
  [s]
  (re/compile s))

(defn re-find
  "Returns the first match of a string to a pattern using re.search.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/search pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn re-matches
  "Returns a match of a string to a pattern using re.fullmatch.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/fullmatch pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn ^:private lazy-re-seq
  "Return a lazy sequence of the matches in a match iterator."
  [iter]
  (lazy-seq
   (when (first iter)
     (let [match (.group (first iter) 0)]
       (cons match (when (seq (rest iter))
                     (lazy-re-seq (rest iter))))))))

(defn re-seq
  "Returns a lazy sequence of matches of a string to a pattern using re.finditer.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (lazy-re-seq (seq (re/finditer pattern s))))

;;;;;;;;;;;;;;;;;;
;; Multimethods ;;
;;;;;;;;;;;;;;;;;;

(import basilisp.lang.multifn)

(defmacro defmulti
  "Define a new multimethod with the dispatch function."
  [name & body]
  (let [doc         (when (string? (first body))
                      (first body))
        body        (if doc
                      (rest body)
                      body)
        dispatch-fn (first body)
        opts        (apply hash-map (rest body))]
    `(def ~name (basilisp.lang.multifn/MultiFunction ~(quote name)
                                                     ~dispatch-fn
                                                     ~(or (:default opts) :default)))))

(defmacro defmethod
  "Add a new method to the multi-function which responds to dispatch-val."
  [multifn dispatch-val & fn-tail]
  `(. ~multifn ~'add-method ~dispatch-val (fn ~@fn-tail)))

(defn methods
  "Return a map of dispatch values to methods for the given multi function."
  [multifn]
  (.-methods multifn))

(defn get-method
  "Return the method which would respond to dispatch-val or nil if no method
  exists for dispatch-val."
  [multifn dispatch-val]
  (.get-method multifn dispatch-val))

(defn remove-method
  "Remove the method which responds to dispatch-val, if it exists. Return the
  multi function."
  [multifn dispatch-val]
  (.remove-method multifn dispatch-val)
  multifn)

(defn remove-all-methods
  "Remove all method for this multi-function. Return the multi function."
  [multifn]
  (.remove-all-methods multifn)
  multifn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn select-keys
  "Return a map with only the keys of m which are in ks."
  [m ks]
  (if-not (seq ks)
    {}
    (reduce (fn [new-map k]
              (if (contains? m k)
                (assoc new-map k (get m k))
                new-map))
            {}
            ks)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Destructuring Support ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn gensym
  "Generate a unique symbol name of the form prefix_#. If no prefix is
  given, then v_ will be used."
  ([]
   (gensym "v_"))
  ([prefix]
   (symbol (basilisp.lang.util/genname prefix))))

(defmulti ^:private destructure-def
  (fn [arg]
    (cond
      (symbol? arg) :symbol
      (vector? arg) :vector
      (map? arg)    :map
      :else         :default)))

(defmethod destructure-def :map
  [arg]
  (let [alias (or (:as arg) (gensym "map_arg_"))

        ;; :or bindings allow users to specify default values for certain
        ;; associative keys.
        or-bindings (:or arg)

        ;; Namespaced keywords can destructure into non-namespaced
        ;; local names by specifying the namespace and with the name
        ;; "keys", just as the non-namespaced name "keys" will access
        ;; non-namespaced keywords.
        ;;
        ;; (let [{:movie/keys [title actors]} {:movie/title  "Die Hard"
        ;;                                     :movie/actors ["Bruce Willis"]}]
        ;;   ...)
        ;;
        kw-keys (->> (keys arg)
                     (filter keyword?)
                     (filter #(= "keys" (name %))))

        ;; Keyword, string, and symbol keys may all be destructured from
        ;; associative types.
        kws  (mapcat (fn [kw]
                       (let [kw-ns (namespace kw)
                             syms  (get arg kw)]
                         (cond->> syms
                           kw-ns (map #(symbol kw-ns (name %))))))
                     kw-keys)
        strs (:strs arg)
        syms (:syms arg)

        ;; Fetch all the remaining keys in the map which do not
        ;; correspond to special functionality.
        remaining (->> [:as :or :strs :syms]
                       (concat kw-keys)
                       (apply dissoc arg))

        ;; Destructuring forms may be nested arbitrarily, so generate the
        ;; definitions for any nested destructured forms as well.
        children (map #(vector % (destructure-def %)) (keys remaining))]
    {:name alias
     :type :map
     :keys kws
     :strs strs
     :syms syms

     :or-bindings or-bindings
     :remaining   (->> children
                       (filter #(not= :symbol (:type (second %))))
                       (map first)
                       (apply dissoc remaining))

     :children (map second children)}))

(defmethod destructure-def :symbol
  [arg]
  {:name arg
   :type :symbol})

(defmethod destructure-def :vector
  [arg]
  (let [;; Fetch the name bound to this argument with any trailing
        ;; :as key.
        alias-args (drop-while (partial not= :as) arg)
        alias      (->> alias-args (apply hash-map) :as)

        ;; Split the remaining arguments into sequential arguments
        ;; and the rest arg (if one at all).
        args (->> arg
                  (drop-last (count alias-args))
                  (split-with (partial not= '&)))

        sequential-args (first args)
        rest-arg        (second args)]
    {:name       (or alias (gensym "vec_arg_"))
     :type       :vector
     :rest       (when (seq rest-arg)
                   {:starts (count sequential-args)
                    :name   (second rest-arg)})
     :children   (map destructure-def sequential-args)}))

(defmethod destructure-def :default
  [arg]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (builtins/type arg)})))

(defmulti ^:private destructure-binding
  (fn [ddef]
    (:type ddef)))

(defmethod destructure-binding :vector
  [ddef]
  (let [fn-arg          (:name ddef)
        sequential-args (->> (:children ddef)
                             (map-indexed (fn [idx child]
                                            (let [alias (:name child)]
                                              (concat
                                               [alias `(nth ~fn-arg ~idx nil)]
                                               (when-not (= :symbol (:type child))
                                                 (destructure-binding child))))))
                             (apply concat))
        rest-def        (:rest ddef)
        rest-arg        (when rest-def
                          [(:name rest-def) `(nthnext ~fn-arg ~(:starts rest-def))])]
    (concat
     sequential-args
     rest-arg
     (->> (:children ddef)
          (filter #(not= :symbol (:type %)))
          (mapcat destructure-binding)))))

(defmethod destructure-binding :map
  [ddef]
  (let [fn-arg (:name ddef)
        ors    (:or-bindings ddef)

        kw-binding (fn [arg]
                     (let [kw-ns      (namespace arg)
                           kw-name    (name arg)
                           sym        (symbol kw-name)
                           kw         (if kw-ns
                                        (keyword kw-ns kw-name)
                                        (keyword kw-name))
                           or-binding (get ors sym)]
                       (if or-binding
                         [sym `(or (get ~fn-arg ~kw) ~or-binding)]
                         [sym `(get ~fn-arg ~kw)])))

        map-binding (fn [f arg]
                      (let [k          (f arg)
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg ~k) ~or-binding)]
                          [arg `(get ~fn-arg ~k)])))

        sym-binding (fn [arg]
                      (let [k          (symbol (name arg))
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg (quote ~k)) ~or-binding)]
                          [arg `(get ~fn-arg (quote ~k))])))

        rem-binding (fn [arg]
                      (let [binding    (key arg)
                            key        (val arg)
                            or-binding (get ors binding)]
                        (if or-binding
                          [binding `(or (get ~fn-arg (quote ~key)) ~or-binding)]
                          [binding `(get ~fn-arg ~key)])))

        child-binding (fn [child]
                        (let [alias (name (:name child))
                              arg   (symbol alias)
                              k     (keyword alias)]
                          [arg `(get ~fn-arg ~k)]))

        non-sym-children (filter #(not= :symbol (:type %)) (:children ddef))]
    (concat
     (mapcat kw-binding (:keys ddef))
     (mapcat (partial map-binding name) (:strs ddef))
     (mapcat sym-binding (:syms ddef))
     (mapcat rem-binding (:remaining ddef))
     (mapcat child-binding non-sym-children)
     (mapcat destructure-binding non-sym-children))))

(defmethod destructure-binding :default
  [ddef]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (:type ddef)})))

(defn ^:private fn-arity-with-destructuring
  "Take a function arity definition (an argument vector and 0 or more body
  expressions) whose argument vector may or may not require destructuring
  and return a function arity definition which uses only bare symbols and
  wraps the original definition in a let binding which performs the
  destructuring steps.

  As an example, for sequential destructuring like:

    (fn [[f & r]]
      {:first f
       :rest  r})

  This function would emit a list of:

    [vec_arg_3432]
    (let* [f (get vec_arg_3432 0)
           r (nthnext vec_arg_3432 1)]
      {:first f
       :rest  r})"
  [body]
  (let [args (first body)
        body (rest body)

        arg-groups (split-with (partial not= '&) args)
        args       (first arg-groups)
        rest-args  (second arg-groups)
        rest-defs  (map destructure-def rest-args)

        rest-binding (concat
                      (let [rest-arg (second rest-defs)]
                        (when (= :map (:type rest-arg))
                          `[~(:name rest-arg) (apply hash-map ~(:name rest-arg))]))
                      (->> rest-defs
                           (filter #(not= :symbol (:type %)))
                           (mapcat destructure-binding)))

        defs     (map destructure-def args)
        arg-vec  (vec (concat
                       (map :name defs)
                       (map :name rest-defs)))
        bindings (->> defs
                      (filter #(not= :symbol (:type %)))
                      (mapcat destructure-binding)
                      (concat rest-binding))
        new-body (if (seq bindings)
                   [`(let* [~@bindings]
                       ~@body)]
                   body)]
    (apply list arg-vec new-body)))

(defmacro ^:no-warn-on-redef fn
  "Return an anonymous (but possibly named) function.

  Function argument vectors support sequential and associative destructuring."
  [& body]
  (let [name    (when (symbol? (first body))
                  (first body))
        body    (cond-> body name rest)
        arities (cond
                  (vector? (first body))
                  (fn-arity-with-destructuring body)

                  (seq? (first body))
                  (map fn-arity-with-destructuring body)

                  :else
                  body)]
    (if name
      `(fn* ~name
            ~@arities)
      `(fn* ~@arities))))

(defn destructure
  "Take a [binding expr] pair (as from a let block) and produce all of the
  replacement bindings for the binding which perform destructuring on the
  initial expression.

  As an example, for sequential destructuring like:

    [f & r :as v] [1 2 3 4]

  This function would emit a list of bindings which can be inserted directly
  into a let* binding to perform destructuring:

     (v [1 2 3 4]
      f (nth v 0)
      r (nthnext v 1))"
  [[binding expr]]
  (let [ddef      (destructure-def binding)
        orig-name (:name ddef)
        bindings  (if (= :symbol (:type ddef))
                    []
                    (destructure-binding ddef))]
    (apply list orig-name expr bindings)))

(defmacro ^:no-warn-on-redef let
  "Let bindings with destructuring support."
  [bindings & body]
  (let [bindings (->> (partition 2 bindings)
                      (mapcat destructure))]
    `(let* [~@bindings]
       ~@body)))

(defn ^:private loop-with-destructuring
  "Take a loop definition (an binding vector and 0 or more body
  expressions) whose binding vector may or may not require destructuring
  and return a loop binding vector and loop body."
  [bindings body]
  (let [defs           (->> (take-nth 2 bindings)
                            (map destructure-def))
        binding-vec    (vec (mapcat (fn [ddef binding]
                                      [(:name ddef) binding])
                                    defs
                                    (take-nth 2 (drop 1 bindings))))
        inner-bindings (->> defs
                            (filter #(not= :symbol (:type %)))
                            (mapcat destructure-binding))
        new-body       (if (seq inner-bindings)
                         [`(let* [~@inner-bindings]
                             ~@body)]
                         body)]
    [binding-vec new-body]))

(defmacro ^:no-warn-on-redef loop
  "Loop bindings with destructuring support."
  [bindings & body]
  (let [[bindings body] (loop-with-destructuring bindings body)]
    `(loop* ~bindings
        ~@body)))
