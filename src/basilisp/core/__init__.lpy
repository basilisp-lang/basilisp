(in-ns 'basilisp.core)

(def list
  (fn* list [& args] args))

(def
  ^{:doc "If o is a Seq, return the first element from o. If o is nil, return
          nil. Otherwise, coerces o to a Seq and returns the first."}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc "If o is a Seq, return the elements after the first in o. If o is nil,
          returns an empty seq. Otherwise, coerces o to a seq and returns the rest."}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc "Calls rest on o. If o returns an empty sequence or nil, returns nil.
          Otherwise, returns the elements after the first in o."}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc "Returns the second element in a Seq."}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc "Returns the first element in the first element of a Seq."}
  ffirst
  (fn* ffirst [seq] (first (first seq))))

(def
  ^{:doc "Creates a new sequence where o is the first element and seq is the rest.
    If seq is nil, return a list containing o. If seq is not a Seq, attempt
    to coerce it to a Seq and then cons o onto the resulting sequence."}
  cons
  (fn* cons [v seq] (basilisp.lang.runtime/cons v seq)))

(def meta
  (fn* meta [o]
       (.-meta o)))

(def with-meta
  (fn* with-meta [o meta]
       (.with-meta o meta)))

(def ^:macro let
  (fn* let [&form & decl]
       (cons 'let* decl)))

(def ^:macro fn
  (fn* fn [&form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def identity
  (fn identity [v] v))

(def
  ^{:doc "Return true if obj is an instance of class."}
  instance?
  (fn instance? [class obj]
    (builtins/isinstance obj class)))

(def
  ^{:doc "Return true if obj is a boolean."}
  boolean?
  (fn boolean? [o]
    (instance? builtins/bool o)))

(def
  ^{:doc "Return true if obj is a float."}
  float?
  (fn float? [o]
    (instance? builtins/float o)))

(def
  ^{:doc "Return true if obj is an integer."}
  integer?
  (fn integer? [o]
    (instance? builtins/int o)))

(def
  ^{:doc "Return true if obj is a string."}
  string?
  (fn string? [o]
    (instance? builtins/str o)))

(def
  ^{:doc "Return true if obj is a symbol."}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc "Return true if obj is a keyword."}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc "Return true if o is a list."}
  list?
  (fn list? [o]
    (instance? basilisp.lang.list/List o)))

(def
  ^{:doc "Return true if o is a map."}
  map?
  (fn map? [o]
    (instance? basilisp.lang.map/Map o)))

(def
  ^{:doc "Return true if o is a set."}
  set?
  (fn set? [o]
    (instance? basilisp.lang.set/Set o)))

(def
  ^{:doc "Return true if o is a vector."}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.vector/Vector o)))

(def seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def
  ^{:doc "Create a hash map from pairs of input arguments."}
  hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def
  ^{:doc "Create a set from the input arguments."}
  hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def
  ^{:doc "Return a set with the contents of coll."}
  set
  (fn set
    [coll]
    (^:allow-builtins basilisp.lang.set/set coll)))

(def
  ^{:doc "Create a vector from the input arguments."}
  vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def
  ^{:doc "Return a vector with the contents of coll."}
  vec
  (fn vec
    [coll]
    (basilisp.lang.vector/vector coll)))

;;;;;;;;;;;; full support for syntax quote begins here ;;;;;;;;;;;;

(def print
  (fn print [& args]
    (apply builtins/print args)))

(def count
  (fn count [coll]
    (try
      (builtins/len coll)
      (catch TypeError _
        (count (apply vector coll))))))

(def
  ^{:doc "Returns a basilisp.lang.exception/ExceptionInfo instance with
          the given message and data."}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:doc "Associate keys to values in associative data structure m. If m is nil,
          returns a new map with key-values kvs."}
  assoc
  (fn assoc [m & kvs]
    (apply basilisp.lang.runtime/assoc m kvs)))

(def
  ^{:doc "Conjoin xs to collection. New elements may be added in different positions
          depending on the type of coll. conj returns the same type as coll. If coll
          is nil, return a list with xs conjoined."}
  conj
  (fn conj [coll & xs]
    (apply basilisp.lang.runtime/conj coll xs)))

(def
  ^{:macro true
    :doc   "Define a new function with an optional docstring."}
  defn
  (fn defn [&form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (builtins/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          fname  (if doc
                   (with-meta name {:doc doc})
                   name)
          body   (if doc
                   (rest body)
                   body)
          multi? (list? (first body))
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))]
      `(def ~fname
         (fn* ~fname
              ~@body)))))

(defn nth
  "Returns the ith element of coll (0-indexed), if it exists.
  nil otherwise."
  [coll i]
  (basilisp.lang.runtime/nth coll i))

(defn nthnext
  "Returns the nth next sequence of coll.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn nthrest
  "Returns the nth rest sequence of coll, or coll if i is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn last
  "Return the last item in a seq, or nil if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(def
  ^{:macro true
    :doc   "Define a new macro like defn. Macro functions are available to the
            compiler during macroexpansion."}
  defmacro
  (fn defmacro [&form name & body]
    (let [body  (concat body)
          doc   (if (string? (first body))
                  (first body)
                  nil)
          fname (with-meta (if doc
                             (with-meta name {:doc doc})
                             name)
                  {:macro true})
          body  (if doc
                  (rest body)
                  body)

          add-implicit-args (fn [body]
                              (cons
                               (if (vector? (first body))
                                 (apply vector (cons '&form (first body)))
                                 (throw
                                  (ex-info "Expected an argument vector"
                                           {:found (first body)})))
                               (rest body)))

          add-args-for-each (fn [in out]
                              (if (seq (rest in))
                                (recur (rest in)
                                       (conj out (add-implicit-args (first in))))
                                (conj out (add-implicit-args (first in)))))

          multi? (list? (first body))
          body   (if multi?
                   (add-args-for-each body [])
                   (add-implicit-args body))]
      `(defn ~fname
         ~@body))))

(defmacro if-not
  "Evaluate cond and if it is true, return false-cond. Otherwise return
  true-cond."
  [cond true-cond false-cond]
  `(if ~cond
     ~false-cond
     ~true-cond))

(defmacro when
  "Evaluate cond and if it is true, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     (do ~@body)
     nil))

(defmacro when-not
  "Evaluate cond and if it is false, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     nil
     (do ~@body)))

(defmacro and
  "Evaluate the expressions from left to right. If all expressions are true,
  return the result of the final expression. Otherwise, returns the first
  false expression. Calling and with no arguments returns true."
  ([] true)
  ([& args]
   (if (seq (rest args))
     `(if ~(first args)
        (and ~@(rest args))
        ~(first args))
     (first args))))

(defmacro or
  "Evaluate the expressions from left to right. Returns the first true
  expression. Otherwise, returns the final falsy expression. Calling or
  with no arguments returns nil."
  ([] nil)
  ([& args]
   (if (seq (rest args))
     `(if ~(first args)
        ~(first args)
        (or ~@(rest args)))
     (first args))))

(defn not
  "Return the logical negation of expr."
  [expr]
  (if expr false true))

(defn false?
  "Return true if x is false, otherwise false."
  [x]
  (operator/is- x false))

(defn true?
  "Return true if x is true, otherwise false."
  [x]
  (operator/is- x true))

(defn nil?
  "Return true if x is nil, otherwise false."
  [x]
  (operator/is- x nil))

(defn some?
  "Return true if x is not nil, otherwise false."
  [x]
  (not (nil? x)))

(defn any?
  "Return true for any x."
  [x]
  true)

(defn =
  "Return true if x and y are equal, otherwise false."
  ([x] true)
  ([x & args]
   (if (seq (rest args))
     (if (basilisp.lang.runtime/equals x (first args))
       (recur (first args) (rest args))
       false)
     (basilisp.lang.runtime/equals x (first args)))))

(defn not=
  "Return true if x and y are not equal, otherwise false."
  [& args]
  (not (apply = args)))

(defn >
  "Return true if arguments are monotonically decreasing, otherwise false."
  ([x] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/gt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/gt x (first args)))))

(defn >=
  "Return true if arguments are decreasing, otherwise false."
  ([x] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/ge x (first args))
       (recur (first args) (rest args))
       false)
     (operator/ge x (first args)))))

(defn <
  "Return true if arguments are monotonically increasing, otherwise false."
  ([x] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/lt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/lt x (first args)))))

(defn <=
  "Return true if arguments are increasing, otherwise false."
  ([x] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/le x (first args))
       (recur (first args) (rest args))
       false)
     (operator/le x (first args)))))

(defn str
  "Create a string representation of o."
  ([] "")
  ([o] (builtins/str o))
  ([o & args]
   (let [coerce (fn [in out]
                  (if (seq (rest in))
                    (recur (rest in)
                           (conj out (builtins/str (first in))))
                    (conj out (builtins/str (first in)))))
         strs   (coerce (conj args o) [])]
     (.join "" strs))))

(defmacro cond
  "Given groups of test/expression pairs, evaluate each test and, if
  true, return the expression. Otherwise, continue through until reaching
  the final expression."
  [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw
             (ex-info "cond requires an even number of forms"
                      {:first (first clauses)})))
          (cons 'basilisp.core/cond (nthrest clauses 2)))))

(defn symbol
  "Create a new symbol with name and optional namespace ns."
  ([name]
   (basilisp.lang.symbol/symbol name))
  ([ns name]
   (basilisp.lang.symbol/symbol name ns)))

(defn keyword
  "Create a new keyword with name and optional namespace ns. Keywords
  will have the colon prefix added automatically, so it should not be
  provided."
  ([name]
   (basilisp.lang.keyword/keyword name))
  ([ns name]
   (basilisp.lang.keyword/keyword name ns)))

(defn name
  "Return the name of a string, symbol, or keyword."
  [v]
  (if (string? v)
    v
    (.-name v)))

(defn namespace
  "Return the namespace of a symbol or keyword, or nil if no namespace."
  [v]
  (.-ns v))

(defn deref
  "Dereference a delay or atom and returns its contents."
  [o]
  (basilisp.lang.runtime/deref o))

(defn compare-and-set!
  "Atomically set the value of atom to new-val if and only if old-val
  is the current value of the atom."
  [atom old-val new-val]
  (.compare-and-set atom old-val new-val))

(defn reset!
  "Reset the value of an atom to v without regard to the previous value.
  Return the new value."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      v
      (recur atom v))))

(defn swap!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return the new value."
  [atom f & args]
  (apply basilisp.lang.runtime/swap atom f args))

(defn atom
  "Return an Atom containing v. The value of an Atom at any point in time
  may be returned by deref'ing it. The value of an atom may be reset using
  reset! and may be swapped using swap!. All operations on an atom occur
  atomically."
  [v]
  (basilisp.lang.atom/Atom v))

(defn realized?
  "Return true if the delay or lazy sequence has been realized."
  [o]
  (.-is-realized o))

(defmacro delay
  "Takes a body of expressions producing any value. Will not produce a
  value until deref'ed. The result is cached and returned in future
  derefs."
  [& body]
  (list 'basilisp.lang.delay/Delay
        (concat '(fn* []) body)))

(defmacro lazy-seq
  "Takes a body of expressions which will produce a seq or nil. When
  seq is first called on the resulting lazy-seq, the sequence will be
  realized."
  [& body]
  (list 'basilisp.lang.seq/LazySeq
        (concat '(fn* []) body)))

(defn pos?
  "Return true if x is positive."
  [x]
  (if (operator/gt x 0) true false))

(defn non-neg?
  "Return true if x is not negative."
  [x]
  (if (operator/ge x 0) true false))

(defn zero?
  "Return true if x is 0."
  [x]
  (= 0 x))

(defn neg?
  "Return true if x is negative."
  [x]
  (if (operator/lt x 0) true false))

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/add x (first args)) (rest args))
     (operator/add x (first args)))))

(defn -
  "Subtract the arguments. If one argument given, returns the negation
  of that argument."
  ([x] (operator/neg x))
  ([x & args]
   (if (seq (rest args))
     (recur (operator/sub x (first args)) (rest args))
     (operator/sub x (first args)))))

(defn *
  "Multiply the arguments. If no arguments given, returns 1."
  ([] 1)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/mul x (first args)) (rest args))
     (operator/mul x (first args)))))

(defn /
  "Divide the arguments. If no arguments given, returns the inverse of
  the argument."
  ([x] (basilisp.lang.runtime/divide 1 x))
  ([x & args]
   (if (seq (rest args))
     (recur (basilisp.lang.runtime/divide x (first args)) (rest args))
     (basilisp.lang.runtime/divide x (first args)))))

(defn mod
  "Returns the modulo of num and div."
  [num div]
  (operator/mod num div))

(defn quot
  "Returns the quotient of num and div."
  [num div]
  (basilisp.lang.runtime/quotient num div))

(defn rem
  "Returns the remainder of num and div."
  [num div]
  (- num (* div (quot num div))))

(defn inc
  "Increment the argument by 1."
  [x]
  (+ x 1))

(defn dec
  "Decrement the argument by 1."
  [x]
  (- x 1))

(defn even?
  "Return true if x is even."
  [x]
  (if (= 0 (mod x 2)) true false))

(defn odd?
  "Return true if x is odd."
  [x]
  (if (= 1 (mod x 2)) true false))

(defn min
  "Return the minimum of the arguments."
  [& args]
  (builtins/min args))

(defn max
  "Return the maximum of the arguments."
  [& args]
  (builtins/max args))

(defn sort
  "Return a sorted sequence of the elements from coll."
  ([coll]
   (basilisp.lang.runtime/sort coll))
  ([cmp coll]
   (basilisp.lang.runtime/sort coll cmp)))

(defn contains?
  "Return true if coll contains k. For vectors, k is an index. For maps, k is
  a key. For sets, k is a value in the set."
  [coll k]
  (basilisp.lang.runtime/contains coll k))

(defn disj
  "Return a new version of the set s without the given elements. If the elements
  don't exist in s, they are ignored."
  ([s] s)
  ([s & elems]
   (apply (.-disj s) elems)))

(defn dissoc
  "Return a new version of m without the given keys. If the keys
  don't exist in m, they are ignored."
  [m & ks]
  (apply (.-dissoc m) ks))

(defn get
  "Return the entry of m corresponding to k if it exists or nil/default otherwise."
  ([m k]
   (basilisp.lang.runtime/get m k))
  ([m k default]
   (basilisp.lang.runtime/get m k default)))

(defn key
  "Return the key from a map entry."
  [entry]
  (.-key entry))

(defn val
  "Return the val from a map entry."
  [entry]
  (.-value entry))

(defmacro new
  "Create a new instance of class with args.

  New objects may be created as any of:
    (new builtins/str *args)
    (new builtins.str *args)
    (new builtins.str. *args)

  This is compatibility syntax for Clojure, since Python (and therefore
  Basilisp) do not require the new keyword for object instantiation."
  [class & args]
  (cond
    (not (symbol? class))
    (throw
     (ex-info "Expected a class name as a symbol"
              {:class-name class}))

    (namespace class)
    (let [n  (name class)
          ns (namespace class)
          s  (symbol (str ns "."
                          (if (.endswith n ".")
                            n
                            (str n "."))))]
      `(~s ~@args))

    :else
    (let [n (name class)
          s (symbol (if (.endswith n ".")
                      n
                      (str n ".")))]
      `(~s ~@args))))

(defn range
  "Return a range of integers from start. If end is specified, the
  sequence will terminate at end."
  ([] (range 0))
  ([start]
   (lazy-seq (cons start (range (inc start)))))
  ([start end]
   (lazy-seq (cons start (when (< start end)
                           (range (inc start) end)))))
  ([start end step]
   (lazy-seq (let [next-int (+ start step)]
               (cons start (when (< next-int end)
                             (range next-int end step)))))))

(defn complement
  "Return a function which returns the logical complement of the return
  value of (apply f args)."
  [f]
  (fn [& args]
    (not (apply f args))))

(defn constantly
  "Returns a function that accepts any number of arguments and returns x."
  [x]
  (fn [& args] x))

(defn reduce
  "Reduce coll by f.

  If val is not supplied and coll has no elements, f will be called
  with no arguments and the result will be returned.

  If val is not supplied and coll has one element, the result of
  (f (first val)) is returned.

  If val is not supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll.

  If val is supplied and coll has no elements, the result of (f val)
  is returned.

  If val is supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll, starting with val."
  ([f coll]
   (if (seq coll)
     (if (seq (rest coll))
       (reduce f (first coll) (rest coll))
       (first coll))
     (f)))
  ([f val coll]
   (let [reduce-coll (fn [out in]
                       (if (seq in)
                         (recur (f out (first in)) (rest in))
                         out))]
     (if (seq coll)
       (reduce-coll val coll)
       (f val)))))

(defn comp
  "Return a function which is the composition of all the functions
  given as arguments. Note that, as in mathematical function composition,
  the argument functions are called from right to left."
  ([] identity)
  ([f] f)
  ([f & args]
   (let [composed (reduce (fn [f g]
                            (fn [& args]
                              (f (apply g args))))
                          f
                          args)]
     (fn [& inner-args]
       (apply composed inner-args)))))

(defn juxt
  "Return a function which takes any number of arguments and applies each of
  the argument functions to this function in order, returning a vector of the
  return values from each function."
  [& args]
  (fn [& inner-args]
    (reduce (fn [v f]
              (conj v (apply f inner-args)))
            []
            args)))

(defn partial
  "Return a function which is the partial application of f with args."
  [f & args]
  (apply basilisp.lang.runtime/partial f args))

(defn every?
  "Return true if every element in coll satisfies pred."
  [pred coll]
  (cond
    (nil? (seq coll))   true
    (pred (first coll)) (recur pred (rest coll))
    :else               false))

(def
  ^{:doc "Return true if not every element in coll satisfies pred."}
  not-every?
  (comp not every?))

(defn some
  "Return true if at least one element in coll satisfies pred."
  [pred coll]
  (when (seq coll)
    (or (pred (first coll))
        (recur pred (rest coll)))))

(def
  ^{:doc "Return true if no element in coll satisfies pred."}
  not-any?
  (comp not some))

(defn map
  "Return a lazy sequence of (f elem) for elements in coll."
  [f coll]
  (lazy-seq
   (cons (f (first coll)) (when (seq (rest coll))
                            (map f (rest coll))))))

(defn filter
  "Return elements from coll where (pred elem) returns true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (cons (first coll) (filter pred (rest coll)))
       (filter pred (rest coll))))))

(defn remove
  "Return elements from coll where (pred elem) returns false."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (not (pred (first coll)))
       (cons (first coll) (remove pred (rest coll)))
       (remove pred (rest coll))))))

(defn take
  "Return the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (when (> n 0)
       (cons (first coll) (take (dec n) (rest coll)))))))

(defn take-while
  "Return elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (when (pred (first coll))
       (cons (first coll) (take-while pred (rest coll)))))))

(defn drop
  "Drop the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (> n 0)
       (drop (dec n) (rest coll))
       (seq coll)))))

(defn drop-while
  "Drop elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (drop-while pred (rest coll))
       (seq coll)))))

(defn split-at
  "Split a collection at the nth item. Returns a vector of
  [(take n coll) (drop n coll)]."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Split a collection at the inflection point of pred. Returns a
  vector of [(take-while pred coll) (drop-while pred coll)]."
  [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

(defn cycle
  "Cycle the items in coll infinitely."
  [coll]
  (let [coll-cycle (fn coll-cycle
                     [curr]
                     (lazy-seq
                      (if (seq curr)
                        (cons (first curr) (coll-cycle (rest curr)))
                        (coll-cycle coll))))]
    (coll-cycle coll)))

(defn repeat
  "Repeat x infinitely or n many times if n is specified. Returns a lazy
  sequence of the x."
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (lazy-seq (cons x (repeat (dec n) x)))))

(defn repeatedly
  "Call f infinitely or n many times if n is specified. Returns a lazy
  sequence of the return values."
  ([f]
   (lazy-seq (cons (f) (repeatedly f))))
  ([n f]
   (lazy-seq (cons (f) (repeatedly (dec n) f)))))

(defn merge
  "Merge maps together from left to right as by conj. If a duplicate key
  appears in a map, the rightmost map's value for that key will be taken."
  [& maps]
  (when (some identity maps)
    (reduce #(conj %1 %2)
            {}
            maps)))

(defmacro binding
  "Establish thread-local bindings for the vars given. The bindings are guaranteed
  to clear once execution passes outside the scope of this block."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [vvar (first bindings)
        val  (second bindings)]
    `(try
       (do
         (.push-bindings (var ~vvar) ~val)
         ~@(if (nthnext bindings 2)
             [(concat
               (list 'binding (vec (nthrest bindings 2)))
               body)]
             body))
       (finally
         (.pop-bindings (var ~vvar))))))

(def ^:dynamic *in* sys/stdin)
(def ^:dynamic *out* sys/stdout)
(def ^:dynamic *err* sys/stderr)

;;;;;;;;;;;;;;;;;;;;
;; REPL Utilities ;;
;;;;;;;;;;;;;;;;;;;;

(def
  ^{:doc "The default data readers used in reader macros. Overriding or
          attempting to change the root binding of this var will not
          change the default data readers."}
  default-data-readers
  (.--DATA-READERS basilisp.reader/ReaderContext))

(def
  ^{:doc     "Data readers map which will be merged in to the default data
              reader map used by the reader. Mappings should be qualified
              symbols to functions taking one argument. The function will
              receive an unevaluated data structure and must return some
              value to the reader."
    :dynamic true}
  *data-readers*
  {})

(def
  ^{:doc     "Resolver used for resolving namespace aliases when reading
              forms using read, read-string, etc."
    :dynamic true}
  *resolver*
  basilisp.lang.runtime/resolve-alias)

(defn read-string
  "Read a string of Basilisp code.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  Note that read-string should not be used to read string input from
  untrusted sources."
  ([s]
   (read-string {:eof :eofthrow} s))
  ([opts s]
   (first (basilisp.reader/read-str s
                                    *resolver*
                                    *data-readers*
                                    (:eof opts)
                                    (if (= (:eof opts) :eofthrow)
                                      true
                                      false)))))

(defn read
  "Read the next form from the stream. If no stream is specified, uses
  the value currently bound to *in*.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  The stream must satisfy the interface of io.TextIOBase, but does not require
  any pushback capabilities. The default basilisp.reader.StreamReader can wrap
  any object implementing TextIOBase and provide pushback capabilities."
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([opts stream]
   (first (basilisp.reader/read stream
                                *resolver*
                                *data-readers*
                                (:eof opts)
                                (if (= (:eof opts) :eofthrow)
                                  true
                                  false))))
  ([stream eof-error? eof-value]
   (first (basilisp.reader/read stream
                                *resolver*
                                *data-readers*
                                eof-value
                                eof-error?))))

(defn eval
  "Evaluate a form (not a string) and return its result."
  [form]
  (let [ctx    (basilisp.compiler.CompilerContext.)
        module (.-module *ns*)]
    (basilisp.compiler/compile-and-exec-form form
                                             ctx
                                             module
                                             "<Eval Input>")))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:private get-namespace
  "Get the Namespace named by ns-sym."
  [ns-sym]
  (.get-or-create basilisp.lang.runtime/Namespace ns-sym))

(defn ns-aliases
  "Return a map of Basilisp namespaces which are aliased in the current
  namespace."
  [ns]
  (reduce (fn [m entry]
            (let [alias     (key entry)
                  namespace (symbol (name (val entry)))]
              (if (= alias namespace)
                m
                (assoc m alias namespace))))
          {}
          (.-aliases ns)))

(defn ns-imports
  "Return a set of Python modules which are imported in the current
  namespace."
  [ns]
  (.-imports ns))

(defn ns-interns
  "Return a map of symbols to Vars which are interned in the current
  namespace."
  [ns]
  (.-interns ns))

(defn ns-publics
  "Return a map of symbols to public Vars which are interned in the
  current namespace.

  Public vars are Vars which are declared without :private metadata."
  [ns]
  (let [interns (ns-interns ns)]
    (if-not (seq interns)
      {}
      (reduce (fn [m entry]
                (if (:private (meta (val entry)))
                  m
                  (assoc m (key entry) (val entry))))
              {}
              interns))))

(defn ns-refers
  "Return a map of symbols to Vars which are referred in the current
  namespace."
  [ns]
  (.-refers ns))

(defn ns-map
  "Return a map of all the mapped symbols in the namespace.

  Includes the return values of ns-interns and ns-refers in one map."
  [ns]
  (let [current-ns *ns*]
    (merge
     (ns-interns current-ns)
     (ns-refers current-ns))))

(defn ns-resolve
  "Return the Var which will be resolved by the symbol in the given namespace."
  [ns sym]
  (.find ns sym))

(defn resolve
  "Return the Var which will be resolved by the symbol in the namespace currently
  bound to *ns*."
  [sym]
  (ns-resolve *ns* sym))

(defmacro import
  "Import a Python module by name."
  [module]
  `(import* ~module))

(defn refer
  "Refer Vars from the namespace named by ns-sym, subject to the filters specified.

  Supported filters:
  - :only [sym1 sym2], to only refer the specified symbols
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name"
  [ns-sym & filters]
  (let [current-ns *ns*
        ns         (get-namespace ns-sym)
        filter-map (apply hash-map filters)]
    (if-not (seq filters)
      (.refer-all current-ns ns)
      (let [only    (set (:only filter-map))
            exclude (set (:exclude filter-map))
            rename  (or (:rename filter-map) {})

            interns (if (seq only)
                      (filter (fn [entry]
                                (contains? only (key entry)))
                              (ns-interns ns))
                      (ns-interns ns))
            interns (if (seq exclude)
                      (remove (fn [entry]
                                (contains? exclude (key entry)))
                              interns)
                      interns)
            interns (if (seq rename)
                      (reduce (fn [m entry]
                                (if (rename (key entry))
                                  (assoc m (rename (key entry)) (val entry))
                                  m))
                              {}
                              interns)
                      interns)

            do-refer (fn [refers]
                       (when (seq refers)
                         (let [entry (first (seq refers))
                               sym   (key entry)
                               var   (val entry)]
                           (.add-refer current-ns sym var)
                           (recur (rest refers)))))]
        (do-refer interns)))))

(import importlib)

(defn ^:private add-refers
  "Refer all of the Vars named in syms from from-ns to to-ns."
  [to-ns from-ns syms]
  (when (seq syms)
    (let [var-sym (first syms)
          var     (get (ns-interns from-ns) var-sym)]
      (.add-refer to-ns var-sym var)
      (recur to-ns from-ns (rest syms)))))

(defn ^:private require-vec
  "Process a vector libspec for require."
  [current-ns v]
  (let [ns-sym (first v)
        opts   (apply hash-map (rest v))]
    (importlib/import-module (name ns-sym))
    (let [new-ns (get-namespace ns-sym)]
      ;; Add the namespace alias
      (.add-alias current-ns (or (:as opts) ns-sym) new-ns)

      ;; Add refers
      (cond
        (= :all (:refer opts))
        (.refer-all which-ns new-ns)

        (:refer opts)
        (add-refers current-ns new-ns (:refer opts))

        :else nil))))

(defn ^:private require-sym
  "Process a symbol libspec for require."
  [s]
  (importlib/import-module (name s)))

(defn require
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:
  - symbols, which name fully qualified namespaces
  - vectors, which take the form [namespace-symbol & opts]

  Vector libspec arguments must be one of:
  - :as name, which will alias the imported namespace to the symbol name
  - :refer [& syms], which will refer syms in the local namespace directly"
  [& args]
  (let [current-ns *ns*

        do-require (fn [requires]
                     (when (seq requires)
                       (let [v (first requires)]
                         (cond
                           (vector? v) (require-vec current-ns v)
                           (symbol? v) (require-sym v)
                           :else             (throw
                                              (ex-info "Invalid libspec for require"
                                                       {:value v}))))
                       (recur (rest requires))))]
    (do-require args)
    (set! '*ns* current-ns)
    nil))

(defmacro ns
  "Use this namespace pre-amble at the top of every namespace to declare
  the namespace name and import necessary Python modules and require
  Basilisp namespaces.

  You may include an optional docstring for the namespace to describe its
  purpose.

  Example:
    (ns my.namespace
       \"My namespace with code\"
       (:require
         [basilisp.string :as str])
       (:import inspect))"
  [name & opts]
  (when-not (and (symbol? name) (nil? (namespace name)))
    (throw (ex-info "Namespace name must be a non-namespaced symbol"
                    {:name name})))
  (let [doc  (when (string? (first opts))
               (first opts))
        opts (if doc (rest opts) opts)
        opts (when (seq opts)
               (reduce (fn [m opt]
                         (let [opt-name (first opt)
                               options  (rest opt)]
                           (when-not (keyword? opt-name)
                             (throw (ex-info "Namespace option must be a keyword"
                                             {:option opt-name})))
                           (assoc m opt-name (vec options))))
                       {}
                       opts))

        requires (when (:require opts)
                   `(require ~@(map #(list 'quote %) (:require opts))))
        imports  (when (:import opts)
                   (map (fn [v]
                          `(import ~v))
                        (:import opts)))]
    `(do
       (in-ns (quote ~name))
       ~requires
       ~@imports)))

;;;;;;;;;;;;;;;;;;;;;
;; Regex Functions ;;
;;;;;;;;;;;;;;;;;;;;;

(import re)

(defn re-pattern
  "Return a new re.Pattern instance."
  [s]
  (re/compile s))

(defn re-find
  "Returns the first match of a string to a pattern using re.search.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/search pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn re-matches
  "Returns a match of a string to a pattern using re.fullmatch.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/fullmatch pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn ^:private lazy-re-seq
  "Return a lazy sequence of the matches in a match iterator."
  [iter]
  (lazy-seq
   (when (first iter)
     (let [match (.group (first iter) 0)]
       (cons match (when (seq (rest iter))
                     (lazy-re-seq (rest iter))))))))

(defn re-seq
  "Returns a lazy sequence of matches of a string to a pattern using re.finditer.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (lazy-re-seq (seq (re/finditer pattern s))))

