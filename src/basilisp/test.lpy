(ns basilisp.test)

(def ^:private collected-tests
  (atom []))

(def ^:private current-ns
  (atom nil))

(defn ^:private add-test!
  "Add the test named by test-var to the test suite for ns."
  [test-var]
  (swap! collected-tests conj test-var))

(def ^:dynamic *test-name* nil)
(def ^:dynamic *test-section* nil)
(def ^:dynamic *test-failures* nil)

(defmacro is
  "Assert that expr is true. Must appear inside of a deftest form."
  ([expr]
   `(is ~expr (str "Test failure: " ~expr)))
  ([expr msg]
   (let [line-no (:basilisp.reader/line (meta &form))

         eq-sym `=

         deconstruct? (and (list? expr) (= eq-sym (first expr)))

         expected (if deconstruct?
                    (second expr)
                    expr)
         actual   (if deconstruct?
                    (nth expr 2)
                    expr)]
     `(let [computed# ~expr
            actual#   ~actual
            expected# ~expected]
        (when-not computed#
          ;; Collect test failures in the atom bound to
          ;; `*test-failures*` by `deftest`.
          (swap! *test-failures*
                 conj
                 [~msg
                  {:test-name    *test-name*
                   :test-section *test-section*
                   :expr         (quote ~expr)
                   :line         ~line-no
                   :actual       actual#
                   :expected     expected#}]))))))

(defmacro testing
  "Wrapper for test cases to provide additional messaging and context
  around the test or group of tests contained inside. Must appear inside
  of a deftest form."
  [msg & body]
  `(binding [*test-section* (if *test-section*
                              (str *test-section* " :: " ~msg)
                              ~msg)]
     ~@body))

(defmacro deftest
  "Define a new test function. Assertions can be made with the is macro.
  Group tests with the testing macro.

  Tests defined by deftest will be run by default by the PyTest test
  runner using Basilisp's builtin PyTest hook."
  [name-sym & body]
  (let [test-name-sym (with-meta name-sym {:test true})
        test-name-str (name test-name-sym)
        test-ns-name  `(quote ~(symbol (name *ns*)))]
    `(do
       (defn ~test-name-sym
         []
         (binding [*ns*            (the-ns ~test-ns-name)
                   *test-name*     ~test-name-str
                   *test-section*  nil
                   *test-failures* (atom [])]
           ~@body
           {:failures (deref *test-failures*)}))

       (add-test! (var ~test-name-sym))
       (reset! current-ns (the-ns ~test-ns-name)))))
