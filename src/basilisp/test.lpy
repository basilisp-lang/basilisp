(ns basilisp.test
  "Basilisp automated testing framework.

  The functions and macros in this namespace are useful in defining automated tests
  for your Basilisp code. Basilisp's builtin test runner is a plugin for PyTest and
  benefits from many PyTest features such as test collection and subsetting.

  Test namespaces should generally be placed in a ``tests`` directory in the root of
  your project. Tests may be organized into single namespaces or nested namespaces.
  All test namespace files should be named ``test_*.lpy`` or ``*_test.lpy`` to be
  eligible for collection by the test runner.

  Tests within each test namespace should be wrapped in an outer :lpy:fn:`deftest`
  form and may optionally be organized within each form with :lpy:fn:`testing` forms.
  :lpy:fn:`is` and :lpy:fn:`are` may be used for making test assertions. All assertions
  will be processed in order to the end and all failures and errors will be reported
  at once.

  Tests may take advantage of Basilisp fixtures via :lpy:fn:`use-fixtures` to perform
  setup and teardown functions for each test or namespace. Fixtures are not the same
  (nor are they compatible with) PyTest fixtures."
  (:import types)
  (:require
   [basilisp.template :as template]
   [basilisp.stacktrace :refer [print-stack-trace]]))

(def ^:dynamic *test-ns*         nil)
(def ^:dynamic *test-var*        nil)
(def ^:dynamic *test-name*       nil)
(def ^:dynamic *test-section*    nil)
(def ^:dynamic *test-assertions* nil)

(def ^{:deprecated true
       :dynamic    true}
  *test-failures*
  "Deprecated. Use :lpy:var:`*test-assertions*` instead."
  nil)

(defprotocol Report

  (continue? [self]
    "Return true if more tests should be processed, else false. Will
  be called after each test to determine if the test runner should
  continue.")

  (report-begin [self]
    "Record the start of this report. Return the modified report.")
  (report-end [self]
    "Record the end of this report. Return the modified report.")

  (report-namespace-begin [self ns]
    "Record the current namespace being tested. Return the modified report.")
  (report-namespace-end [self ns assertions]
    "Record the end of testing the namespace. Return the modified report.")

  (report-test-begin [self test-var]
    "Record the start of a test. Return the modified report.")
  (report-test-end [self test-var assertions]
    "Record the result of a test. Return the modified report."))

(defn failures
  "Get all assertions that represent either a failure or an
  error. return ``nil`` if there are none."
  [assertions]
  (seq (filter (comp #{:failure :error} :type) assertions)))

(defn- print-failures
  [ns test-var assertions]
  (when-let [fails (failures assertions)]
    (let [file (-> test-var meta (:file (name ns)))]
      (doseq [fail fails]
        (let [{:keys [type expected actual
                      message test-section line]} fail
              error?                              (= :error type)]
          (println (format "%s in (%s) (%s)"
                           (if error? "ERROR" "FAIL")
                           (if test-var (name test-var) "unknown")
                           (cond-> file
                             line (str ":" line))))
          (when test-section (println test-section))
          (when message (println message))
          (if error?
            (when (instance? BaseException actual)
              (print-stack-trace actual)
              (println))
            (println "expected:" expected "\n  actual:" actual \newline)))))))

(defrecord SimpleReport [pass failure error tests]
  Report

  (continue? [self] true)

  (report-begin [self] self)
  (report-end [self]
    (println
     (format "\nRan %d tests containing %d assertions.\n%d failures, %d errors."
             tests
             (+ pass failure)
             failure
             error))
    self)

  (report-namespace-begin [self ns]
    (println "\nTesting " ns "\n")
    self)
  (report-namespace-end [self ns assertions]
    (print-failures ns nil assertions)
    (map->SimpleReport (->> assertions
                            (map :type)
                            frequencies
                            (merge-with + (into {} self)))))

  (report-test-begin [self _] self)
  (report-test-end [self test-var assertions]
    (print-failures (namespace test-var) test-var assertions)
    (map->SimpleReport (->> assertions
                            (map :type)
                            frequencies
                            (merge-with + (into {} self) {:tests 1})))))

(defmulti ^{:arglists '([fixture-type & fixtures])}
  use-fixtures
  "Configure fixture functions to be run for each test or once per namespace.

  ``fixture-type`` may be one of:

  - ``:each`` to specify that a fixture should be run before each test
  - ``:once`` to specify that a fixture should be run once per test namespace

  Fixture functions are functions of 0 arguments which must either return a value
  or temporarily ``yield`` control back to the test runner after performing some setup.
  If the ``yield`` approach is taken, the test runner will return control to the
  fixture whenever the test or tests have finished executing.

  For example, to define a fixture with setup and teardown functions, your fixture
  may take this form::

    (fn fixture []
      (setup-test)
      (yield)
      (teardown-test))

  Fixtures will be run in the order they are provided.

  Subsequent calls to ``use-fixtures`` in the same test namespace will overwrite
  fixtures applied during previous calls for the same ``fixture-type``.

  Note that due to the way fixtures are applied, the set of fixtures that are active
  for each ``fixture-type`` after all tests are collected will be applied to all tests.
  It is not possible to apply specific fixtures to individual tests by adding fixtures
  via ``use-fixture`` and then removing them after the test is defined."
  (fn [fixture-type & _] fixture-type))

(defmethod use-fixtures :each
  [_ & fixtures]
  (alter-meta! *ns* assoc ::each-fixtures fixtures))

(defmethod use-fixtures :once
  [_ & fixtures]
  (alter-meta! *ns* assoc ::once-fixtures fixtures))

(defn generator?
  "Return true if ``x`` is a generator type, else false."
  [x]
  (instance? types/GeneratorType x))

(defmacro with-fixtures
  "Wrap the ``body`` in the ``fixtures`` in the given order. Handle
  setup and teardown for each of the ``fixtures``."
  [fixtures & body]
  (assert (vector? fixtures) "Expected a literal vector of fixtures")
  (let [result (gensym "result")]
    (reduce (fn [form fixture]
              `(let [~result (~fixture)]
                 (if (generator? ~result)
                   (try
                     (python/next ~result)
                     ~form
                     (finally
                       (try
                         (python/next ~result)
                         (catch python/StopIteration ~'_ nil))))
                   ~form)))
            `(do ~@body)
            (reverse fixtures))))

(defmacro compose-fixtures
  "Compose any number of ``fixtures``, in order, creating a new fixture
  that combines their behavior. Always returns a valid fixture
  function, even if no fixtures are given."
  [& fixtures]
  `(fn [] (with-fixtures [~@fixtures] (yield))))

(defn join-fixtures
  "Composes a collection of ``fixtures``, in order.  Always returns a valid
  fixture function, even if the collection is empty.

  Prefer :lpy:macro`compose-fixtures` if fixtures are known at compile time."
  [fixtures]
  (if (seq fixtures)
    (reduce #(compose-fixtures %1 %2) fixtures)
    (constantly nil)))

(defn assert!
  "Emit an assertion.

  Use as a return value for :lpy:fn`gen-assert` methods."
  [type expr msg line-num additional-data]
  (vswap! *test-assertions* conj
          (assoc additional-data
                 :ns           *test-ns*
                 :var          *test-var*
                 :test-name    *test-name*
                 :test-section *test-section*
                 :expr         expr
                 :message      msg
                 :line         line-num
                 :type         type)))

(defn pass!
  "Emit an assertion that indicates a test criteria has pass.

  Use as a return value for :lpy:fn`gen-assert` methods."
  [expr msg line-num & {:as additional-data}]
  (assert! :pass expr msg line-num additional-data))

(defn fail!
  "Emit an assertion that indicates a test failure.

  Use as a return value for :lpy:fn`gen-assert` methods."
  [expr msg line-num expected actual & {:as additional-data}]
  (assert! :failure expr msg line-num
           (assoc additional-data
                  :actual   actual
                  :expected expected)))

(defn error!
  "Emit an assertion that indicates an error ``e`` has occurred.

  Use as a return value for :lpy:fn`gen-assert` methods."
  [expr msg line-num e & {:as additional-data}]
  (assert! :error expr (str msg " " (python/repr e)) line-num
           (assoc additional-data
                  :actual   e
                  :expected (:expected additional-data expr))))

(defmulti
  ^{:arglists '([expr msg line-num])}
  gen-assert
  "Implementation detail of :lpy:fn:`is` for generating macros."
  (fn [expr _ _]
    (cond
      (vector? expr)     :default
      (sequential? expr) (let [maybe-f (first expr)]
                           (if (and (symbol? maybe-f)
                                    (or (= 'basilisp.core/= maybe-f)
                                        (#{'thrown-with-msg? 'thrown?} (symbol (name maybe-f)))))
                             (symbol (name maybe-f))
                             maybe-f))
      :else              :default)))

;; clojure.test does not special case '=, but this means that its expected/actual
;; results just show expected `expr` and `(not expr)`
(defmethod gen-assert '=
  [expr msg line-num]
  `(let [actual#   ~(nth expr 2)
         expected# ~(second expr)]
     (if (= expected# actual#)
       (pass! (quote ~expr) ~msg ~line-num)
       (fail! (quote ~expr) ~msg ~line-num expected# actual#))))

(defmethod gen-assert 'instance?
  [expr msg line-num]
  `(let [value# ~(nth expr 2)
         cls#   ~(second expr)]
     (if (instance? cls# value#)
       (pass! (quote ~expr) ~msg ~line-num)
       (fail! (quote ~expr) ~msg ~line-num cls# (list '~'type value#)))))

(defmethod gen-assert 'thrown?
  [expr msg line-num]
  (let [exc-type (second expr)
        body     (nthnext expr 2)]
    `(try
       (fail! (quote ~expr) ~msg ~line-num (quote ~exc-type) (do ~@body))
       (catch ~exc-type _
         (pass! (quote ~expr) ~msg ~line-num))
       (catch python/Exception e#
         (fail! (quote ~expr)
                (str "Expected " ~exc-type "; got " (python/type e#) " instead")
                ~line-num
                ~exc-type
                e#)))))

(defmethod gen-assert 'thrown-with-msg?
  [expr msg line-num]
  (let [exc-type (second expr)
        pattern  (nth expr 2)
        body     (nthnext expr 3)]
    `(try
       (fail! (quote ~expr) ~msg ~line-num (quote ~exc-type) (do ~@body))
       (catch ~exc-type e#
         ;; Use python/str rather than Basilisp str to get the raw "message"
         ;; from the exception.
         (let [string-exc# (python/str e#)]
           (if (re-find ~pattern string-exc#)
             (pass! (quote ~expr) ~msg ~line-num)
             (fail! (quote ~expr)
                    "Regex pattern did not match"
                    ~line-num
                    ~pattern
                    string-exc#))))
       (catch python/Exception e#
         (fail! (quote ~expr)
                (str "Expected " ~exc-type "; got " (python/type e#) " instead")
                ~line-num
                ~exc-type
                e#)))))

(defmethod gen-assert :default
  [expr msg line-num]
  `(let [computed# ~expr]
     (if computed#
       (pass! (quote ~expr) ~msg ~line-num)
       (fail! (quote ~expr) ~msg ~line-num (list '~'not computed#) computed#))))

(defmacro is
  "Assert that a test condition, ``expr``, is true. :lpy:fn:`is` assertion failures are
  recorded and reported as test failures, causing the entire containing ``deftest`` to
  be marked as failed.

  ``expr`` can take multiple forms:

  - ``(is (= expected actual))`` generates a basic assertion that ``expected`` and
    ``actual`` are equal by ``=``; error messaging will reflect that the first element
    is the expected value and the second element is the actual value
  - ``(is (thrown? ExceptionType expr))`` generates a basic assertion that ``expr``
    does generate an exception of the type ``ExceptionType``
  - ``(is (thrown-with-msg? ExceptionType pattern expr))`` generates a basic assertion
    that ``expr`` does generate an exception of the type ``ExceptionType`` and that
    the stringified exception (as by ``python/str``) matches the regular expression
    ``pattern`` using :lpy:fn:`re-find`
  - ``(is expr)`` is the most basic assertion type that just asserts that ``expr`` is
    truthy

  ``is`` assertions must appear inside of a :lpy:fn:`deftest` form."
  ([expr]
   `(is ~expr (str "Test failure: " (pr-str (quote ~expr)))))
  ([expr msg]
   (let [line-num (or (:basilisp.lang.reader/line (meta &form))
                      (:basilisp.lang.reader/line (meta (first &form))))
         exc-name (gensym "e")]
     `(try
        ~(gen-assert expr msg line-num)
        (catch python/Exception ~exc-name
          (error! (quote ~expr)
                  "Unexpected exception thrown during test run:"
                  ~(if line-num
                     line-num
                     `(.-tb_lineno
                       (.-__traceback__ ~exc-name)))
                  ~exc-name))))))

(defmacro are
  "Generate assertions using the template expression ``expr``. Template expressions
  should be defined in terms of the symbols in the argument vector ``argv``.

  Arguments will be partitioned into groups of as many arguments are in ``argv``
  and applied to the template expression.

  As an example::

    (are [res x y] (= res (+ x y))
      3  1 2
      4  2 2
      0 -1 1)

  This would macroexpand to create a group of assertions like this::

    (do
      (is (= 3 (+ 1 2)))
      (is (= 4 (+ 2 2)))
      (is (= 0 (+ -1 1))))

  This may be convenient for generating large numbers of identically formed assertions
  with different arguments.

  Note that assertions generated with ``are`` typically lose line numbers in test
  failure reports, due to the nature of the macro generation.

  ``are`` assertions must appear inside of a :lpy:fn:`deftest` form."
  [argv expr & args]
  `(template/do-template ~argv (is ~expr) ~@args))

(defmacro testing
  "Wrapper for test cases to provide additional messaging and context around the test
  or group of tests contained inside. The value of ``msg`` will be shown in the report
  with any test failures that occur inside this block.

  ``testing`` macros may be nested. Each nested block message will be appended to the
  message from the previous block.

  ``testing`` forms must appear inside of a :lpy:fn:`deftest` form."
  [msg & body]
  `(binding [*test-section* (if *test-section*
                              (str *test-section* " :: " ~msg)
                              ~msg)]
     ~@body))

(defn execute*
  "Execute the test var ``v`` with the given ``fixture`` if any. Return
  a list of test assertions."
  ([test-var]
   (execute* (constantly nil) test-var))
  ([fixture test-var]
   (binding [*ns*              (namespace test-var)
             *test-ns*         (namespace test-var)
             *test-var*        test-var
             *test-name*       (-> test-var name str)
             *test-section*    nil
             *test-assertions* (volatile! nil)
             *test-failures*   *test-assertions*]
     (let [{testf :test
            line  :line} (meta test-var)]
       (try
         (with-fixtures [fixture]
           (try
             (testf)
             (catch Exception e
               (error! nil "Exception in test:" line e))))
         (catch Exception e
           (error! nil "Exception in test fixture:" line e)))
       (reverse @*test-assertions*)))))

(defmacro deftest
  "Define a new test.

  Assertions can be made with the :lpy:fn:`is` and :lpy:fn:`are` macros. Group tests
  with the :lpy:fn:`testing` macro.

  Tests defined by `deftest` will be run by default by the PyTest test runner using
  Basilisp's builtin PyTest hook."
  [test-name & body]
  `(defn ~(vary-meta test-name assoc
                     ::test true
                     ;; This key is used by some tools (emacs-cider) to
                     ;; identify test vars.
                     :test  `(fn ~test-name [] ~@body))
     []
     {:failures (failures (execute* (var ~test-name)))}))

(defn- report-test
  [report fixtures test-var]
  (-> report
      (report-test-begin test-var)
      (report-test-end test-var (execute* fixtures test-var))))

(defn- report-namespace
  [report ns test-vars]
  (let [report       (report-namespace-begin report ns)
        once-fixture (-> ns meta ::once-fixtures join-fixtures)
        each-fixture (-> ns meta ::each-fixtures join-fixtures)]
    (try
      (report-namespace-end (with-fixtures [once-fixture]
                              (reduce (fn [report test-var]
                                        (if (continue? report)
                                          (report-test report each-fixture
                                                       test-var)
                                          (reduced report)))
                                      report
                                      test-vars))
                            ns
                            nil)
      (catch Exception e
        (report-namespace-end report
                              ns
                              [{:test-name    nil
                                :test-section nil
                                :ns           ns
                                :var          nil
                                :expr         nil
                                :line         nil
                                :type         :error
                                :expected     nil
                                :actual       e
                                :message
                                (str "Exception in namespace fixture: "
                                     (python/repr e))}])))))

(defn collect-tests
  "Get all tests from the given vars and/or namespaces. If none are
  given then default to the tests current namespace. Return a mapping
  of namespaces to test vars."
  [vars-or-namespaces]
  (->> (or (seq vars-or-namespaces)
           [*ns*])
       (mapcat #(if (var? %) (list %) (-> % ns-interns vals)))
       (filter (comp ::test meta))
       (group-by namespace)))

(defn compile-report
  "Build a report by running all tests from the given vars and/or
  namespaces. If none are given then default to the tests current
  namespace."
  [report vars-or-namespaces]
  (report-end
   (reduce (fn [report [ns test-vars]]
             (if (continue? report)
               (report-namespace report ns test-vars)
               (reduced report)))
           (report-begin report)
           (collect-tests vars-or-namespaces))))

(defn run-tests
  "Run all tests from the given vars and/or namespaces. If none are
  given then default to the tests current namespace. Print failures to
  standard output."
  [& vars-or-namespaces]
  (into {} (compile-report (->SimpleReport 0 0 0 0) vars-or-namespaces)))

(defn run-all-tests
  "Run all loaded tests. Print failures to standard output. Optionally
  filter tests by regex ``re``."
  ([]
   (apply run-tests (all-ns)))
  ([re]
   (->> (all-ns)
        (mapcat (comp vals ns-interns))
        (filter #(re-find re (subs (str %) 2)))
        (apply run-tests))))
