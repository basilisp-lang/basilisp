(in-ns 'basilisp.core)

(def ^{:doc      "Create a list from the arguments."
       :arglists '([& args])}
  list
  (fn* list [& args] args))

(def
  ^{:doc      "If o is a Seq, return the first element from o. If o is nil, return
               nil. Otherwise, coerces o to a Seq and returns the first."
    :arglists '([seq])}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc      "If o is a Seq, return the elements after the first in o. If o is nil,
               returns an empty seq. Otherwise, coerces o to a seq and returns the rest."
    :arglists '([seq])}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc      "Calls rest on o. If o returns an empty sequence or nil, returns nil.
               Otherwise, returns the elements after the first in o."
    :arglists '([seq])}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc      "Returns the second element in a Seq."
    :arglists '([seq])}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc      "Returns the first element in the first element of a Seq."
    :arglists '([seq])}
  ffirst
  (fn* ffirst [seq] (first (first seq))))

(def
  ^{:doc      "Creates a new sequence where o is the first element and seq is the rest.
               If seq is nil, return a list containing o. If seq is not a Seq, attempt
               to coerce it to a Seq and then cons o onto the resulting sequence."
    :arglists '([v seq])}
  cons
  (fn* cons [v seq] (basilisp.lang.runtime/cons v seq)))

(def ^{:doc      "Return the metadata from o, or nil if there is no metadata."
       :arglists '([o])}
  meta
  (fn* meta [o]
       (if (python/hasattr o "meta")
         (.-meta o)
         nil)))

(def ^{:doc      "Return o with the supplied metadata map assoc'ed into its existing metadata."
       :arglists '([o meta])}
  with-meta
  (fn* with-meta [o meta]
       (if meta
         (.with-meta o meta)
         o)))

(def ^:macro ^:redef let
  (fn* let [&env &form & decl]
       (cons 'let* decl)))

(def ^:macro ^:redef loop
  (fn* loop [&env &form & decl]
       (cons 'loop* decl)))

(def ^:macro ^:redef fn
  (fn* fn [&env &form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def ^{:doc      "Returns its argument unmodified."
       :arglists '([v])}
  identity
  (fn identity [v] v))

(def
  ^{:doc      "Return true if obj is an instance of class."
    :arglists '([class obj])}
  instance?
  (fn instance? [class obj]
    (python/isinstance obj class)))

(def
  ^{:doc      "Return true if obj is a boolean."
    :arglists '([o])}
  boolean?
  (fn boolean? [o]
    (instance? python/bool o)))

(def
  ^{:doc      "Return true if obj is a float."
    :arglists '([o])}
  float?
  (fn float? [o]
    (instance? python/float o)))

(def
  ^{:doc      "Return true if obj is an integer."
    :arglists '([o])}
  integer?
  (fn integer? [o]
    (instance? python/int o)))

(def
  ^{:doc      "Return true if obj is a string."
    :arglists '([o])}
  string?
  (fn string? [o]
    (instance? python/str o)))

(def
  ^{:doc      "Return true if obj is a symbol."
    :arglists '([o])}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc      "Return true if obj is a keyword."
    :arglists '([o])}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc      "Return true if o is a list."
    :arglists '([o])}
  list?
  (fn list? [o]
    (instance? basilisp.lang.interfaces/IPersistentList o)))

(def
  ^{:doc      "Return true if o is a map."
    :arglists '([o])}
  map?
  (fn map? [o]
    (instance? basilisp.lang.interfaces/IPersistentMap o)))

(def
  ^{:doc      "Return true if o is a set."
    :arglists '([o])}
  set?
  (fn set? [o]
    (instance? basilisp.lang.interfaces/IPersistentSet o)))

(def
  ^{:doc      "Return true if o is a vector."
    :arglists '([o])}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.interfaces/IPersistentVector o)))

(def
  ^{:doc      "Return true if o implements Seq."
    :arglists '([o])}
  seq?
  (fn seq? [o]
    (instance? basilisp.lang.interfaces/ISeq o)))

(def ^{:doc      "Coerce the argument o to a Seq. If o is nil, return nil."
       :arglists '([o])}
  seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def ^{:doc      "Apply function f to the arguments provided.

                  The last argument must always be coercible to a Seq. Intermediate
                  arguments are not modified."
       :arglists '([f & args])}
  apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def ^{:doc      "Concatenate the sequences given by seqs into a single Seq."
       :arglists '([& seqs])}
  concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def
  ^{:doc      "Create a hash map from pairs of input arguments."
    :arglists '([& kvs])}
  hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def
  ^{:doc      "Create a set from the input arguments."
    :arglists '([& members])}
  hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def
  ^{:doc      "Return a set with the contents of coll."
    :arglists '([coll])}
  set
  (fn set
    [coll]
    (^:allow-builtins basilisp.lang.set/set coll)))

(def
  ^{:doc      "Create a vector from the input arguments."
    :arglists '([& elems])}
  vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def
  ^{:doc      "Return a vector with the contents of coll."
    :arglists '([coll])}
  vec
  (fn vec
    [coll]
    (basilisp.lang.vector/vector coll)))

;;;;;;;;;;;; full support for syntax quote begins here ;;;;;;;;;;;;

(def
  ^{:doc      "Return the length of coll as by Python's len builtin. If the collection
               does not respond to __len__, then count it manually."
    :arglists '([coll])}
  count
  (fn count [coll]
    (try
      (python/len coll)
      (catch TypeError _
        (count (apply vector coll))))))

(def
  ^{:doc      "Returns a basilisp.lang.exception/ExceptionInfo instance with
               the given message and data."
    :arglists '([msg data])}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:doc      "Associate keys to values in associative data structure m. If m is nil,
               returns a new map with key-values kvs."
    :arglists '([m & kvs])}
  assoc
  (fn assoc [m & kvs]
    (apply basilisp.lang.runtime/assoc m kvs)))

(def
  ^{:doc      "Conjoin xs to collection. New elements may be added in different positions
               depending on the type of coll. conj returns the same type as coll. If coll
               is nil, return a list with xs conjoined."
    :arglists '([coll & xs])}
  conj
  (fn conj [coll & xs]
    (apply basilisp.lang.runtime/conj coll xs)))

(def
  ^{:macro    true
    :doc      "Define a new function with an optional docstring."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defn
  (fn defn [&env &form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (python/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta (if (map? (first body))
                  (first body)
                  nil)
          fname  (if doc
                   (with-meta name (assoc fmeta :doc doc))
                   (with-meta name fmeta))
          body   (if fmeta
                   (rest body)
                   body)
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       (apply list sigs)))
                   (list (first body)))
          fname  (with-meta fname {:arglists (list 'quote fsigs)})
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))]
      `(def ~fname
         (fn ~fname
              ~@body)))))

(defn nth
  "Returns the ith element of coll (0-indexed), if it exists.
  nil otherwise. If i is out of bounds, throws an IndexError unless
  notfound is specified."
  ([coll i]
   (basilisp.lang.runtime/nth coll i))
  ([coll i notfound]
   (basilisp.lang.runtime/nth coll i notfound)))

(defn nthnext
  "Returns the nth next sequence of coll.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn nthrest
  "Returns the nth rest sequence of coll, or coll if i is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn last
  "Return the last item in a seq, or nil if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(defn str
  "Create a string representation of o."
  ([] "")
  ([o] (basilisp.lang.runtime/lstr o))
  ([o & args]
   (let [coerce (fn [in out]
                  (if (seq (rest in))
                    (recur (rest in)
                           (conj out (basilisp.lang.runtime/lstr (first in))))
                    (conj out (basilisp.lang.runtime/lstr (first in)))))
         strs   (coerce (conj args o) [])]
     (.join "" strs))))

(defn symbol
  "Create a new symbol with name and optional namespace ns."
  ([name]
   (basilisp.lang.symbol/symbol name))
  ([ns name]
   (basilisp.lang.symbol/symbol name ns)))

(defn keyword
  "Create a new keyword with name and optional namespace ns. Keywords
  will have the colon prefix added automatically, so it should not be
  provided."
  ([name]
   (basilisp.lang.keyword/keyword name))
  ([ns name]
   (basilisp.lang.keyword/keyword name ns)))

(defn name
  "Return the name of a string, symbol, or keyword."
  [v]
  (if (string? v)
    v
    (.-name v)))

(defn namespace
  "Return the namespace of a symbol or keyword, or nil if no namespace."
  [v]
  (.-ns v))

(def
  ^{:macro    true
    :doc      "Define a new macro like defn. Macro functions are available to the
               compiler during macroexpansion."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defmacro
  (fn defmacro [&env &form name & body]
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta  (if (map? (first body))
                   (first body)
                   nil)
          body   (if fmeta
                   (rest body)
                   body)
          fname  (if doc
                   (with-meta name (assoc fmeta :doc doc :macro true))
                   (with-meta name (assoc fmeta :macro true)))
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       `(quote ~(apply list sigs))))
                   `(quote ~(list (first body))))
          fname  (with-meta fname {:arglists fsigs})

          add-implicit-args (fn [body]
                              (cons
                               (if (vector? (first body))
                                 (apply vector
                                        (cons '&env
                                              (cons '&form
                                                    (first body))))
                                 (throw
                                  (ex-info "Expected an argument vector"
                                           {:found (first body)})))
                               (rest body)))

          add-args-for-each (fn [in out]
                              (if (seq (rest in))
                                (recur (rest in)
                                       (conj out (add-implicit-args (first in))))
                                (conj out (add-implicit-args (first in)))))

          body (if multi?
                 (add-args-for-each body [])
                 (add-implicit-args body))]
      `(defn ~fname
         ~@body))))

(defmacro defasync
  "Define a new asynchronous function with an optional docstring."
  [name & body]
  (let [body   (concat body)
        doc    (if (string? (first body))
                 (first body)
                 nil)
        body   (if doc
                 (rest body)
                 body)
        fmeta (if (map? (first body))
                (assoc (first body))
                nil)
        body   (if fmeta
                 (rest body)
                 body)
        fmeta (apply assoc fmeta (concat [:async true]
                                         (if doc
                                           [:doc doc]
                                           nil)))]
    `(defn ~name
       ~fmeta
       ~@body)))

(defn macroexpand-1
  "Macroexpand form one time. Returns the macroexpanded form. The return
  value may still represent a macro. Does not macroexpand child forms."
  [form]
  (basilisp.lang.compiler/macroexpand-1 form))

(defn macroexpand
  "Repeatedly macroexpand form as by macroexpand-1 until form no longer
  represents a macro. Returns the expanded form. Does not macroexpand child
  forms."
  [form]
  (basilisp.lang.compiler/macroexpand form))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Comparisons & Macros ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro if-not
  "Evaluate cond and if it is true, return false-cond. Otherwise return
  true-cond."
  [cond true-cond false-cond]
  `(if ~cond
     ~false-cond
     ~true-cond))

(defmacro if-let
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is true. Otherwise, return the
  false expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if expr#
       (let [~(first binding) expr#]
         ~true-cond)
       ~false-cond)))

(defmacro if-some
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is not nil. Otherwise, return the
  false expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if (operator/is- expr# nil)
       ~false-cond
       (let [~(first binding) expr#]
         ~true-cond))))

(defmacro when
  "Evaluate cond and if it is true, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     (do ~@body)
     nil))

(defmacro when-let
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is true. Return nil otherwise."
  [binding & body]
  `(if-let ~binding
     (do ~@body)
     nil))

(defmacro when-some
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is not nil. Return nil otherwise."
  [binding & body]
  `(if-some ~binding
     (do ~@body)
     nil))

(defmacro when-not
  "Evaluate cond and if it is false, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     nil
     (do ~@body)))

(defmacro and
  "Evaluate the expressions from left to right. If all expressions are true,
  return the result of the final expression. Otherwise, returns the first
  false expression. Calling and with no arguments returns true."
  ([] true)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          (and ~@(rest args))
          expr#))
     (first args))))

(defmacro or
  "Evaluate the expressions from left to right. Returns the first true
  expression. Otherwise, returns the final falsy expression. Calling or
  with no arguments returns nil."
  ([] nil)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          expr#
          (or ~@(rest args))))
     (first args))))

(defmacro cond
  "Given groups of test/expression pairs, evaluate each test and, if
  true, return the expression. Otherwise, continue through until reaching
  the final expression."
  [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw
             (ex-info "cond requires an even number of forms"
                      {:first (first clauses)})))
          (cons 'basilisp.core/cond (nthrest clauses 2)))))

(defn not
  "Return the logical negation of expr."
  [expr]
  (if expr false true))

(defn apply-kw
  "Apply function f to the arguments provided, passing the keys from
  the final argument (which must be a map) as Python keyword arguments
  to f. Keywords and symbol keys will be converted to strings and munged
  to be legal Python identifiers, to avoid errors.

  The last argument must always be coercible to a Mapping. Intermediate
  arguments are not modified."
  [f & args]
  (basilisp.lang.runtime/apply-kw f args))

(defn hash
  "Return the hash code for its argument."
  [x]
  (python/hash x))

(defn identical?
  "Return true if x and y are the same object, otherwise false."
  [x y]
  (operator/is_ x y))

(defn =
  "Return true if x and y are equal, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (basilisp.lang.runtime/equals x (first args))
       (recur (first args) (rest args))
       false)
     (basilisp.lang.runtime/equals x (first args)))))

(defn not=
  "Return true if x and y are not equal, otherwise false."
  [& args]
  (not (apply = args)))

(defn >
  "Return true if arguments are monotonically decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/gt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/gt x (first args)))))

(defn >=
  "Return true if arguments are decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/ge x (first args))
       (recur (first args) (rest args))
       false)
     (operator/ge x (first args)))))

(defn <
  "Return true if arguments are monotonically increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/lt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/lt x (first args)))))

(defn <=
  "Return true if arguments are increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/le x (first args))
       (recur (first args) (rest args))
       false)
     (operator/le x (first args)))))

(defn distinct?
  "Return true if no two arguments are equal."
  [& args]
  (= (count (vec args))
     (count (set args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Management Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn deref
  "Dereference a delay or atom and returns its contents.

  If o is an object implementing IBlockingDeref and timeout-s and
  timeout-val are supplied, deref will wait at most timeout-s seconds,
  returning timeout-val if timeout-s seconds elapse and o has not
  returned."
  ([o]
   (basilisp.lang.runtime/deref o))
  ([o timeout-s timeout-val]
   (basilisp.lang.runtime/deref o timeout-s timeout-val)))

(defn compare-and-set!
  "Atomically set the value of atom to new-val if and only if old-val
  is the current value of the atom."
  [atom old-val new-val]
  (.compare-and-set atom old-val new-val))

(defn reset!
  "Reset the value of an atom to v without regard to the previous value.
  Return the new value."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      v
      (recur atom v))))

(defn reset-vals!
  "Reset the value of an atom to v without regard to the previous value.
  Return a vector containing the new value and the old value in that order."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      [v current]
      (recur atom v))))

(defn swap!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return the new value."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      new-val
      (recur atom f args))) )

(defn swap-vals!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return a vector containing
  the new value and the old value in that order."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      [new-val current]
      (recur atom f args))))

(defn atom
  "Return an Atom containing v. The value of an Atom at any point in time
  may be returned by deref'ing it. The value of an atom may be reset using
  reset! and may be swapped using swap!. All operations on an atom occur
  atomically."
  [v]
  (basilisp.lang.atom/Atom v))

(defn realized?
  "Return true if the delay or lazy sequence has been realized."
  [o]
  (.-is-realized o))

(defmacro delay
  "Takes a body of expressions producing any value. Will not produce a
  value until deref'ed. The result is cached and returned in future
  derefs."
  [& body]
  (list 'basilisp.lang.delay/Delay
        (concat '(fn* []) body)))

(defn delay?
  "Return true if x names a delay."
  [x]
  (instance? basilisp.lang.delay/Delay x))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/add x (first args)) (rest args))
     (operator/add x (first args)))))

(defn -
  "Subtract the arguments. If one argument given, returns the negation
  of that argument."
  ([x] (operator/neg x))
  ([x & args]
   (if (seq (rest args))
     (recur (operator/sub x (first args)) (rest args))
     (operator/sub x (first args)))))

(defn *
  "Multiply the arguments. If no arguments given, returns 1."
  ([] 1)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/mul x (first args)) (rest args))
     (operator/mul x (first args)))))

(defn /
  "Divide the arguments. If no arguments given, returns the inverse of
  the argument."
  ([x] (basilisp.lang.runtime/divide 1 x))
  ([x & args]
   (if (seq (rest args))
     (recur (basilisp.lang.runtime/divide x (first args)) (rest args))
     (basilisp.lang.runtime/divide x (first args)))))

(defn mod
  "Returns the modulo of num and div."
  [num div]
  (operator/mod num div))

(defn quot
  "Returns the quotient of num and div."
  [num div]
  (basilisp.lang.runtime/quotient num div))

(defn rem
  "Returns the remainder of num and div."
  [num div]
  (- num (* div (quot num div))))

(defn inc
  "Increment the argument by 1."
  [x]
  (+ x 1))

(defn dec
  "Decrement the argument by 1."
  [x]
  (- x 1))

(defn min
  "Return the minimum of the arguments."
  [& args]
  (python/min args))

(defn max
  "Return the maximum of the arguments."
  [& args]
  (python/max args))

(defn numerator
  "Return the numerator of a Fraction."
  [frac]
  (.-numerator frac))

(defn denominator
  "Return the denominator of a Fraction."
  [frac]
  (.-denominator frac))

(defn sort
  "Return a sorted sequence of the elements from coll."
  ([coll]
   (basilisp.lang.runtime/sort coll))
  ([cmp coll]
   (basilisp.lang.runtime/sort coll cmp)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Simple Predicates ;;
;;;;;;;;;;;;;;;;;;;;;;;

(import* decimal fractions uuid)

(defn any?
  "Return true for any x."
  [_]
  true)

(defn associative?
  "Return true if x implements IAssociative."
  [x]
  (instance? basilisp.lang.interfaces/IAssociative x))

(defn bytes?
  "Return true if x is a byte array (the Python `bytearray` type).

  Note that Python supplies byte string and byte array objects in its standard
  library. This function complies with Clojure's standard library in returning
  true iff x is a Python bytearray. To check if an object is a Python `bytes`,
  use `byte-string?`."
  [x]
  (instance? python/bytearray x))

(defn byte-string?
  "Return true if x is a byte string (the Python `bytes` type).

  Note that Python supplies byte string and byte array objects in its standard
  library. To check if an object is a Python `bytearray`, use `bytes?`."
  [x]
  (instance? python/bytes x))

(defn class?
  "Return true if x names a type."
  [x]
  (instance? python/type x))

(defn coll?
  "Return true if x implements IAssociative."
  [x]
  (instance? basilisp.lang.interfaces/IPersistentCollection x))

(defn complex?
  "Return true if x is a complex number."
  [x]
  (instance? python/complex x))

(defn decimal?
  "Return true if x is a Decimal."
  [x]
  (instance? decimal/Decimal x))

(defn even?
  "Return true if x is even."
  [x]
  (if (= 0 (mod x 2)) true false))

(defn false?
  "Return true if x is false, otherwise false."
  [x]
  (operator/is- x false))

(def double? float?)

(defn fn?
  "Return true if x is a function created by `fn` or `fn*`."
  [x]
  (and (python/callable x)
       (python/hasattr x "_basilisp_fn")
       (python/getattr x "_basilisp_fn")))

(defn ident?
  "Return true if x is either a keyword or symbol."
  [x]
  (or (keyword? x) (symbol? x)))

(defn ifn?
  "Return true if x is callable as a function.

  Many Basilisp data structures are callable as functions though
  they are not proper function types."
  [x]
  (python/callable x))

(def ^{:doc "Return true if x is an integer.

             Note that unlike Clojure, Basilisp uses Python integers and
             there is no distinction between standard and fixed-precision
             integers."}
  int?
  integer?)

(defn map-entry?
  "Return true if x implements IMapEntry."
  [x]
  (instance? basilisp.lang.interfaces/IMapEntry x))

(defn neg?
  "Return true if x is negative."
  [x]
  (if (operator/lt x 0) true false))

(defn non-neg?
  "Return true if x is not negative."
  [x]
  (if (operator/ge x 0) true false))

(defn nat-int?
  "Return true if x is a non-negative integer"
  [x]
  (and (integer? x) (non-neg? x)))

(defn neg-int?
  "Return true if x is a negative integer."
  [x]
  (and (integer? x) (neg? x)))

(defn nil?
  "Return true if x is nil, otherwise false."
  [x]
  (operator/is- x nil))

(defn some?
  "Return true if x is not nil, otherwise false."
  [x]
  (not (nil? x)))

(defn number?
  "Return true if x is a number."
  [x]
  (or (integer? x) (float? x) (complex? x)))

(defn odd?
  "Return true if x is odd."
  [x]
  (if (= 1 (mod x 2)) true false))

(defn pos?
  "Return true if x is positive."
  [x]
  (if (operator/gt x 0) true false))

(defn pos-int?
  "Return true if x is a positive integer."
  [x]
  (and (integer? x) (pos? x)))

(defn py-dict?
  "Return true if x is a Python `dict`."
  [x]
  (instance? python/dict x))

(defn py-frozenset?
  "Return true if x is a Python `frozenset`."
  [x]
  (instance? python/frozenset x))

(defn py-list?
  "Return true if x is a Python `list`."
  [x]
  (instance? python/list x))

(defn py-set?
  "Return true if x is a Python `set`."
  [x]
  (instance? python/set x))

(defn py-tuple?
  "Return true if x is a Python `tuple`."
  [x]
  (instance? python/tuple x))

(defn qualified-ident?
  "Return true if x is either a keyword or symbol with a namespace."
  [x]
  (and (ident? x) (some? (namespace x))))

(defn qualified-keyword?
  "Return true if x is a keyword with a namespace."
  [x]
  (and (keyword? x) (some? (namespace x))))

(defn qualified-symbol?
  "Return true if x is a symbol with a namespace."
  [x]
  (and (symbol? x) (some? (namespace x))))

(defn ratio?
  "Return true if x is a Fraction."
  [x]
  (instance? fractions/Fraction x))

(defn rational?
  "Return true if x is a rational number."
  [x]
  (or (int? x) (ratio? x) (decimal? x)))

(defn real-number?
  "Return true if x is a real number."
  [x]
  (or (integer? x) (float? x)))

(defn seqable?
  "Return true if an ISeq can be produced from x."
  [x]
  (instance? basilisp.lang.interfaces/ISeqable x))

(defn simple-keyword?
  "Return true if x is a keyword with no namespace."
  [x]
  (and (keyword? x) (nil? (namespace x))))

(defn special-symbol?
  "Return true if x is a special form symbol."
  [x]
  (basilisp.lang.runtime/is-special-form x))

(defn simple-symbol?
  "Return true if x is a symbol with no namespace."
  [x]
  (and (symbol? x) (nil? (namespace x))))

(defn true?
  "Return true if x is true, otherwise false."
  [x]
  (operator/is- x true))

(defn uuid?
  "Return true if x is a UUID."
  [x]
  (instance? uuid/UUID x))

(defn uuid-like?
  "Return true if x is coercible to a UUID.

  Python's UUID constructor supports byte sequences in big- and little-
  endian byte orders. This function checks only for big-endian bytes."
  [x]
  (try
    (cond
      (uuid? x)         true
      (string? x)       (do (uuid/UUID x) true)
      (int? x)          (do (apply-kw uuid/UUID {:int x}) true)
      (byte-string? x)  (do (apply-kw uuid/UUID {:bytes x}) true)
      (or (py-tuple? x)
          (vector? x))  (do (apply-kw uuid/UUID {:fields x}) true)
      :else             false)
    (catch python/AttributeError _ false)
    (catch python/TypeError _ false)
    (catch python/ValueError _ false)))

(defn var?
  "Return true if x is a Var."
  [x]
  (instance? basilisp.lang.runtime/Var x))

(defn zero?
  "Return true if x is 0."
  [x]
  (= 0 x))

;;;;;;;;;;;;;;;;
;; Exceptions ;;
;;;;;;;;;;;;;;;;

(def ^{:doc     "During a REPL session, bound to the most recent value evaluated."
       :dynamic true}
  *1
  nil)
(def ^{:doc     "During a REPL session, bound to the second most recent value evaluated."
       :dynamic true}
  *2
  nil)
(def ^{:doc     "During a REPL session, bound to the third most recent value evaluated."
       :dynamic true}
  *3
  nil)
(def ^{:doc     "During a REPL session, bound to the most recently thrown exception."
       :dynamic true}
  *e
  nil)

(defn ex-cause
  "Return the cause (another Exception) of ex if it derives from Exception,
  otherwise it returns nil."
  [ex]
  (when (instance? python/Exception ex)
    (or (.- ex __cause__) (.- ex __context__))))

(defn ex-data
  "Return the data map of ex if is an instance of IExceptionInfo, otherwise
  it returns nil."
  [ex]
  (when (instance? basilisp.lang.interfaces/IExceptionInfo ex)
    (.-data ex)))

(defn ex-message
  "Return the message of ex if is an Exception, otherwise
  it returns nil."
  [ex]
  (when (instance? python/Exception ex)
    (python/getattr ex "message" (python/str ex))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Bit Manipulation Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn bit-and
  "Return the bitwise and of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (first args)) rest-arg)
    (operator/and- x (first args))))

(defn bit-or
  "Return the bitwise or of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/or- x (first args)) rest-arg)
    (operator/or- x (first args))))

(defn bit-not
  "Invert the bits of x."
  [x]
  (operator/invert x))

(defn bit-shift-left
  "Return x shifted left n bits."
  [x n]
  (operator/lshift x n))

(defn bit-shift-right
  "Return x shifted right n bits."
  [x n]
  (operator/rshift x n))

(defn bit-xor
  "Return the bitwise xor of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/xor x (first args)) rest-arg)
    (operator/xor x (first args))))

(defn bit-and-not
  "Return the bitwise and complement of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (operator/not- (first args))) rest-arg)
    (operator/and- x (operator/not- (first args)))))

(defn bit-clear
  "Clear the bit of x at index n."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip
  "Flip the bit of x at index n."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-set
  "Set the bit of x at index n."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-test
  "Test the bit of x at index n."
  [x n]
  (bit-and (bit-shift-right x n) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn contains?
  "Return true if coll contains k. For vectors, k is an index. For maps, k is
  a key. For sets, k is a value in the set."
  [coll k]
  (basilisp.lang.runtime/contains coll k))

(defn disj
  "Return a new version of the set s without the given elements. If the elements
  don't exist in s, they are ignored."
  ([s] s)
  ([s & elems]
   (apply (.-disj s) elems)))

(defn dissoc
  "Return a new version of m without the given keys. If the keys
  don't exist in m, they are ignored."
  [m & ks]
  (apply (.-dissoc m) ks))

(defn empty
  "Return an empty collection of the same interface type as coll, or nil."
  [coll]
  (when (coll? coll)
    (.empty coll)))

(defn get
  "Return the entry of m corresponding to k if it exists or nil/default otherwise."
  ([m k]
   (basilisp.lang.runtime/get m k))
  ([m k default]
   (basilisp.lang.runtime/get m k default)))

(defn assoc-in
  "Associate value in a nested associative structure, with ks as a sequence of
  keys and v as the new value. If no map exists for any key in ks, a new empty
  map will be created."
  [m ks v]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m fk (assoc-in (get m fk) rks v))
      (basilisp.lang.runtime/assoc m fk v))))

(defn get-in
  "Return the entry of an associative data structure addressed by the sequence of
  keys ks or default (default: nil) if the value is not found."
  ([m ks]
   (get-in m ks nil))
  ([m ks default]
   (let [fk  (first ks)
         rks (rest ks)]
     (if (seq rks)
       (if-let [child-map (basilisp.lang.runtime/get m fk)]
         (get-in child-map rks default)
         default)
       (basilisp.lang.runtime/get m fk default)))))

(defn update
  "Updates the value for key k in associative data structure m with the return value
  from calling (f old-v & args). If m is nil, use an empty map. If k is not in m,
  old-v will be nil."
  [m k f & args]
  (apply basilisp.lang.runtime/update m k f args))

(defn update-in
  "Updates the value for key k in associative data structure m with the return value
  from calling (f old-v & args). If m is nil, use an empty map. If k is not in m,
  old-v will be nil."
  [m ks f & args]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m
                                   fk
                                   (apply update-in
                                          (or (basilisp.lang.runtime/get m fk) {})
                                          rks
                                          f
                                          args))
      (apply basilisp.lang.runtime/update m fk f args))))

(defn map-entry
  "With one argument, coerce the input to a map entry. With two arguments, return a
  map entry containing key and value."
  ([coll]
   (if (= 2 (count coll))
     (basilisp.lang.map.MapEntry/from-vec coll)
     (throw
      (ex-info "Cannot coerce object to basilisp.lang.map.MapEntry"
               {:coll coll
                :type (type coll)}))))
  ([k v]
   (basilisp.lang.map.MapEntry/of k v)))

(defn find
  "Find the map entry of k in m, if it exists. Return nil otherwise."
  [m k]
  (when-let [v (get m k)]
    (map-entry k v)))

(defn key
  "Return the key from a map entry."
  [entry]
  (.-key entry))

(defn val
  "Return the val from a map entry."
  [entry]
  (.-value entry))

(defn keys
  "Return a seq of the keys from a map."
  [m]
  (seq (.keys m)))

(defn vals
  "Return a seq of the values from a map."
  [m]
  (seq (.values m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher Order Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro lazy-seq
  "Takes a body of expressions which will produce a seq or nil. When
  seq is first called on the resulting lazy-seq, the sequence will be
  realized."
  [& body]
  (list 'basilisp.lang.seq/LazySeq
        (concat '(fn* []) body)))

(defn iterate
  "Returns a lazy sequence of (f x), (f (f x)) and so on."
  [f x]
  (lazy-seq
   (let [v (f x)]
     (when v
       (cons v (iterate f v))))))

(defn range
  "Return a range of integers from start. If end is specified, the
  sequence will terminate at end."
  ([]
   (iterate inc -1))
  ([end]
   (lazy-seq (cons 0 (range 1 end))))
  ([start end]
   (lazy-seq (cons start (when (< start (dec end))
                           (range (inc start) end)))))
  ([start end step]
   (lazy-seq (let [next-int (+ start step)]
               (cons start (when (< next-int (dec end))
                             (range next-int end step)))))))

(defn complement
  "Return a function which returns the logical complement of the return
  value of (apply f args)."
  [f]
  (fn [& args]
    (not (apply f args))))

(defn constantly
  "Returns a function that accepts any number of arguments and returns x."
  [x]
  (fn [& ^:no-warn-when-unused args] x))

(defn reduce
  "Reduce coll by f.

  If val is not supplied and coll has no elements, f will be called
  with no arguments and the result will be returned.

  If val is not supplied and coll has one element, the result of
  (f (first val)) is returned.

  If val is not supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll.

  If val is supplied and coll has no elements, the result of (f val)
  is returned.

  If val is supplied and coll has elements, repeatedly reduce coll
  by calling f on successive elements in coll, starting with val."
  ([f coll]
   (if (seq coll)
     (if (seq (rest coll))
       (reduce f (first coll) (rest coll))
       (first coll))
     (f)))
  ([f val coll]
   (let [reduce-coll (fn [out in]
                       (if (seq in)
                         (recur (f out (first in)) (rest in))
                         out))]
     (if (seq coll)
       (reduce-coll val coll)
       (f val)))))

(defn comp
  "Return a function which is the composition of all the functions
  given as arguments. Note that, as in mathematical function composition,
  the argument functions are called from right to left."
  ([] identity)
  ([f] f)
  ([f & args]
   (let [composed (reduce (fn [f g]
                            (fn [& args]
                              (f (apply g args))))
                          f
                          args)]
     (fn [& inner-args]
       (apply composed inner-args)))))

(defn juxt
  "Return a function which takes any number of arguments and applies each of
  the argument functions to this function in order, returning a vector of the
  return values from each function."
  [& args]
  (fn [& inner-args]
    (reduce (fn [v f]
              (conj v (apply f inner-args)))
            []
            args)))

(defn partial
  "Return a function which is the partial application of f with args."
  [f & args]
  (apply basilisp.lang.runtime/partial f args))

(defn every?
  "Return true if every element in coll satisfies pred."
  [pred coll]
  (cond
    (nil? (seq coll))   true
    (pred (first coll)) (recur pred (rest coll))
    :else               false))

(def
  ^{:doc "Return true if not every element in coll satisfies pred."}
  not-every?
  (comp not every?))

(defn some
  "Return true if at least one element in coll satisfies pred."
  [pred coll]
  (when (seq coll)
    (or (pred (first coll))
        (recur pred (rest coll)))))

(def
  ^{:doc "Return true if no element in coll satisfies pred."}
  not-any?
  (comp not some))

(defn map
  "Return a lazy sequence of (f elem) for elements in coll."
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (cons (f (first coll)) (map f (rest coll))))))
  ([f coll & colls]
   (lazy-seq
    (when (and (seq coll) (every? seq colls))
      (cons (apply f (first coll) (map first colls))
            (apply map f (rest coll) (map rest colls)))))))

(defn map-indexed
  "Return a lazy sequence of (f idx elem) for elements in coll. The
  index starts at 0."
  [f coll]
  (map f (range) coll))

(defn mapcat
  "Return a lazy sequence of the concatenated results of mapping f over
  colls."
  [f & colls]
  (apply concat (apply map f colls)))

(defn filter
  "Return elements from coll where (pred elem) returns true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (cons (first coll) (filter pred (rest coll)))
       (filter pred (rest coll))))))

(defn remove
  "Return elements from coll where (pred elem) returns false."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (not (pred (first coll)))
       (cons (first coll) (remove pred (rest coll)))
       (remove pred (rest coll))))))

(defn take
  "Return the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (when (> n 0)
       (cons (first coll) (take (dec n) (rest coll)))))))

(defn take-while
  "Return elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (when (pred (first coll))
       (cons (first coll) (take-while pred (rest coll)))))))

(defn drop
  "Drop the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (> n 0)
       (drop (dec n) (rest coll))
       (seq coll)))))

(defn drop-while
  "Drop elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (drop-while pred (rest coll))
       (seq coll)))))

(defn drop-last
  "Drop all but the last n items of coll."
  ([coll]
   (drop-last 1 coll))
  ([n coll]
   (map (comp first vector) coll (drop n coll))))

(defn split-at
  "Split a collection at the nth item. Returns a vector of
  [(take n coll) (drop n coll)]."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Split a collection at the inflection point of pred. Returns a
  vector of [(take-while pred coll) (drop-while pred coll)]."
  [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

(defn group-by
  "Return a map whose keys are the result of calling f on each element
  in coll and whose values are vectors of the values which produced the
  corresponding key, in the order they were added."
  [f coll]
  (if-not (seq coll)
    {}
    (reduce (fn [m v]
              (let [group (f v)]
                (if (contains? m group)
                  (update m group conj v)
                  (assoc m group [v]))))
            {}
            coll)))

(defn interpose
  "Return a lazy sequence of elements of coll separated by sep. If
  coll is empty, return an empty sequence."
  [sep coll]
  (lazy-seq
   (when (seq coll)
     (if (seq (rest coll))
       (cons (first coll)
             (cons sep (interpose sep (rest coll))))
       (cons (first coll) nil)))))

(defn cycle
  "Cycle the items in coll infinitely."
  [coll]
  (let [coll-cycle (fn coll-cycle
                     [curr]
                     (lazy-seq
                      (if (seq curr)
                        (cons (first curr) (coll-cycle (rest curr)))
                        (coll-cycle coll))))]
    (coll-cycle coll)))

(defn repeat
  "Repeat x infinitely or n many times if n is specified. Returns a lazy
  sequence of the x."
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (lazy-seq
    (when (> n 0)
      (cons x (repeat (dec n) x))))))

(defn repeatedly
  "Call f infinitely or n many times if n is specified. Returns a lazy
  sequence of the return values."
  ([f]
   (lazy-seq (cons (f) (repeatedly f))))
  ([n f]
   (lazy-seq
    (when (> n 0)
      (cons (f) (repeatedly (dec n) f))))))

(defn take-nth
  "Return a lazy sequence of every nth element of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (<= n 0)
       (repeat (first coll))
       (cons (first coll)
             (take-nth n (drop (dec n) (rest coll))))))))

(defn partition
  "Return a lazy sequence of partitions of coll of size n at offsets
  of step elements. If step is not given, steps of size n will be used
  and there will be no overlap between partitions. If pad is given,
  partition will pull elements from pad until the final sequence is
  equal to size n."
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (cons (take n coll) (partition n step (drop step coll))))))
  ([n step pad coll]
   (lazy-seq
    (when (seq coll)
      (let [s  (take n coll)
            ns (count s)
            s  (if (< ns n)
                 (concat s (take (- n ns) pad))
                 s)]
        (cons s (partition n step pad (drop step coll))))))))

(defn partition-by
  "Return a lazy sequence of partitions, splitting coll each time f
  returns a different value."
  [f coll]
  (lazy-seq
   (when (seq coll)
     (let [elem  (first coll)
           felem (f elem)
           run   (cons elem (take-while #(= felem (f %)) (next coll)))]
       (cons run (partition-by f (seq (drop (count run) coll))))))))

(defn merge
  "Merge maps together from left to right as by conj. If a duplicate key
  appears in a map, the rightmost map's value for that key will be taken."
  [& maps]
  (when (some identity maps)
    (reduce #(conj %1 %2)
            {}
            maps)))

;;;;;;;;;;;;;;;;;;;;;;
;; Random Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(import* random)

(defn rand
  "Return a random real number between lower (default: 0) and upper (default: 1) inclusive."
  ([] (random/uniform 0 1))
  ([upper] (random/uniform 0 upper))
  ([lower upper] (random/uniform lower upper)))

(defn rand-int
  "Return a random integer between lower (default: 0) and upper inclusive."
  ([upper]
   (random/randrange 0 upper))
  ([lower upper]
   (random/randrange lower upper)))

(defn rand-nth
  "Return a random element from coll."
  [coll]
  (nth coll (rand-int (count coll))))

(defn random-sample
  "Return elements from coll with the random probability of prob."
  [prob coll]
  (filter (fn [_] (< (rand) prob)) coll))

(defn shuffle
  "Return a random permutation of coll."
  [coll]
  (vec (random/sample (python/list coll) (count coll))))

;;;;;;;;;;;;;;;;;;;;
;; Utility Macros ;;
;;;;;;;;;;;;;;;;;;;;

(defmacro apply-method
  "Apply arguments to a method call. Equivalent to (apply (.-method o) args)."
  [o method & args]
  `(apply (. ~o ~(symbol (str "-" method))) ~@args))

(defmacro comment
  "Ignore all the forms passed, returning nil."
  [& ^:no-warn-when-unused forms]
  nil)

(defmacro condp
  "Take a predicate and an expression and a series of clauses, call
  (pred test expr) on the first expression for each clause. The result
  expression from first the set of clauses for which this expression
  returns a truthy value will be returned from the condp expression.

  Clauses can take two forms:

  - test-expr result-expr
  - test-expr :>> result-fn, where :>> is a keyword literal

  For the ternary expression clause, the unary result-fn will be called
  with the result of the predicate."
  [pred expr & clauses]
  (when (seq clauses)
    (let [test-expr (first clauses)
          remaining (rest clauses)]
      (if (seq remaining)
        (let [result    (first remaining)
              remaining (rest remaining)]
          (cond
            (= result :>>) `(let [res# ~(list pred test-expr expr)]
                              (if res#
                                (~(first remaining) res#)
                                (condp ~pred ~expr ~@(rest remaining))))
            result         `(if ~(list pred test-expr expr)
                              ~result
                              (condp ~pred ~expr ~@remaining))
            :else          (throw
                            (ex-info "expected result expression"
                                     {:test test-expr}))))
        test-expr))))

(defmacro new
  "Create a new instance of class with args.

  New objects may be created as any of:
    (new python/str *args)
    (new python.str *args)
    (new python.str. *args)

  This is compatibility syntax for Clojure, since Python (and therefore
  Basilisp) do not require the new keyword for object instantiation."
  [class & args]
  (cond
    (not (symbol? class))
    (throw
     (ex-info "Expected a class name as a symbol"
              {:class-name class}))

    (namespace class)
    (let [n  (name class)
          ns (namespace class)
          s  (symbol (str ns "."
                          (if (.endswith n ".")
                            n
                            (str n "."))))]
      `(~s ~@args))

    :else
    (let [n (name class)
          s (symbol (if (.endswith n ".")
                      n
                      (str n ".")))]
      `(~s ~@args))))

(defn push-thread-bindings
  "Takes a map of Var/value pairs and applies the given value to the Var in the
  current thread.

  This call should be accompanied with a pop-thread-bindings call in a
  try/finally block.

  This function is a very low level function and its use is discouraged in favor
  of a higher level construct like the binding macros."
  [bindings]
  (basilisp.lang.runtime/push-thread-bindings bindings))

(defn pop-thread-bindings
  "Pop thread bindings set by a corresponding call to push-thread-bindings. This
  should not be called without a prior call to push-thread-bindings."
  []
  (basilisp.lang.runtime/pop-thread-bindings))

(defmacro binding
  "Establish thread-local bindings for the vars given. The bindings are guaranteed
  to clear once execution passes outside the scope of this block."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [var-bindings (reduce (fn [v pair]
                               (let [vvar (first pair)
                                     vval (second pair)]
                                 (conj v `(var ~vvar) vval)))
                             []
                             (partition 2 bindings))]
    `(try
       (do
         (push-thread-bindings (hash-map ~@var-bindings))
         ~@body)
       (finally
         (pop-thread-bindings)))))

(import* [time :as py-time])

(defn ^:private perf-counter
  []
  (py-time/perf-counter))

(defmacro time
  "Time the execution of expr. Return the result of expr and print the
  time execution took in milliseconds."
  [expr]
  `(let [start (perf-counter)]
     (try
       ~expr
       (finally
         (println (* 1000 (- (perf-counter) start)) "msecs")))))

;;;;;;;;;;;;;;;;;;;;;;
;; Threading Macros ;;
;;;;;;;;;;;;;;;;;;;;;;

(defmacro ->
  "Thread x through the forms. Places x in the second position of
  the first form, and then the resulting expression into the second
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->
        ~(if (seq? joining)
           (apply list (first joining) x (rest joining))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro ->>
  "Thread x through the forms. Places x in the last position of
  the first form, and then the resulting expression into the last
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->>
        ~(if (seq? joining)
           (concat joining (list x))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro some->
  "Thread x through the forms (as by ->) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (-> ~x ~(first forms))]
       (when-not (nil? result#)
         (some-> result# ~@(next forms))))
    x))

(defmacro some->>
  "Thread x through the forms (as by ->>) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (->> ~x ~(first forms))]
       (when-not (nil? result#)
         (some->> result# ~@(next forms))))
    x))

(defmacro cond->
  "Takes a test and form pair, threading x (as by ->) through each form for
  which the corresponding test evaluates as true. cond-> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (-> ~x ~(second clauses))
                ~x)]
       (cond-> e#
           ~@(nthnext clauses 2)))
    x))

(defmacro cond->>
  "Takes a test and form pair, threading x (as by ->>) through each form for
  which the corresponding test evaluates as true. cond->> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (->> ~x ~(second clauses))
                ~x)]
       (cond->> e#
         ~@(nthnext clauses 2)))
    x))

(defmacro as->
  "Bind x to name and thread it through the forms, replacing instances of name
  in forms with the threaded expression."
  [x name & forms]
  (if (seq forms)
    `(as->
         (let [~name ~x]
           ~(first forms))
         ~name
       ~@(next forms))
    x))

;;;;;;;;;;;;;;;;;;;;;;
;; String Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(import* os)

(defn format
  "Format a string as by Python's `%` operator."
  [fmt & args]
  (if (= 1 (count args))
    (let [arg (first args)]
      (if (or (map? arg) (py-dict? arg))
        (operator/mod fmt (python/dict arg))
        (operator/mod fmt arg)))
    (operator/mod fmt (python/tuple args))))

;;;;;;;;;;;;;;;;;;;;;;
;; Output Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;

(def ^:dynamic *in* sys/stdin)
(def ^:dynamic *out* sys/stdout)
(def ^:dynamic *err* sys/stderr)

(def ^:dynamic *print-sep* " ")

(defn repr
  "Return the reader representation of an object."
  [x]
  (basilisp.lang.runtime/lrepr x))

(defn flush
  "Flush the buffer currently bound to *out*."
  []
  (.flush *out*))

(defn newline
  "Write a platform specific newline to *out*."
  []
  (.write *out* os/linesep)
  nil)

(defmacro with-in-str
  "Evaluate body with *in* bound to a io.StringIO instance containing the
  string s."
  [s & body]
  `(binding [*in* (io/StringIO ~s)]
     ~@body))

(defmacro with-out-str
  "Capture the contents of text sent to *out* and return the contents as a
  string."
  [& body]
  `(binding [*out* (io/StringIO)]
     ~@body
     (. *out* ~'getvalue)))

(defn pr
  "Print the arguments to the stream bound to *out* in a format which
  is readable by the reader. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space).

  Note that some dynamically created Basilisp forms (such keywords and
  symbols) and Python objects may not be readable again."
  ([] nil)
  ([x]
   (.write *out* (repr x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn prn
  "Same as pr, but appending a newline afterwards."
  ([]
   (.write *out* \newline)
   nil)
  ([x]
   (let [stdout *out*]
     (.write stdout (repr x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn pr-str
  "Return the contents of calling pr on the args as a string."
  [& args]
  (with-out-str
    (apply pr args)))

(defn prn-str
  "Return the contents of calling prn on the args as a string."
  [& args]
  (with-out-str
    (apply prn args)))

(defn print
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (print ""))
  ([x]
   (.write *out* (str x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn println
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (println ""))
  ([x]
   (let [stdout *out*]
     (.write stdout (str x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn print-str
  "Return the contents of calling print on the args as a string."
  [& args]
  (with-out-str
    (apply print args)))

(defn println-str
  "Return the contents of calling println on the args as a string."
  [& args]
  (with-out-str
    (apply println args)))

(defn printf
  "Prints formatted output as per format.

  Does not append a newline."
  [fmt & args]
  (print (apply format fmt args)))

;;;;;;;;;;;;;;;;;;;;
;; REPL Utilities ;;
;;;;;;;;;;;;;;;;;;;;

(def
  ^{:doc "The default data readers used in reader macros. Overriding or
          attempting to change the root binding of this var will not
          change the default data readers."}
  default-data-readers
  basilisp.lang.reader.ReaderContext/_DATA_READERS)

(def
  ^{:doc     "Data readers map which will be merged in to the default data
              reader map used by the reader. Mappings should be qualified
              symbols to functions taking one argument. The function will
              receive an unevaluated data structure and must return some
              value to the reader."
    :dynamic true}
  *data-readers*
  {})

(def
  ^{:doc     "Resolver used for resolving namespace aliases when reading
              forms using read, read-string, etc."
    :dynamic true}
  *resolver*
  basilisp.lang.runtime/resolve-alias)

(defn read-string
  "Read a string of Basilisp code.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  Note that read-string should not be used to read string input from
  untrusted sources."
  ([s]
   (read-string {:eof :eofthrow} s))
  ([opts s]
   (first (basilisp.lang.reader/read-str s
                                         *resolver*
                                         *data-readers*
                                         (:eof opts)
                                         (if (= (:eof opts) :eofthrow)
                                           true
                                           false)
                                         (:features opts)
                                         (if (= :preserve (:read-cond opts))
                                           false
                                           true)))))

(defn read
  "Read the next form from the stream. If no stream is specified, uses
  the value currently bound to *in*.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  The stream must satisfy the interface of io.TextIOBase, but does not require
  any pushback capabilities. The default basilisp.lang.reader.StreamReader can
  wrap any object implementing TextIOBase and provide pushback capabilities."
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([opts stream]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     (:eof opts)
                                     (if (= (:eof opts) :eofthrow)
                                       true
                                       false)
                                     (:features opts)
                                     (if (= :preserve (:read-cond opts))
                                       false
                                       true))))
  ([stream eof-error? eof-value]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     eof-value
                                     eof-error?))))

(defn eval
  "Evaluate a form (not a string) and return its result."
  [form]
  (let [ctx    (basilisp.lang.compiler.CompilerContext. "<Eval Input>")
        module (.-module *ns*)]
    (basilisp.lang.compiler/compile-and-exec-form form
                                                  ctx
                                                  module)))

;;;;;;;;;;;;;;;;;;;
;; Var Utilities ;;
;;;;;;;;;;;;;;;;;;;

(defn alter-var-root
  "Atomically alter the Var root by calling (apply f root args) and setting
  the root as the result."
  [v f & args]
  (apply-method v alter-root f args))

(defn find-var
  "Return the Var named by namespace-qualified sym if it exists, or nil otherwise."
  [sym]
  (basilisp.lang.runtime.Var/find sym))

(defn thread-bound?
  "Return true if vars are thread-bound, which implies that a set! will succeed.
  Returns true if no vars are given."
  [& vars]
  (loop [v (first vars)
         r (rest vars)]
    (if-not v
      true
      (if (.-is-thread-bound v)
        (recur (first r) (rest r))
        false))))

(defn var-get
  "Return the value inside the Var. Return thread local bindings if they exist,
  otherwise, return the root binding."
  [v]
  @v)

(defn var-set
  "Set the binding of the Var. Must be thread-local."
  [v val]
  (if (thread-bound? v)
    (set! (.-value v) val)
    (throw
     (ex-info "Cannot set non-thread-bound Var binding" {:var v}))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defn all-ns
  "Return a sequence of all namespaces."
  []
  (vals @basilisp.lang.runtime.Namespace/-NAMESPACES))

(defn find-ns
  "Return the namespace named by sym if it exists, or nil otherwise."
  [sym]
  (basilisp.lang.runtime.Namespace/get sym))

(defn the-ns
  "If v is a symbol, return the Namespace named by that symbol if it
  exists. If v is a Namespace, return it. Otherwise, throw an exception."
  [v]
  (cond
    (symbol? v)
    (.get basilisp.lang.runtime/Namespace v)

    (instance? basilisp.lang.runtime/Namespace v)
    v

    :else
    (throw
     (ex-info "Expected a Symbol or a Namespace"
              {:value v
               :type  (python/type v)}))))

(defn intern
  "Finds or creates a Var in ns (which is either a namespace or symbol),
  setting the root binding to val, if provided. The namespace must exist.
  Return the Var."
  ([ns name]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name)]
     (.intern ns v)))
  ([ns name val]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name)]
     (set! (.-root v) val)
     (.intern ns v))))

(defn create-ns
  "Create a Namespace with the name ns-sym or return the existing one
  if it already exists."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/get-or-create ns-sym))

(defn remove-ns
  "Remove the namespace named by the symbol."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/remove ns-sym))

(defn ns-name
  "Return the name of the namespace, a symbol."
  [ns]
  (.-name ns))

(defn ns-aliases
  "Return a map of Basilisp namespaces which are aliased in the current
  namespace."
  [ns]
  (reduce (fn [m entry]
            (let [alias     (key entry)
                  namespace (symbol (name (val entry)))]
              (if (= alias namespace)
                m
                (assoc m alias namespace))))
          {}
          (.-aliases (the-ns ns))))

(defn ns-imports
  "Return a set of Python modules which are imported in the current
  namespace."
  [ns]
  (.-imports (the-ns ns)))

(defn ns-interns
  "Return a map of symbols to Vars which are interned in the current
  namespace."
  [ns]
  (.-interns (the-ns ns)))

(defn ns-unalias
  "Remove the alias for the symbol sym from ns. Return nil."
  [ns sym]
  (.remove-alias (the-ns ns) sym))

(defn ns-unmap
  "Remove the mapping for the symbol sym from ns. Return nil."
  [ns sym]
  (.unmap (the-ns ns) sym))

(defn ns-publics
  "Return a map of symbols to public Vars which are interned in the
  current namespace.

  Public vars are Vars which are declared without :private metadata."
  [ns]
  (let [interns (ns-interns (the-ns ns))]
    (if-not (seq interns)
      {}
      (reduce (fn [m entry]
                (if (:private (meta (val entry)))
                  m
                  (assoc m (key entry) (val entry))))
              {}
              interns))))

(defn ns-refers
  "Return a map of symbols to Vars which are referred in the current
  namespace."
  [ns]
  (.-refers (the-ns ns)))

(defn ns-map
  "Return a map of all the mapped symbols in the namespace.

  Includes the return values of ns-interns and ns-refers in one map."
  ([] (ns-map *ns*))
  ([ns]
   (let [resolved-ns (the-ns ns)]
     (merge
      (ns-interns resolved-ns)
      (ns-refers resolved-ns)))))

(defn ns-resolve
  "Return the Var which will be resolved by the symbol in the given namespace."
  [ns sym]
  (basilisp.lang.runtime/resolve-var sym (the-ns ns)))

(defn resolve
  "Return the Var which will be resolved by the symbol in the namespace currently
  bound to *ns*."
  [sym]
  (ns-resolve *ns* sym))

(defmacro import
  "Import a Python module by name."
  [module]
  `(import* ~module))

(defn refer
  "Refer Vars from the namespace named by ns-sym, subject to the filters specified.

  Supported filters:
  - :only [sym1 sym2], to only refer the specified symbols
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name"
  [ns-sym & filters]
  (let [current-ns *ns*
        ns         (the-ns ns-sym)
        filter-map (apply hash-map filters)]
    (if-not (seq filters)
      (.refer-all current-ns ns)
      (let [only    (set (:only filter-map))
            exclude (set (:exclude filter-map))
            rename  (or (:rename filter-map) {})

            interns (if (seq only)
                      (filter (fn [entry]
                                (contains? only (key entry)))
                              (ns-interns ns))
                      (ns-interns ns))
            interns (if (seq exclude)
                      (remove (fn [entry]
                                (contains? exclude (key entry)))
                              interns)
                      interns)
            interns (if (seq rename)
                      (reduce (fn [m entry]
                                (if (rename (key entry))
                                  (assoc m (rename (key entry)) (val entry))
                                  m))
                              {}
                              interns)
                      interns)

            do-refer (fn [refers]
                       (when (seq refers)
                         (let [entry (first (seq refers))
                               sym   (key entry)
                               var   (val entry)]
                           (.add-refer current-ns sym var)
                           (recur (rest refers)))))]
        (do-refer interns)))))

(def refer-basilisp
  "Refer Vars from basilisp.core using the same filter syntax as refer."
  (partial refer 'basilisp.core))

(def refer-clojure
  "Compatibility layer with JVM Clojure, which points to refer-basilisp."
  refer-basilisp)

(import importlib)

(defn ^:private add-refers
  "Refer all of the Vars named in syms from from-ns to to-ns."
  [to-ns from-ns syms]
  (when (seq syms)
    (let [var-sym (first syms)
          var     (get (ns-interns from-ns) var-sym)]
      (.add-refer to-ns var-sym var)
      (recur to-ns from-ns (rest syms)))))

(defn ^:private require-vec
  "Process a vector libspec for require."
  [current-ns v]
  (let [ns-sym (first v)
        opts   (apply hash-map (rest v))]
    (importlib/import-module (name ns-sym))
    (let [new-ns (the-ns ns-sym)]
      ;; Add the namespace alias
      (.add-alias current-ns (or (:as opts) ns-sym) new-ns)

      ;; Add refers
      (cond
        (= :all (:refer opts))
        (.refer-all current-ns new-ns)

        (:refer opts)
        (add-refers current-ns new-ns (:refer opts))

        :else nil))))

(defn ^:private require-sym
  "Process a symbol libspec for require."
  [s]
  (importlib/import-module (name s)))

(defn require
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:
  - symbols, which name fully qualified namespaces
  - vectors, which take the form [namespace-symbol & opts]

  Vector libspec arguments must be one of:
  - :as name, which will alias the imported namespace to the symbol name
  - :refer [& syms], which will refer syms in the local namespace directly"
  [& args]
  (let [current-ns *ns*

        do-require (fn [requires]
                     (when (seq requires)
                       (let [v (first requires)]
                         (cond
                           (vector? v) (require-vec current-ns v)
                           (symbol? v) (require-sym v)
                           :else             (throw
                                              (ex-info "Invalid libspec for require"
                                                       {:value v}))))
                       (recur (rest requires))))]
    (do-require args)
    (set! *ns* current-ns)
    nil))

(defmacro ns
  "Use this namespace pre-amble at the top of every namespace to declare
  the namespace name and import necessary Python modules and require
  Basilisp namespaces.

  You may include an optional docstring for the namespace to describe its
  purpose.

  Example:
    (ns my.namespace
       \"My namespace with code\"
       (:require
         [basilisp.string :as str])
       (:import inspect))"
  [name & opts]
  (when-not (and (symbol? name) (nil? (namespace name)))
    (throw (ex-info "Namespace name must be a non-namespaced symbol"
                    {:name name})))
  (let [doc  (when (string? (first opts))
               (first opts))
        opts (if doc (rest opts) opts)
        opts (when (seq opts)
               (reduce (fn [m opt]
                         (let [opt-name (first opt)
                               options  (rest opt)]
                           (when-not (keyword? opt-name)
                             (throw (ex-info "Namespace option must be a keyword"
                                             {:option opt-name})))
                           (assoc m opt-name (vec options))))
                       {}
                       opts))

        requires (when (:require opts)
                   `(require ~@(map #(list 'quote %) (:require opts))))
        imports  (when (:import opts)
                   (map (fn [v]
                          `(import ~v))
                        (:import opts)))]
    `(do
       (in-ns (quote ~name))
       ~requires
       ~@imports)))

;;;;;;;;;;;;;;;;;;;;;
;; Regex Functions ;;
;;;;;;;;;;;;;;;;;;;;;

(import re)

(defn re-pattern
  "Return a new re.Pattern instance."
  [s]
  (re/compile s))

(defn re-find
  "Returns the first match of a string to a pattern using re.search.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/search pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn re-matches
  "Returns a match of a string to a pattern using re.fullmatch.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/fullmatch pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn ^:private lazy-re-seq
  "Return a lazy sequence of the matches in a match iterator."
  [iter]
  (lazy-seq
   (when (first iter)
     (let [match (.group (first iter) 0)]
       (cons match (when (seq (rest iter))
                     (lazy-re-seq (rest iter))))))))

(defn re-seq
  "Returns a lazy sequence of matches of a string to a pattern using re.finditer.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (lazy-re-seq (seq (re/finditer pattern s))))

;;;;;;;;;;;;;;;;;;
;; Multimethods ;;
;;;;;;;;;;;;;;;;;;

(import basilisp.lang.multifn)

(defmacro defmulti
  "Define a new multimethod with the dispatch function."
  [name & body]
  (let [doc         (when (string? (first body))
                      (first body))
        body        (if doc
                      (rest body)
                      body)
        dispatch-fn (first body)
        opts        (apply hash-map (rest body))]
    `(def ~name (basilisp.lang.multifn/MultiFunction ~(quote name)
                                                     ~dispatch-fn
                                                     ~(or (:default opts) :default)))))

(defmacro defmethod
  "Add a new method to the multi-function which responds to dispatch-val."
  [multifn dispatch-val & fn-tail]
  `(. ~multifn (~'add-method ~dispatch-val (fn ~@fn-tail))))

(defn methods
  "Return a map of dispatch values to methods for the given multi function."
  [multifn]
  (.-methods multifn))

(defn get-method
  "Return the method which would respond to dispatch-val or nil if no method
  exists for dispatch-val."
  [multifn dispatch-val]
  (.get-method multifn dispatch-val))

(defn remove-method
  "Remove the method which responds to dispatch-val, if it exists. Return the
  multi function."
  [multifn dispatch-val]
  (.remove-method multifn dispatch-val)
  multifn)

(defn remove-all-methods
  "Remove all method for this multi-function. Return the multi function."
  [multifn]
  (.remove-all-methods multifn)
  multifn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn select-keys
  "Return a map with only the keys of m which are in ks."
  [m ks]
  (if-not (seq ks)
    {}
    (reduce (fn [new-map k]
              (if (contains? m k)
                (assoc new-map k (get m k))
                new-map))
            {}
            ks)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Destructuring Support ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn gensym
  "Generate a unique symbol name of the form prefix_#. If no prefix is
  given, then v_ will be used."
  ([]
   (gensym "v_"))
  ([prefix]
   (symbol (basilisp.lang.util/genname prefix))))

(defmulti ^:private destructure-def
  (fn [arg]
    (cond
      (symbol? arg) :symbol
      (vector? arg) :vector
      (map? arg)    :map
      :else         :default)))

(defmethod destructure-def :map
  [arg]
  (let [alias (or (:as arg) (gensym "map_arg_"))

        ;; :or bindings allow users to specify default values for certain
        ;; associative keys.
        or-bindings (:or arg)

        ;; Namespaced keywords can destructure into non-namespaced
        ;; local names by specifying the namespace and with the name
        ;; "keys", just as the non-namespaced name "keys" will access
        ;; non-namespaced keywords.
        ;;
        ;; (let [{:movie/keys [title actors]} {:movie/title  "Die Hard"
        ;;                                     :movie/actors ["Bruce Willis"]}]
        ;;   ...)
        ;;
        kw-keys (->> (keys arg)
                     (filter keyword?)
                     (filter #(= "keys" (name %))))

        ;; Keyword, string, and symbol keys may all be destructured from
        ;; associative types.
        kws  (mapcat (fn [kw]
                       (let [kw-ns (namespace kw)
                             syms  (get arg kw)]
                         (cond->> syms
                           kw-ns (map #(symbol kw-ns (name %))))))
                     kw-keys)
        strs (:strs arg)
        syms (:syms arg)

        ;; Fetch all the remaining keys in the map which do not
        ;; correspond to special functionality.
        remaining (->> [:as :or :strs :syms]
                       (concat kw-keys)
                       (apply dissoc arg))

        ;; Destructuring forms may be nested arbitrarily, so generate the
        ;; definitions for any nested destructured forms as well.
        children (map #(vector % (destructure-def %)) (keys remaining))]
    {:name alias
     :type :map
     :keys kws
     :strs strs
     :syms syms

     :or-bindings or-bindings
     :remaining   (->> children
                       (filter #(not= :symbol (:type (second %))))
                       (map first)
                       (apply dissoc remaining))

     :children (map second children)}))

(defmethod destructure-def :symbol
  [arg]
  {:name arg
   :type :symbol})

(defmethod destructure-def :vector
  [arg]
  (let [;; Fetch the name bound to this argument with any trailing
        ;; :as key.
        alias-args (drop-while (partial not= :as) arg)
        alias      (->> alias-args (apply hash-map) :as)

        ;; Split the remaining arguments into sequential arguments
        ;; and the rest arg (if one at all).
        args (->> arg
                  (drop-last (count alias-args))
                  (split-with (partial not= '&)))

        sequential-args (first args)
        rest-arg        (second args)]
    {:name       (or alias (gensym "vec_arg_"))
     :type       :vector
     :rest       (when (seq rest-arg)
                   {:starts (count sequential-args)
                    :name   (second rest-arg)})
     :children   (map destructure-def sequential-args)}))

(defmethod destructure-def :default
  [arg]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (python/type arg)})))

(defmulti ^:private destructure-binding
  (fn [ddef]
    (:type ddef)))

(defmethod destructure-binding :vector
  [ddef]
  (let [fn-arg          (:name ddef)
        sequential-args (->> (:children ddef)
                             (map-indexed (fn [idx child]
                                            (let [alias (:name child)]
                                              (concat
                                               [alias `(nth ~fn-arg ~idx nil)]
                                               (when-not (= :symbol (:type child))
                                                 (destructure-binding child))))))
                             (apply concat))
        rest-def        (:rest ddef)
        rest-arg        (when rest-def
                          [(:name rest-def) `(nthnext ~fn-arg ~(:starts rest-def))])]
    (concat
     sequential-args
     rest-arg
     (->> (:children ddef)
          (filter #(not= :symbol (:type %)))
          (mapcat destructure-binding)))))

(defmethod destructure-binding :map
  [ddef]
  (let [fn-arg (:name ddef)
        ors    (:or-bindings ddef)

        kw-binding (fn [arg]
                     (let [kw-ns      (namespace arg)
                           kw-name    (name arg)
                           sym        (symbol kw-name)
                           kw         (if kw-ns
                                        (keyword kw-ns kw-name)
                                        (keyword kw-name))
                           or-binding (get ors sym)]
                       (if or-binding
                         [sym `(or (get ~fn-arg ~kw) ~or-binding)]
                         [sym `(get ~fn-arg ~kw)])))

        map-binding (fn [f arg]
                      (let [k          (f arg)
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg ~k) ~or-binding)]
                          [arg `(get ~fn-arg ~k)])))

        sym-binding (fn [arg]
                      (let [k          (symbol (name arg))
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg (quote ~k)) ~or-binding)]
                          [arg `(get ~fn-arg (quote ~k))])))

        rem-binding (fn [arg]
                      (let [binding    (key arg)
                            key        (val arg)
                            or-binding (get ors binding)]
                        (if or-binding
                          [binding `(or (get ~fn-arg (quote ~key)) ~or-binding)]
                          [binding `(get ~fn-arg ~key)])))

        child-binding (fn [child]
                        (let [alias (name (:name child))
                              arg   (symbol alias)
                              k     (keyword alias)]
                          [arg `(get ~fn-arg ~k)]))

        non-sym-children (filter #(not= :symbol (:type %)) (:children ddef))]
    (concat
     (mapcat kw-binding (:keys ddef))
     (mapcat (partial map-binding name) (:strs ddef))
     (mapcat sym-binding (:syms ddef))
     (mapcat rem-binding (:remaining ddef))
     (mapcat child-binding non-sym-children)
     (mapcat destructure-binding non-sym-children))))

(defmethod destructure-binding :default
  [ddef]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (:type ddef)})))

(defn ^:private fn-arity-with-destructuring
  "Take a function arity definition (an argument vector and 0 or more body
  expressions) whose argument vector may or may not require destructuring
  and return a function arity definition which uses only bare symbols and
  wraps the original definition in a let binding which performs the
  destructuring steps.

  As an example, for sequential destructuring like:

    (fn [[f & r]]
      {:first f
       :rest  r})

  This function would emit a list of:

    [vec_arg_3432]
    (let* [f (get vec_arg_3432 0)
           r (nthnext vec_arg_3432 1)]
      {:first f
       :rest  r})"
  [body]
  (let [args (first body)
        body (rest body)

        arg-groups (split-with (partial not= '&) args)
        args       (first arg-groups)
        rest-args  (second arg-groups)
        rest-defs  (map destructure-def rest-args)

        rest-binding (concat
                      (let [rest-arg (second rest-defs)]
                        (when (= :map (:type rest-arg))
                          `[~(:name rest-arg) (apply hash-map ~(:name rest-arg))]))
                      (->> rest-defs
                           (filter #(not= :symbol (:type %)))
                           (mapcat destructure-binding)))

        defs     (map destructure-def args)
        arg-vec  (vec (concat
                       (map :name defs)
                       (map :name rest-defs)))
        bindings (->> defs
                      (filter #(not= :symbol (:type %)))
                      (mapcat destructure-binding)
                      (concat rest-binding))
        new-body (if (seq bindings)
                   [`(let* [~@bindings]
                       ~@body)]
                   body)]
    (apply list arg-vec new-body)))

(defmacro ^:no-warn-on-redef fn
  "Return an anonymous (but possibly named) function.

  Function argument vectors support sequential and associative destructuring."
  [& body]
  (let [name    (when (symbol? (first body))
                  (first body))
        body    (cond-> body name rest)
        arities (cond
                  (vector? (first body))
                  (fn-arity-with-destructuring body)

                  (seq? (first body))
                  (apply list (map fn-arity-with-destructuring body))

                  :else
                  body)]
    (as-> arities $
      (cond->> $ name (cons name))
      (cons 'fn* $)
      (cond-> $
        (meta &form) (with-meta (meta &form))))))

(defn destructure
  "Take a [binding expr] pair (as from a let block) and produce all of the
  replacement bindings for the binding which perform destructuring on the
  initial expression.

  As an example, for sequential destructuring like:

    [f & r :as v] [1 2 3 4]

  This function would emit a list of bindings which can be inserted directly
  into a let* binding to perform destructuring:

     (v [1 2 3 4]
      f (nth v 0)
      r (nthnext v 1))"
  [[binding expr]]
  (let [ddef      (destructure-def binding)
        orig-name (:name ddef)
        bindings  (if (= :symbol (:type ddef))
                    []
                    (destructure-binding ddef))]
    (apply list orig-name expr bindings)))

(defmacro ^:no-warn-on-redef let
  "Let bindings with destructuring support."
  [bindings & body]
  `(let* [~@(->> (partition 2 bindings)
                 (mapcat destructure))]
     ~@body))

(defn ^:private loop-with-destructuring
  "Take a loop definition (an binding vector and 0 or more body
  expressions) whose binding vector may or may not require destructuring
  and return a loop binding vector and loop body."
  [bindings body]
  (let [defs           (->> (take-nth 2 bindings)
                            (map destructure-def))
        binding-vec    (vec (mapcat (fn [ddef binding]
                                      [(:name ddef) binding])
                                    defs
                                    (take-nth 2 (drop 1 bindings))))
        inner-bindings (->> defs
                            (filter #(not= :symbol (:type %)))
                            (mapcat destructure-binding))
        new-body       (if (seq inner-bindings)
                         [`(let* [~@inner-bindings]
                             ~@body)]
                         body)]
    [binding-vec new-body]))

(defmacro ^:no-warn-on-redef loop
  "Loop bindings with destructuring support."
  [bindings & body]
  (let [[bindings body] (loop-with-destructuring bindings body)]
    `(loop* ~bindings
        ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Interop Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

(defn lisp->py
  "Recursively convert Basilisp data structures into Python data structures.

  Callers can specify a keyword argument :keyword-fn, which names a function
  which is called for each keyword value in the input structure to return a
  new value. By default :keyword-fn is the function `name`."
  ([o]
   (basilisp.lang.runtime/to-py o))
  ([o & {:keys [keyword-fn] :or {keyword-fn name}}]
   (basilisp.lang.runtime/to-py o keyword-fn)))

(defn py->lisp
  "Recursively convert Python data structures into Basilisp data structures.

  Callers can specify a keyword argument :keywordize-keys, which defaults to
  true. If :keywordize-keys is true, then all string keys in Python dicts will
  be converted into keywords in the final return value."
  ([o]
   (basilisp.lang.runtime/to-lisp o))
  ([o & {:keys [keywordize-keys] :or {keywordize-keys true}}]
   (basilisp.lang.runtime/to-lisp o keywordize-keys)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Data Types & Protocols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(import* abc)

(defmulti munge
  "Munge the input value into a Python-safe string. Converts keywords and
  symbols into strings as by `name` prior to munging. Returns a string."
  python/type)

(defmethod munge basilisp.lang.keyword/Keyword
  [kw]
  (basilisp.lang.util/munge (name kw)))

(defmethod munge basilisp.lang.symbol/Symbol
  [s]
  (basilisp.lang.util/munge (name s)))

(defmethod munge python/str
  [s]
  (basilisp.lang.util/munge s))

(def namespace-munge
  "Convert a Basilisp namespace name to a valid Python name."
  munge)

(defn gen-interface
  "Generate and return a new Python interface (abstract base clase).

  Callers should use `definterface` to generate new interfaces."
  [interface-name methods]
  (let [methods (reduce (fn [m [method-name args docstring]]
                          (let [method-args (->> (concat ['^:no-warn-when-unused self] args)
                                                 (apply vector))
                                method      (->> (list 'fn* method-name method-args)
                                                 (eval)
                                                 (abc/abstractmethod))]
                            (when docstring
                              (set! (.- method __doc__) docstring))
                            (assoc m (munge method-name) method)))
                        {}
                        methods)]
    (python/type interface-name
                   #py (abc/ABC)
                   (lisp->py methods))))

;; The behavior described below where `definterface` forms are not permitted
;; to be used in `deftype` and `defrecord` forms when they are not top-level
;; is a bug, documented in the following issue:
;;
;; https://github.com/chrisrink10/basilisp/issues/376

(defmacro definterface
  "Define a new Python interface (abstract base clase) with the given name
  and method signatures.

  Method signatures are in the form (method-name [arg1 arg2 ...]).

  Interface objects cannot be directly instantiated. Instead, you must create
  a concrete implementation of an interface (perhaps via deftype) and supply
  implementations for all of the abstract methods.

  The generated interface derives from Python's `abc.ABC` and all method
  definitions are declared as `abc.abstractmethod`s and thus must be implemented
  by a concrete type.

  The generated interface will be immediately available after this form has
  been evaluated _if it is evaluated as a top-level form_. If this form appears
  within a function and is referred to later in a `deftype` or `defrecord` form,
  a compilation error will occur since the compiler will be unable to evaluate
  whether the generated value refers to an abstract class."
  [interface-name & methods]
  (let [name-str    (name interface-name)
        method-sigs (map #(list 'quote %) methods)]
    `(def ~interface-name
       (gen-interface ~name-str [~@method-sigs]))))

(defn ^:private collect-methods
  "Collect method and interface declarations for `deftype` and `defrecord`
  into a map containing `:interfaces` and `:methods` keys."
  [method-impls]
  (group-by (fn [v]
              (cond
                (symbol? v) :interfaces
                (seq v)     :methods
                :else       (throw
                             (ex-info "Expected method definition or interface name"
                                      {:value v :type (type v)}))))
            method-impls))

(defmacro deftype
  "Define a new Python concrete type which can implement 0 or more Python
  interfaces or Basilisp protocols.

  The new type will have fields matching the names in `fields`. Fields may
  be referred to unqualified in the bodies of implemented methods. By default
  the fields of this type are immutable. Attempting to set non-mutable fields
  from a method body will result in a compiler error.

  Fields may be made mutable by annotating their definition with `:mutable`
  metadata. Mutable fields may be set within method bodies using the `set!`
  special form. It is not advised to use mutable fields unless you are sure
  you know what you are doing. As a consequence of Python's lax policy towards
  immutability, types with even one mutable field may be mutated by outside
  callers using `set!`, so bear that in mind when choosing mutability.

  Interface or protocol implementations are declared as the name of the
  interface or protocol as a symbol, followed by 1 or more method
  definitions for that interface. Types are not required to declare
  any interface implementations. Types which do declare interface
  implementations are required to implement all interface methods. Failing
  to implement all interface methods is a compile time error. Types
  implementing `object` are not required to implement all `object` methods.

  Method declarations should appear as:

    (method-name [arg1 arg2 ...] & body)

  Unlike in Clojure, interface and protocol methods are permitted to
  include variadic arguments.

  Type objects are created with sensible `object` defaults as by `attrs`.
  New types may override `object` defaults. An `__init__` function is
  automatically created which takes positional arguments matching the
  order of definition in `fields`. Additionally, given a name `NewType`,
  a factory function will be created `->NewType` which can be used to
  generate new instances of the type.

  Methods must supply a `this` or `self` parameter. `recur` special forms
  used in the body of a method should not include that parameter, as it
  will be supplied automatically."
  [type-name fields & method-impls]
  (let [ctor-name (with-meta
                    (symbol (str "->" (name type-name)))
                    (meta type-name))

        {:keys [interfaces methods]} (collect-methods method-impls)]
    `(do
       (deftype* ~type-name ~fields
         :implements [~@interfaces
                      ~'basilisp.lang.interfaces/IType
                      ~'python/object]
         ~@methods)
       (def ~ctor-name ~type-name)
       ~type-name)))

(import* attr)

(defn record?
  "Return true if v is a record type."
  [v]
  (instance? basilisp.lang.interfaces/IRecord v))

(defmulti ^:private evolve
  (fn [v & _]
    (cond
      (record? v) :record
      (map? v)    :map)))

(defmethod evolve :map
  [m & kwargs]
  (apply assoc m kwargs))

(defmethod evolve :record
  [rec & kwargs]
  (->> (apply hash-map kwargs)
       (apply-kw attr/evolve rec)))

(defn ^:private validate-record-fields
  "Validate that record fields do not contain any reserved entries,
  are not declared as mutable, and do not declare any default values."
  [fields field-kws]
  (when (some #(#{:meta :_recmap} %) field-kws)
    (throw
     (ex-info "Reserved fields cannot be used for Record field names"
              {:fields (.intersection #{:meta :_recmap} (set field-kws))})))

  (when (some #(:mutable (meta %)) fields)
    (throw
     (ex-info "Mutable fields not permitted in Record types"
              {:fields (filter #(:mutable (meta %)) fields)})))

  (when (some #(contains? (meta %) :default) fields)
    (throw
     (ex-info "Record fields may not specify defaults"
              {:fields (filter #(contains? (meta %) :default) fields)}))))

(defn ^:private validate-record-methods
  "Validate that record methods are not declared as class methods,
  properties, or static methods."
  [methods]
  (when (->> methods
             (mapcat (fn [method]
                       [(meta method) (meta (first method))]))
             (some #(or (:classmethod %) (:property %) (:staticmethod %))))
    (throw
     (ex-info "Record methods may not be class methods, properties, or static methods"
              {:methods methods}))))

(defmacro defrecord
  "Define a new Basilisp record.

  The new record will have fields matching the names in `fields`. Fields may
  be referred to unqualified in the bodies of implemented methods.

  Interface or protocol implementations are declared as the name of the
  interface or protocol as a symbol, followed by 1 or more method
  definitions for that interface. Records are not required to declare
  any interface implementations. Records which do declare interface
  implementations are required to implement all interface methods. Failing
  to implement all interface methods is a compile time error. Records
  implementing `object` are not required to implement all `object` methods.

  Method declarations should appear as:

    (method-name [arg1 arg2 ...] & body)

  Records objects are created with sensible `object` defaults as by `attrs`.
  New records may override `object` defaults. An `__init__` function is
  automatically created which takes positional arguments matching the
  order of definition in `fields`. Additionally, given a name `NewRecord`,
  a factory function will be created `->NewRecord` which can be used to
  generate new instances of the record.

  Methods must supply a `this` or `self` parameter. `recur` special forms
  used in the body of a method should not include that parameter, as it
  will be supplied automatically."
  [type-name fields & method-impls]
  (let [ctor-name     (with-meta
                        (symbol (str "->" (name type-name)))
                        (meta type-name))
        map-ctor      (with-meta
                        (symbol (str "map->" (name type-name)))
                        (meta type-name))

        record-fields (vec (concat fields
                                   ['^{:default nil} meta
                                    '^{:default {}} _recmap]))
        field-kws     (->> fields (map (comp keyword name)))
        field-kw-set  (set field-kws)

        {:keys [interfaces methods]} (collect-methods method-impls)

        interfaces (concat interfaces
                           '[basilisp.lang.interfaces/IPersistentMap
                             basilisp.lang.interfaces/IMeta
                             basilisp.lang.interfaces/IRecord
                             python/object])

        ;; We can use these gensyms repeatedly and interpolate them in
        ;; multiple layers of syntax quoting, unlike gensyms using # syntax.
        this-gs  (gensym "this")
        other-gs (gensym "other")
        map-gs   (gensym "m")
        key-gs   (gensym "k")]

    (validate-record-fields fields field-kws)
    (validate-record-methods methods)

    `(do
       (deftype* ~type-name ~record-fields
         :implements [~@interfaces]

         ;; IPersistentMap
         (~'assoc [~this-gs ~'& args#]
          (let [{fields# :fields map# :map} (->> (partition 2 args#)
                                                 (group-by (fn [[k#]]
                                                             (if (contains? ~field-kw-set k#)
                                                               :fields
                                                               :map))))

                new-recmap# (when (seq map#)
                              ;; Python attrs does not allow the underscore prefixed
                              ;; field name in the constructor
                              ["recmap" (->> (mapcat identity map#)
                                             (apply assoc ~'_recmap))])]
            (->> fields#
                 (map (fn [[k# v#]] [(name k#) v#]))
                 (mapcat identity)
                 (concat new-recmap#)
                 (apply evolve ~this-gs))))
         (~'cons [~this-gs ~'& elems#]
          (loop [[f# ~'& r#] elems#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (map? f#)
              (recur r#
                     (->> (seq f#)
                          (mapcat identity)
                          (apply assoc new-rec#)))

              (map-entry? f#)
              (recur r# (assoc new-rec# (key f#) (val f#)))

              (vector? f#)
              (recur r# (apply assoc new-rec# f#))

              (py-dict? f#)
              (recur r#
                     (->> (seq (.items f#))
                          (map (fn [[k v]] (map-entry k v)))
                          (apply conj new-rec#)))

              :else
              (throw
               (ex-info "Argument to record conj must be another Map or castable to MapEntry"
                        {:value f#
                         :type  (python/type f#)})))))
         (~'empty [~this-gs]
          (throw
           (python/TypeError
            ~(str "Cannot create empty " type-name))))
         (~'seq [~this-gs]
          (concat
           [~@(map (fn [field]
                     (map-entry (keyword (name field)) field))
                   fields)]
           (seq ~'_recmap)))
         (~'dissoc [~this-gs ~'& ks#]
          (loop [[f# ~'& r#] ks#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (contains? ~field-kw-set f#)
              (recur r#
                     (->> (seq new-rec#)
                          (filter (fn [[k#]]
                                    (not= k# f#)))
                          (mapcat identity)
                          (apply hash-map)))

              (contains? (.- new-rec#  ~'_recmap) f#)
              (recur r#
                     (->> (dissoc (.- new-rec# ~'_recmap) f#)
                          (evolve new-rec# "recmap")))

              :else
              (recur r# new-rec#))))
         (~'contains [~this-gs ~key-gs]
          (or (~field-kw-set ~key-gs)
              (contains? ~'_recmap ~key-gs)))
         (~'entry [~this-gs ~key-gs]
          (cond
            (contains? ~field-kw-set ~key-gs)
            (map-entry ~key-gs (python/getattr ~this-gs (munge ~key-gs)))

            (contains? ~'_recmap ~key-gs)
            (map-entry ~key-gs (get ~'_recmap ~key-gs))))
         (~'val-at [~this-gs ~key-gs ~'& args#]
          (let [[default#] args#]
            (cond
              (contains? ~field-kw-set ~key-gs)
              (python/getattr ~this-gs (munge ~key-gs))

              (contains? ~'_recmap ~key-gs)
              (get ~'_recmap ~key-gs default#))))
         (~'__getitem__ [~this-gs ~key-gs]
          (. ~this-gs ~'entry ~key-gs))
         (~'__iter__ [~this-gs]
          (seq ~this-gs))
         (~'__len__ [~this-gs]
          (+ ~(count field-kw-set)
             (count ~'_recmap)))

         ;; IMeta
         (~'with-meta [~this-gs new-meta#]
          (->> (merge (or ~'meta {}) new-meta#)
               (evolve ~this-gs "meta")))

         ;; IRecord
         (~' ^:classmethod create [cls# ~map-gs]
          (cls#
           ~@(map (fn [field-kw]
                    `(get ~map-gs ~field-kw))
                  field-kws)
           nil
           (dissoc ~map-gs ~@field-kws)))
         (~'_record_lrepr [~this-gs py-kwargs#]
          (let [{print-meta :print_meta} (py->lisp py-kwargs#)

                ns-name   (name *ns*)
                qual-name (.- ~type-name ~'__qualname__)]
            (cond->> (->> (mapcat identity ~this-gs)
                          (apply hash-map)
                          (repr)
                          (str "#" ns-name "." qual-name))
              print-meta (str "^" (repr (meta ~this-gs)) " "))))

         ;; object
         (~'__eq__ [~this-gs ~other-gs]
          (or (identical? ~this-gs ~other-gs)
              (and (instance? (python/type ~this-gs) ~other-gs)
                   (= [~@fields
                       ~'_recmap]
                      [~@(map (fn [field]
                                `(.- ~other-gs ~field))
                              fields)
                       (.- ~other-gs ~'_recmap)]))))
         (~'__hash__ [~this-gs]
          (hash [~@fields ~'_recmap]))

         ~@methods)

       (defn ~ctor-name
         ~(str
           "Create a new instance of the record " type-name ".")
         ~fields
         (~type-name ~@fields nil {}))

       (defn ~map-ctor
         ~(str
           "Create a new instance of the record " type-name " from a "
           "map whose keys correspond to the fields of " type-name ".")
         [m#]
         ((.- ~type-name ~'create) m#))

       ~type-name)))

