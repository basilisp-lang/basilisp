(in-ns 'basilisp.core)

(import* abc
         atexit
         collections
         datetime
         decimal
         fractions
         importlib.util
         inspect
         math
         multiprocessing
         os
         pathlib
         [queue :as py-queue]
         random
         re
         threading
         [time :as py-time]
         uuid)

(def ^{:doc      "Create a list from the arguments."
       :arglists '([& args])}
  list
  (fn* list [& args] (if args args '())))

(def
  ^{:doc      "If ``seq`` is a Seq, return the first element from ``seq``. If ``seq``
               is ``nil``\\, return ``nil``\\. Otherwise, coerces ``seq`` to a Seq and
               returns the first element."
    :arglists '([seq])}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc      "If ``seq`` is a Seq, return the elements after the first in ``seq``\\.
               If ``seq`` is ``nil``\\, returns an empty seq. Otherwise, coerces ``seq``
               to a seq and returns the rest."
    :arglists '([seq])}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc      "Calls :lpy:fn:`rest` on ``o``. If ``o`` returns an empty sequence or
               ``nil``, returns ``nil``\\. Otherwise, returns the elements after the
               first in ``o``\\."
    :arglists '([seq])}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc      "Returns the second element in a Seq."
    :arglists '([seq])}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc      "Returns the first element in the first element of a Seq."
    :arglists '([seq])}
  ffirst
  (fn* ffirst [seq] (first (first seq))))

(def
  ^{:doc      "Creates a new sequence where ``o`` is the first element and ``seq`` is
               the rest. If ``seq`` is nil, return a list containing ``o``\\. If ``seq``
               is not a Seq, attempt to coerce it to a Seq and then cons ``o`` onto the
               resulting sequence."
    :arglists '([o seq])}
  cons
  (fn* cons [o seq] (basilisp.lang.runtime/cons o seq)))

(def ^{:doc      "Return the metadata from ``o``\\, or ``nil`` if there is no metadata."
       :arglists '([o])}
  meta
  (fn* meta [o]
       (if (python/hasattr o "meta")
         (.-meta o)
         nil)))

(def ^{:doc      "Return an object of the same type and representing the same value as
                  ``o`` with ``meta`` as its metadata. Of Basilisp's builtin types,
                  only those implementing the interface IWithMeta support
                  ``with-meta``."
       :arglists '([o meta])}
  with-meta
  (fn* with-meta [o meta]
       (if meta
         (.with-meta o meta)
         o)))

(def ^:macro ^:redef let
  (fn* let [&env &form & decl]
       (cons 'let* decl)))

(def ^:macro ^:redef loop
  (fn* loop [&env &form & decl]
       (cons 'loop* decl)))

(def ^:macro ^:redef fn
  (fn* fn [&env &form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def ^{:doc      "Returns its argument unmodified."
       :arglists '([v])}
  identity
  (fn identity [v] v))

(def
  ^{:doc      "Return ``true`` if ``obj`` is an instance of ``class``\\."
    :arglists '([class obj])}
  instance?
  (fn instance? [class obj]
    (python/isinstance obj class)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a boolean."
    :arglists '([o])}
  boolean?
  (fn boolean? [o]
    (instance? python/bool o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a float."
    :arglists '([o])}
  float?
  (fn float? [o]
    (instance? python/float o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is an integer."
    :arglists '([o])}
  integer?
  (fn integer? [o]
    (instance? python/int o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a string."
    :arglists '([o])}
  string?
  (fn string? [o]
    (instance? python/str o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a symbol."
    :arglists '([o])}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a keyword."
    :arglists '([o])}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a list."
    :arglists '([o])}
  list?
  (fn list? [o]
    (instance? basilisp.lang.interfaces/IPersistentList o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a map."
    :arglists '([o])}
  map?
  (fn map? [o]
    (instance? basilisp.lang.interfaces/IPersistentMap o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a set."
    :arglists '([o])}
  set?
  (fn set? [o]
    (instance? basilisp.lang.interfaces/IPersistentSet o)))

(def
  ^{:doc      "Return ``true`` if ``o`` is a vector."
    :arglists '([o])}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.interfaces/IPersistentVector o)))

(def
  ^{:doc      "Return ``true`` if ``o`` implements Seq."
    :arglists '([o])}
  seq?
  (fn seq? [o]
    (instance? basilisp.lang.interfaces/ISeq o)))

(def ^{:doc      "Coerce the argument ``o`` to a Seq. If ``o`` is ``nil``\\, return
                  ``nil``\\."
       :arglists '([o])}
  seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def ^{:doc      "Apply function ``f`` to the arguments provided.

                  The last argument must always be coercible to a Seq. Intermediate
                  arguments are not modified."
       :arglists '([f & args])}
  apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def ^{:doc      "Return an object of the same type and representing the same value as
                  ``o`` (as by :lpy:fn:`with-meta`) with the new object's metadata set
                  to the value of ``(apply f (meta o) & args)``\\."
       :arglists '([o f & args])}
  vary-meta
  (fn* vary-meta [o f & args]
       (with-meta o (apply f (meta o) args))))

(def ^{:doc      "Concatenate the sequences given by ``seqs`` into a single Seq."
       :arglists '([& seqs])}
  concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def
  ^{:doc      "Create a hash map from pairs of input arguments."
    :arglists '([& kvs])}
  hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def
  ^{:doc      "Create a set from the input arguments."
    :arglists '([& members])}
  hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def
  ^{:doc      "Return a set with the contents of ``coll``\\."
    :arglists '([coll])}
  set
  (fn set
    [coll]
    (^:allow-builtins basilisp.lang.runtime/to-set coll)))

(def
  ^{:doc      "Create a vector from the input arguments."
    :arglists '([& elems])}
  vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def
  ^{:doc      "Return a vector with the contents of ``coll``\\."
    :arglists '([coll])}
  vec
  (fn vec
    [coll]
    (basilisp.lang.runtime/vector coll)))

;;;;;;;;;;;; full support for syntax quote begins here ;;;;;;;;;;;;

(def
  ^{:doc      "Return the length of ``coll`` as by Python's ``len`` builtin, or 0 if
               ``coll`` is nil. If the collection does not respond to ``__len__``\\,
               then count it manually."
    :arglists '([coll])
    :inline   true}
  count
  (fn ^:inline count [coll]
    (basilisp.lang.runtime/count coll)))

(def
  ^{:doc      "Returns a ``basilisp.lang.exception/ExceptionInfo`` instance with
               the given message and data."
    :arglists '([msg data])
    :inline   true}
  ex-info
  (fn ^:inline ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:doc      "Associate keys to values in associative data structure ``m``\\. If ``m``
               is ``nil``\\, returns a new map with key-values ``kvs``\\."
    :arglists '([m k v] [m k v & kvs])}
  assoc
  (fn assoc
    ([m k v]
     (basilisp.lang.runtime/assoc m k v))
    ([m k v & kvs]
     (apply basilisp.lang.runtime/assoc m k v kvs))))

(def
  ^{:doc      "Conjoin ``xs`` to collection ``coll``. New elements may be added in
               different positions depending on the type of ``coll``\\. ``conj`` returns
               the same type as ``coll``\\. If ``coll`` is ``nil``\\, return a list with
               ``xs`` conjoined."
    :arglists '([] [coll] [coll x] [coll x & xs])}
  conj
  (fn conj
    ([] [])
    ([coll] coll)
    ([coll x]
     (basilisp.lang.runtime/conj coll x))
    ([coll x & xs]
     (apply basilisp.lang.runtime/conj coll x xs))))

;; Define inline functions for earlier core functions now that we have all the
;; functionality required to do so.

(.alter-meta #'first assoc :inline (fn [seq] `(basilisp.lang.runtime/first ~seq)))
(.alter-meta #'rest assoc :inline (fn [seq] `(basilisp.lang.runtime/rest ~seq)))
(.alter-meta #'next assoc :inline (fn [seq] `(basilisp.lang.runtime/next ~seq)))
(.alter-meta #'second assoc :inline (fn [seq] `(first (rest ~seq))))
(.alter-meta #'ffirst assoc :inline (fn [seq] `(first (first ~seq))))
(.alter-meta #'identity assoc :inline (fn [o] `~o))
(.alter-meta #'instance? assoc :inline (fn [class obj] `(python/isinstance ~obj ~class)))
(.alter-meta #'boolean? assoc :inline (fn [o] `(instance? python/bool ~o)))
(.alter-meta #'float? assoc :inline (fn [o] `(instance? python/float ~o)))
(.alter-meta #'integer? assoc :inline (fn [o] `(instance? python/int ~o)))
(.alter-meta #'string? assoc :inline (fn [o] `(instance? python/str ~o)))
(.alter-meta #'symbol? assoc :inline (fn [o] `(instance? basilisp.lang.symbol/Symbol ~o)))
(.alter-meta #'keyword? assoc :inline (fn [o] `(instance? basilisp.lang.keyword/Keyword ~o)))
(.alter-meta #'list? assoc :inline (fn [o] `(instance? basilisp.lang.interfaces/IPersistentList ~o)))
(.alter-meta #'map? assoc :inline (fn [o] `(instance? basilisp.lang.interfaces/IPersistentMap ~o)))
(.alter-meta #'set? assoc :inline (fn [o] `(instance? basilisp.lang.interfaces/IPersistentSet ~o)))
(.alter-meta #'vector? assoc :inline (fn [o] `(instance? basilisp.lang.interfaces/IPersistentVector ~o)))
(.alter-meta #'seq? assoc :inline (fn [o] `(instance? basilisp.lang.interfaces/ISeq ~o)))
(.alter-meta #'seq assoc :inline (fn [o] `(basilisp.lang.runtime/to-seq ~o)))
(.alter-meta #'set assoc :inline (fn [coll] `(basilisp.lang.runtime/to-set ~coll)))
(.alter-meta #'vec assoc :inline (fn [coll] `(basilisp.lang.runtime/vector ~coll)))

(def
  ^{:macro    true
    :doc      "Define a new function with an optional docstring.

               The function will be interned in the current Namespace as a Var using
               the given ``name``\\.

               After the name, an optional mapping of meta attributes may be provided.
               Any metadata values given will be attached to the metadata of the
               interned Var. A few special meta keys change how ``defn`` emits the
               final Var and function:

                - ``:decorators`` is an optional vector of functions which will wrap
                  the final function emitted by ``defn``. Like standard Python
                  decorators and the ``comp`` function, decorators are applied to the
                  generated function from right to left.

               Specify an optional docstring after the metadata map to provide callers
               with additional details about your function, its arguments, and its
               return value. If a docstring is provided, it will be attached to the
               interned Var metadata under the `:doc` key.

               Functions may be defined with 1 or more arities. Functions of a single
               arity may be defined with a single vector of 0 or more arguments after
               the optional metadata map. Any forms appearing after the argument
               vector will be part of the function body. It is legal to define a
               function with no body. In this case, your function will always return
               ``nil``\\.

               Functions with multiple arities are defined as a series of lists after
               the optional metadata map. Each list must contain an argument vector
               and 0 or more body forms. No arity may share the same number of fixed
               (non-variadic) arguments. There may be at most one variadic arity
               defined per function and the number of fixed arguments to that arity
               must be greater than or equal than the number of fixed arguments of all
               other arities."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defn
  (fn defn [&env &form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (python/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta  (if (map? (first body))
                   (first body)
                   nil)
          fname  (if fmeta
                   (vary-meta name conj fmeta)
                   name)
          fname  (if doc
                   (vary-meta fname assoc :doc doc)
                   fname)
          body   (if fmeta
                   (rest body)
                   body)
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       (apply list sigs)))
                   (list (first body)))
          fname  (vary-meta fname assoc :arglists (list 'quote fsigs))
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))

          decorators (:decorators fmeta)
          fn-body    (if decorators
                       (loop [wrappers (seq (python/reversed decorators))
                              final    `(fn ~fname ~@body)]
                         (if (seq wrappers)
                           (recur (rest wrappers)
                                  `(~(first wrappers) ~final))
                           final))
                       `(fn ~fname ~@body))]
      `(def ~fname ~fn-body))))

(defn nth
  "Returns the ``i`` th element of ``coll`` (0-indexed), if it exists or ``nil``
  otherwise. If ``i`` is out of bounds, throws an ``IndexError`` unless ``notfound``
  is specified.

  ``coll`` may be any sequential collection type (such as a list or vector), string,
  or ``nil``\\. If ``coll`` is not one of the supported types, a ``TypeError`` will be
  thrown."
  ([coll i]
   (basilisp.lang.runtime/nth coll i))
  ([coll i notfound]
   (basilisp.lang.runtime/nth coll i notfound)))

(defn ^:inline nthnext
  "Returns the nth next sequence of ``coll``\\.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn ^:inline nthrest
  "Returns the nth rest sequence of ``coll``\\, or ``coll`` if ``i`` is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn ^:inline nfirst
  "Return the result of calling ``(next (first v))``\\."
  [v]
  (next (first v)))

(defn ^:inline fnext
  "Return the result of calling ``(first (next v))``\\."
  [v]
  (first (next v)))

(defn ^:inline nnext
  "Return the result of calling ``(next (next v))``\\."
  [v]
  (next (next v)))

(defn last
  "Return the last item in a seq, or ``nil`` if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(defn ^:inline nil?
  "Return ``true`` if ``x`` is ``nil``\\, otherwise ``false``\\."
  [x]
  (operator/is- x nil))

(defn str
  "Create a string representation of ``o``.

  Return the empty string if ``o`` is nil."
  ([] "")
  ([o] (if (nil? o) "" (basilisp.lang.runtime/lstr o)))
  ([o & args]
   (let [coerce (fn [in out]
                  (let [item (first in)
                        repr (if (nil? item) "" (basilisp.lang.runtime/lstr item))]
                    (if (seq (rest in))
                      (recur (rest in)
                             (conj out repr))
                      (conj out repr))))
         strs   (coerce (conj args o) [])]
     (.join "" strs))))

(defn queue
  "Return a new persistent queue."
  ([]
   basilisp.lang.queue/EMPTY)
  ([coll]
   (basilisp.lang.queue/queue coll)))

(defn symbol
  "Create a new symbol with ``name`` and optional namespace ``ns``.

  ``name`` may be keyword, symbol, string, or Var. If ``name`` is a keyword or symbol
  with a namespace, the namespace will be included in the resulting value. If ``name``
  is a Var, the Var's namespace will always be the namespace of the resulting value. If
  ``name`` is a string with at least one '/', the string will be split on the first '/'
  character with the first segment being used as ``ns`` and the second as ``name``.

  If ``ns`` is not ``nil``, then both ``name`` and ``ns`` must be strings."
  ([name]
   (basilisp.lang.runtime/symbol-from-name name))
  ([ns name]
   (basilisp.lang.runtime/symbol name ns)))

(defn keyword
  "Create a new keyword with ``name`` and optional namespace ``ns``\\. Keywords will
  have the colon prefix added automatically, so it should not be provided.

  ``name`` may be keyword, symbol, or string. If ``name`` is a keyword or symbol with a
  namespace, the namespace will be included in the resulting value. If ``name`` is a
  string with at least one '/', the string will be split on the first '/' character
  with the first segment being used as ``ns`` and the second as ``name``.

  If ``ns`` is not ``nil``, then both ``name`` and ``ns`` must be strings."
  ([name]
   (basilisp.lang.runtime/keyword-from-name name))
  ([ns name]
   (basilisp.lang.runtime/keyword name ns)))

(defn find-keyword
  "Return the keyword named by ``name`` and optionally ``ns`` if it has already been
  interned.

  Return ``nil`` otherwise."
  ([name]
   (basilisp.lang.keyword/find-keyword name))
  ([ns name]
   (basilisp.lang.keyword/find-keyword name ns)))

(defn name
  "Return the name of a string, symbol, or keyword."
  [v]
  (if (string? v)
    v
    (.-name v)))

(defn ^:inline reader-conditional
  "Construct a data representation of a :ref:`reader conditional <reader_conditionals>`.

  The form must contain balanced key-value pairs."
  [form is-splicing?]
  (basilisp.lang.reader/ReaderConditional form is-splicing?))

(defn ^:inline reader-conditional?
  "Return true if the value is the data representation of a :ref:`reader conditional <reader_conditionals>`."
  [o]
  (instance? basilisp.lang.reader/ReaderConditional o))

(defn ^:inline tagged-literal
  "Construct a data representation of a tagged literal from a tag symbol and a form."
  [tag form]
  (basilisp.lang.tagged/tagged-literal tag form))

(defn ^:inline tagged-literal?
  "Return true if the value is the data representation of a tagged literal."
  [o]
  (instance? basilisp.lang.tagged/TaggedLiteral o))

(defn ^:inline namespace
  "Return the namespace of a symbol or keyword, or ``nil`` if no namespace."
  [v]
  (.-ns v))

(def
  ^{:macro    true
    :doc      "Define a new macro function. The arguments and syntax of ``defmacro``
               are identical to that of :lpy:fn:`defn`.

               When the compiler encounters a new macro function invocation, it
               immediately invokes that function during compilation and substitutes
               the function invocation with the return value of the called macro.
               Macros must return valid syntax at the point they are invoked,
               otherwise the compiler will throw an exception and compilation
               will halt.

               Macros created by ``defmacro`` have access to two implicit arguments
               whose names must not appear in your argument list:

                - ``&env`` is a map of all symbol bindings available to the compiler
                  at the point the macro is invoked.
                - ``&form`` is the original form invoking the macro. This is often
                  useful for reading and copying metadata attached to the original
                  form."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defmacro
  (fn defmacro [&env &form name & body]
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta  (if (map? (first body))
                   (first body)
                   nil)
          body   (if fmeta
                   (rest body)
                   body)
          fname  (if doc
                   (vary-meta name assoc :doc doc :macro true)
                   (vary-meta name assoc :macro true))
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       `(quote ~(apply list sigs))))
                   `(quote ~(list (first body))))
          fname  (vary-meta fname assoc :arglists fsigs)

          add-implicit-args (fn [body]
                              (cons
                               (if (vector? (first body))
                                 (apply vector
                                        (cons '&env
                                              (cons '&form
                                                    (first body))))
                                 (throw
                                  (ex-info "Expected an argument vector"
                                           {:found (first body)})))
                               (rest body)))

          add-args-for-each (fn [in out]
                              (if (seq (rest in))
                                (recur (rest in)
                                       (conj out (add-implicit-args (first in))))
                                (conj out (add-implicit-args (first in)))))

          body (if multi?
                 (add-args-for-each body [])
                 (add-implicit-args body))]
      `(defn ~fname
         ~@body))))

(defmacro defasync
  "Define a new asynchronous function as by ``defn``.

  Asynchronous functions are compiled as Python ``async def`` s."
  [name & body]
  `(defn ~(vary-meta name assoc :async true)
     ~@body))

(defmacro defn-
  "Define a new private function as by ``defn``\\.

  Private functions are ``def`` 'ed with the ``:private`` metadata, which makes them
  ineligible for access outside the namespace using ``require`` or ``refer``\\."
  [name & body]
  `(defn ~(vary-meta name assoc :private true)
     ~@body))

(defn ^:inline macroexpand-1
  "Macroexpand ``form`` one time. Returns the macroexpanded form. The return value
  may still represent a macro. Does not macroexpand child forms."
  [form]
  (basilisp.lang.compiler/macroexpand-1 form))

(defn ^:inline macroexpand
  "Repeatedly macroexpand ``form`` as by :lpy:fn:`macroexpand-1` until form no longer
  represents a macro. Returns the expanded form. Does not macroexpand child forms."
  [form]
  (basilisp.lang.compiler/macroexpand form))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Comparisons & Macros ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro if-not
  "Evaluate ``cond`` and if it is ``true``\\, return ``false-cond``. Otherwise return
  ``true-cond``\\."
  [cond true-cond false-cond]
  `(if ~cond
     ~false-cond
     ~true-cond))

(defmacro if-let
  "Evaluate the binding as with ``let``, binding the given name for use in the ``true``
  expression iff the binding expression is truthy . Otherwise, return the ``false``
  expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if expr#
       (let [~(first binding) expr#]
         ~true-cond)
       ~false-cond)))

(defmacro if-some
  "Evaluate the binding as with ``let``, binding the given name for use in the ``true``
  expression iff the binding expression is not ``nil``\\. Otherwise, return the
  ``false`` expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if (operator/is- expr# nil)
       ~false-cond
       (let [~(first binding) expr#]
         ~true-cond))))

(defmacro when
  "Evaluate ``cond`` and if it is truthy, execute body in an implicit ``do`` block."
  [cond & body]
  `(if ~cond
     (do ~@body)
     nil))

(defmacro when-let
  "Evaluate the binding as with ``let``\\, binding the given name for use in the
  ``true`` expression iff the binding expression is truthy. Return ``nil`` otherwise."
  [binding & body]
  `(if-let ~binding
     (do ~@body)
     nil))

(defmacro when-first
  "Evaluate the binding as with ``let``\\, binding the given name to the first value
  (as by :lpy:fn:`first`) in the binding expression iff the first value in the binding
  expression is not ``nil``\\. Return ``nil`` otherwise."
  [binding & body]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)
  `(let* [expr# (first ~(second binding))]
     (if expr#
       (let [~(first binding) expr#]
         ~@body)
       nil)))

(defmacro when-some
  "Evaluate the binding as with ``let``\\, binding the given name for use in the
  true expression iff the binding expression is not ``nil``\\. Return ``nil``
  otherwise."
  [binding & body]
  `(if-some ~binding
     (do ~@body)
     nil))

(defmacro when-not
  "Evaluate ``cond`` and if it is falsey, execute body in an implicit ``do`` block."
  [cond & body]
  `(if ~cond
     nil
     (do ~@body)))

(defmacro and
  "Evaluate the expressions from left to right. If all expressions are truthy, return
  the result of the final expression. Otherwise, returns the first falsey expression.
  Calling ``and`` with no arguments returns ``true``\\."
  ([] true)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          (and ~@(rest args))
          expr#))
     (first args))))

(defmacro or
  "Evaluate the expressions from left to right. Returns the first truthy expression.
  Otherwise, returns the final falsey expression. Calling ``or`` with no arguments
  returns ``nil``\\."
  ([] nil)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          expr#
          (or ~@(rest args))))
     (first args))))

(defmacro cond
  "Given groups of test/expression pairs, evaluate each test and, if ``true``\\, return
  the expression. Otherwise, continue through until reaching the final expression."
  [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw
             (ex-info "cond requires an even number of forms"
                      {:first (first clauses)})))
          (cons 'basilisp.core/cond (nthrest clauses 2)))))

(defmacro dotimes
  "Repeatedly execute ``body`` (likely for side effects) while the binding name is
  repeatedly rebound from 0 to the binding value, ``n``\\, minus 1. Returns ``nil``\\."
  [binding & body]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)
  (let [nm (first binding)]
    `(loop [~nm 0]
       (when (< ~nm ~(second binding))
         ~@body
         (recur (inc ~nm))))))

(defmacro while
  "Execute ``body`` repeatedly (likely for side effects) until ``cond`` returns
  ``false``\\. Return ``nil``\\."
  [cond & body]
  `(loop []
     (when ~cond
       ~@body
       (recur))))

(defn not
  "Return the logical negation of ``expr``\\."
  [expr]
  (if expr false true))

(defn apply-kw
  "Apply function ``f`` to the arguments provided, passing the keys from the final
  argument (which must be a map) as Python keyword arguments to ``f``\\. Keywords and
  symbol keys will be converted to strings and munged to be legal Python identifiers
  to avoid errors.

  The last argument must always be coercible to a Mapping. Intermediate arguments are
  not modified."
  [f & args]
  (basilisp.lang.runtime/apply-kw f args))

(defn ^:inline hash
  "Return the hash code for its argument."
  [x]
  (python/hash x))

(defn ^:inline identical?
  "Return ``true`` if ``x`` and ``y`` are the same object, otherwise ``false``\\."
  [x y]
  (operator/is_ x y))

(defn =
  "Return ``true`` if ``x`` and ``y`` are equal, otherwise ``false``\\.

  Number equality follows Python's ``=`` semantics whereby \"a
  comparison between numbers of different types behaves as though the
  exact values of those numbers were being compared\"."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (basilisp.lang.runtime/equals x (first args))
       (recur (first args) (rest args))
       false)
     (basilisp.lang.runtime/equals x (first args)))))

(defn not=
  "Return ``true`` if ``x`` and ``y`` are not equal, otherwise ``false``\\."
  [& args]
  (not (apply = args)))

(defn ==
  "Alias for lpy:fn:`=`."
  [& args]
  (apply = args))

(defn >
  "Return ``true`` if arguments are monotonically decreasing, otherwise ``false``\\."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/gt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/gt x (first args)))))

(defn >=
  "Return ``true`` if arguments are decreasing, otherwise ``false``\\."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/ge x (first args))
       (recur (first args) (rest args))
       false)
     (operator/ge x (first args)))))

(defn <
  "Return ``true`` if arguments are monotonically increasing, otherwise ``false``\\."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/lt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/lt x (first args)))))

(defn <=
  "Return ``true`` if arguments are increasing, otherwise ``false``\\."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/le x (first args))
       (recur (first args) (rest args))
       false)
     (operator/le x (first args)))))

(defn distinct?
  "Return ``true`` if no two arguments are equal."
  [& args]
  (= (count (vec args))
     (count (set args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Management Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn deref
  "Dereference a delay, atom, promise, future, volatile, or Var and returns its contents.

  If ``o`` is an object implementing :py:class:`basilisp.lang.interfaces.IBlockingDeref`
  (i.e. futures and promises) and ``timeout-ms`` and ``timeout-val`` are supplied, ``deref``
  will wait at most ``timeout-ms`` milliseconds, returning ``timeout-val`` if ``timeout-ms``
  milliseconds elapse and ``o`` has not returned."
  ([o]
   (basilisp.lang.runtime/deref o))
  ([o timeout-ms timeout-val]
   (basilisp.lang.runtime/deref o timeout-ms timeout-val)))

(defn ^:inline compare-and-set!
  "Atomically set the value of ``atom`` to ``new-val`` if and only if ``old-val`` is
  the current value of the atom."
  [atom old-val new-val]
  (.compare-and-set atom old-val new-val))

(defn reset!
  "Reset the value of an atom to ``v`` without regard to the previous value. Return the
  new value."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      v
      (recur atom v))))

(defn reset-vals!
  "Reset the value of an atom to ``v`` without regard to the previous value. Return a
  vector containing the new value and the old value in that order."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      [v current]
      (recur atom v))))

(defn swap!
  "Atomically swap the value of an atom to the return value of ``(apply f
  current-value args)``\\. The function ``f`` may be called multiple times while
  swapping, so should be free of side effects. Return the new value."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      new-val
      (recur atom f args))) )

(defn swap-vals!
  "Atomically swap the value of an atom to the return value of ``(apply f
  current-value args)``. The function ``f`` may be called multiple times while
  swapping, so should be free of side effects. Return a vector containing the new
  value and the old value in that order."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      [new-val current]
      (recur atom f args))))

(defn atom
  "Return an Atom containing ``v``\\. The value of an Atom at any point in time may be
  returned by :lpy:fn`deref` ing it. The value of an atom may be reset using
  :lpy:fn:`reset!` and may be swapped using :lpy:fn:`swap!`. All operations on an atom
  occur atomically."
  ([v]
   (basilisp.lang.atom/Atom v))
  ([v & kwargs]
   (apply-kw basilisp.lang.atom/Atom v (apply hash-map kwargs))))

(defn ^:inline realized?
  "Return ``true`` if the delay, future, lazy sequence, or promise has been realized."
  [o]
  (.-is-realized o))

(defmacro delay
  "Takes a body of expressions producing any value. Will not produce a value until
  :lpy:fn:`deref` ed. The result is cached and returned in future ``derefs``\\."
  [& body]
  (list 'basilisp.lang.delay/Delay
        (concat '(fn* []) body)))

(defn ^:inline delay?
  "Return ``true`` if ``x`` names a delay."
  [x]
  (instance? basilisp.lang.delay/Delay x))

(defn force
  "If ``x`` is a Delay, returned the possibly cached value of ``x``. Otherwise, return
  ``x``\\."
  [x]
  (if (delay? x)
    @x
    x))

(defn ^:inline promise
  "Return a promise object which can be set exactly once using :lpy:fn:`deliver` .
  Readers may block waiting for the value of the promise using ``@`` or
  :lpy:fn:`deref`. If the value has already been realized, then reading the value of
  the promise will not block. Readers may check if the promise has been delivered
  using :lpy:fn:`realized?`."
  []
  (basilisp.lang.promise/Promise))

(defn ^:inline deliver
  "Deliver the value ``v`` to the promise ``p``\\. If ``p`` already has a value, then a
  subsequent call to :lpy:fn:`deliver` for ``p`` will have no effect."
  [p v]
  (.deliver p v))

;;;;;;;;;;;;;
;; Futures ;;
;;;;;;;;;;;;;

(def ^:dynamic *executor-pool*
  (basilisp.lang.futures/ThreadPoolExecutor))

(atexit/register (.-shutdown *executor-pool*))

;; Declare `bound-fn*` now for use in `future-call`, though it is defined much later
;; with the rest of the Var binding functions and macros.
(def ^:redef bound-fn*)

(defn future-call
  "Call the no args function ``f`` in another thread. Returns a Future object. The
  value returned by ``f`` can be fetched using :lpy:fn:`deref` or ``@``\\, though doing
  so may block unless the ``deref`` with a timeout argument is used."
  ([f]
   (future-call f *executor-pool*))
  ([f pool]
   (.submit pool (bound-fn* f))))

(defmacro future
  "Execute the expressions of ``body`` in another thread. Returns a Future object.
  The value returned by the body can be fetched using :lpy:fn:`deref` or ``@``\\, though
  doing so may block unless the ``deref`` with a timeout argument is used."
  [& body]
  `(future-call
    (fn* []
         ~@body)))

(defn ^:inline future-cancel
  "Attempt to cancel the Future ``fut``\\. If the future can be cancelled, return
  ``true``\\. Otherwise, return ``false``\\."
  [fut]
  (.cancel fut))

(defn ^:inline future?
  "Return ``true`` if ``x`` is a future, ``false`` otherwise."
  [x]
  (instance? basilisp.lang.futures/Future x))

(defn ^:inline future-cancelled?
  "Return ``true`` if the Future ``fut`` has been cancelled, ``false`` otherwise."
  [fut]
  (.cancelled fut))

(defn ^:inline future-done?
  "Return ``true`` if the Future ``fut`` is done, ``false`` otherwise."
  [fut]
  (.done fut))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x y] (operator/add x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/add x y) (first args) (rest args))
     (operator/add x y))))

(defn -
  "Subtract the arguments. If one argument given, returns the negation of that
  argument."
  ([x] (operator/neg x))
  ([x y] (operator/sub x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/sub x y) (first args) (rest args))
     (operator/sub x y))))

(defn *
  "Multiply the arguments. If no arguments given, returns 1."
  ([] 1)
  ([x] x)
  ([x y] (operator/mul x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/mul x y) (first args) (rest args))
     (operator/mul x y))))

(defn /
  "Divide the arguments. If no arguments given, returns the inverse of the argument."
  ([x] (basilisp.lang.runtime/divide 1 x))
  ([x y] (basilisp.lang.runtime/divide x y))
  ([x y & args]
   (if (seq args)
     (recur (basilisp.lang.runtime/divide x y) (first args) (rest args))
     (basilisp.lang.runtime/divide x y))))

(defn ^:inline abs
  "Return the absolute value of ``x``\\."
  [x]
  (python/abs x))

(defn ^:inline mod
  "Returns the modulo of ``num`` and ``div``\\.

  It uses floored division for calculating the quotient."
  [num div]
  (operator/mod num div))

(defn ^:inline quot
  "Returns the quotient of ``num`` and ``div``\\.

  The division result is truncated."
  [num div]
  (int (/ num div)))

(defn ^:inline rem
  "Returns the remainder of ``num`` and ``div``\\.

  It uses truncated division for calculating the quotient."
  [num div]
  (- num (* div (int (/ num div)))))

(defn ^:inline inc
  "Increment the argument by 1."
  [x]
  (+ x 1))

(defn ^:inline dec
  "Decrement the argument by 1."
  [x]
  (- x 1))

(defn min
  "Return the minimum of the arguments."
  [& args]
  (python/min args))

(defn max
  "Return the maximum of the arguments."
  [& args]
  (python/max args))

(defn ^:inline numerator
  "Return the numerator of a Fraction."
  [frac]
  (.-numerator frac))

(defn ^:inline denominator
  "Return the denominator of a Fraction."
  [frac]
  (.-denominator frac))

(defn rationalize
  "Return the lowest ratio of ``num``.

  If ``num`` is an integer or simplifies to an integer, return that value."
  [num]
  (let [frac (fractions/Fraction num)]
    (if #?(:lpy312+ (.is-integer frac) :lpy311- (= (denominator frac) 1))
      (python/int frac)
      (let [ratio (.as-integer-ratio frac)]
        (fractions/Fraction (first ratio) (second ratio))))))

(defn ^:inline compare
  "Return either -1, 0, or 1 to indicate the relationship between ``x`` and ``y``\\.

  This is a 3-way comparator commonly used in Java-derived systems. Python does not
  typically use 3-way comparators, so this function convert's Python's ``__lt__`` and
  ``__gt__`` method returns into one of the 3-way comparator return values.

  Comparisons are generally only valid between homogeneous objects, with the exception
  of numbers which can be compared regardless of type. Most scalar value types
  (including ``nil``\\, booleans, numbers, strings, keywords, and symbols) are
  comparable. ``nil`` compares less than all values except itself. ``NaN`` compares
  equal to all numbers, including itself. Strings are compared lexicographically.
  Symbols and keywords are sorted first on their namespace, if they have one, and then
  on their name. Symbols and keywords with namespaces always sort ahead of those
  without. Symbols cannot be compared to keywords.

  Of the built in collection types, only vectors can be compared. Vectors are compared
  first by their length and then element-wise.

  Other collections such as maps, sequences, and sets cannot be compared.

  Python objects supporting ``__lt__`` and ``__gt__`` can generally be compared."
  [x y]
  (basilisp.lang.runtime/compare x y))

(defn sort
  "Return a sorted sequence of the elements from ``coll`` using the ``cmp`` comparator\\.

  The :lpy:fn:`compare` fn is used in if ``cmp`` is not provided."
  ([coll]
   (basilisp.lang.runtime/sort coll))
  ([cmp coll]
   (basilisp.lang.runtime/sort coll cmp)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Simple Predicates ;;
;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline any?
  "Return true for any ``x``\\."
  [_]
  true)

(defn ^:inline associative?
  "Return ``true`` if ``x`` implements :py:class:`basilisp.lang.interfaces.IAssociative`."
  [x]
  (instance? basilisp.lang.interfaces/IAssociative x))

(defn ^:inline bytes?
  "Return ``true`` if ``x`` is a byte array (the Python :external:py:class:`bytearray`
  type).

  Note that Python supplies byte string and byte array objects in its standard library.
  This function complies with Clojure's standard library in returning true iff ``x`` is
  a Python ``bytearray``\\. To check if an object is a Python
  :external:py:class:`bytes`\\, use :lpy:fn:`byte-string?` ."
  [x]
  (instance? python/bytearray x))

(defn ^:inline byte-string?
  "Return ``true`` if ``x`` is a byte string (the Python :external:py:class:`bytes` type).

  Note that Python supplies byte string and byte array objects in its standard library.
  To check if an object is a Python :external:py:class:`bytearray`, use ``bytes?``\\."
  [x]
  (instance? python/bytes x))

(defn char?
  "Return ``true`` if ``x`` is a string of length 1."
  [x]
  (and (instance? python/str x)
       (= (python/len x) 1)))

(defn ^:inline class?
  "Return ``true`` if ``x`` names a type."
  [x]
  (instance? python/type x))

(defn ^:inline coll?
  "Return ``true`` if ``x`` implements :py:class:`basilisp.lang.interfaces.IPersistentCollection`\\."
  [x]
  (instance? basilisp.lang.interfaces/IPersistentCollection x))

(defn ^:inline complex?
  "Return ``true`` if ``x`` is a complex number."
  [x]
  (instance? python/complex x))

(defn ^:inline counted?
  "Return ``true`` if ``x`` can be counted in constant time."
  [x]
  (instance? basilisp.lang.interfaces/ICounted x))

(defn ^:no-inline decimal?
  "Return ``true`` if ``x`` is a :external:py:class:`decimal.Decimal`\\."
  [x]
  (instance? decimal/Decimal x))

(defn ^:inline empty?
  "Return ``true`` if ``coll`` is empty (as by ``(not (seq coll))``\\).

  Typically, you should prefer the idiom ``(seq coll)`` to ``(not (empty? coll))``\\."
  [coll]
  (not (seq coll)))

(defn even?
  "Return ``true`` if ``x`` is even."
  [x]
  (if (= 0 (mod x 2)) true false))

(defn ^:inline false?
  "Return ``true`` if ``x`` is ``false``\\, otherwise ``false``\\."
  [x]
  (operator/is- x false))

(def ^{:doc "Return ``true`` if ``o`` is a :external:py:class:`float`\\.

             Same as :lpy:fn:`float?`. Python does not distinguish between single and
             double precision floating point numbers, so all floating points are called
             ``float`` and are double precision."}
  double?
  float?)

(defn fn?
  "Return ``true`` if ``x`` is a function created by ``fn`` or ``fn*``\\."
  [x]
  (and (python/callable x)
       (python/hasattr x "_basilisp_fn")
       (python/getattr x "_basilisp_fn")))

(defn ident?
  "Return ``true`` if ``x`` is either a keyword or symbol."
  [x]
  (or (keyword? x) (symbol? x)))

(defn ^:inline ifn?
  "Return ``true`` if ``x`` is callable as a function.

  Many Basilisp data structures are callable as functions though they are not proper
  function types."
  [x]
  (python/callable x))

(defn ^:inline indexed?
  "Return ``true`` if elements of ``x`` can be accessed by index efficiently."
  [x]
  (instance? basilisp.lang.interfaces/IIndexed x))

(defn infinite?
  "Return ``true`` if ``x`` is either positive or negative infinity."
  [x]
  (math/isinf x))

(def ^{:doc "Return ``true`` if ``x`` is an :external:py:class`int`\\.

             Note that unlike Clojure, Basilisp uses Python integers and there is no
             distinction between standard and fixed-precision integers."}
  int?
  integer?)

(defn ^:inline map-entry?
  "Return ``true`` if ``x`` implements :py:class:`basilisp.lang.interfaces.IMapEntry`\\."
  [x]
  (instance? basilisp.lang.interfaces/IMapEntry x))

(defn NaN?
  "Return ``true`` if ``x`` is NaN."
  [x]
  (math/isnan x))

(defn neg?
  "Return ``true`` if ``x`` is negative."
  [x]
  (if (operator/lt x 0) true false))

(defn non-neg?
  "Return ``true`` if ``x`` is not negative."
  [x]
  (if (operator/ge x 0) true false))

(defn nat-int?
  "Return ``true`` if ``x`` is a non-negative integer"
  [x]
  (and (integer? x) (non-neg? x)))

(defn neg-int?
  "Return ``true`` if ``x`` is a negative integer."
  [x]
  (and (integer? x) (neg? x)))

(defn ^:inline some?
  "Return ``true`` if ``x`` is not ``nil``\\, otherwise ``false`` s."
  [x]
  (not (nil? x)))

(defn number?
  "Return ``true`` if ``x`` is a number (integer, float, or complex)."
  [x]
  (or (integer? x) (float? x) (complex? x)))

(defn odd?
  "Return ``true`` if ``x`` is odd."
  [x]
  (if (= 1 (mod x 2)) true false))

(defn pos?
  "Return ``true`` if ``x`` is positive."
  [x]
  (if (operator/gt x 0) true false))

(defn pos-int?
  "Return ``true`` if ``x`` is a positive integer."
  [x]
  (and (integer? x) (pos? x)))

(defn ^:inline py-dict?
  "Return ``true`` if ``x`` is a Python :external:py:class:`dict`\\."
  [x]
  (instance? python/dict x))

(defn ^:inline py-frozenset?
  "Return ``true`` if ``x`` is a Python :external:py:class:`frozenset`\\."
  [x]
  (instance? python/frozenset x))

(defn ^:inline py-list?
  "Return ``true`` if ``x`` is a Python :external:py:class:`list`\\."
  [x]
  (instance? python/list x))

(defn ^:inline py-set?
  "Return ``true`` if ``x`` is a Python :external:py:class:`set`\\."
  [x]
  (instance? python/set x))

(defn ^:inline py-tuple?
  "Return ``true`` if ``x`` is a Python :external:py:class:`tuple`\\."
  [x]
  (instance? python/tuple x))

(defn qualified-ident?
  "Return ``true`` if ``x`` is either a keyword or symbol with a namespace."
  [x]
  (and (ident? x) (some? (namespace x))))

(defn qualified-keyword?
  "Return ``true`` if ``x`` is a keyword with a namespace."
  [x]
  (and (keyword? x) (some? (namespace x))))

(defn qualified-symbol?
  "Return ``true`` if ``x`` is a symbol with a namespace."
  [x]
  (and (symbol? x) (some? (namespace x))))

(defn ^:inline queue?
  "Return ``true`` if ``x`` is a persistent queue."
  [x]
  (instance? basilisp.lang.queue/PersistentQueue x))

(defn ^:no-inline ratio?
  "Return ``true`` if ``x`` is a :external:py:class:`fractions.Fraction`\\."
  [x]
  (instance? fractions/Fraction x))

(defn rational?
  "Return ``true`` if ``x`` is a rational number."
  [x]
  (or (int? x) (ratio? x) (decimal? x)))

(defn real-number?
  "Return ``true`` if ``x`` is a real number."
  [x]
  (or (integer? x) (float? x)))

(defn ^:inline reversible?
  "Return ``true`` if x implements :py:class:`basilisp.lang.interfaces.IReversible`\\."
  [x]
  (instance? basilisp.lang.interfaces/IReversible x))

(defn ^:inline seqable?
  "Return ``true`` if an :py:class:`basilisp.lang.interfaces.ISeq` can be produced from
  ``x``\\."
  [x]
  (instance? basilisp.lang.interfaces/ISeqable x))

(defn ^:inline sequential?
  "Return ``true`` if ``x`` implements :py:class:`basilisp.lang.interfaces.ISequential`\\."
  [x]
  (instance? basilisp.lang.interfaces/ISequential x))

(defn simple-ident?
  "Return ``true`` if ``x`` is either a keyword or symbol without a namespace."
  [x]
  (and (ident? x) (nil? (namespace x))))

(defn simple-keyword?
  "Return ``true`` if ``x`` is a keyword with no namespace."
  [x]
  (and (keyword? x) (nil? (namespace x))))

(defn ^:inline special-symbol?
  "Return ``true`` if ``x`` is a special form symbol."
  [x]
  (basilisp.lang.runtime/is-special-form x))

(defn simple-symbol?
  "Return ``true`` if ``x`` is a symbol with no namespace."
  [x]
  (and (symbol? x) (nil? (namespace x))))

(defn ^:inline true?
  "Return ``true`` if ``x`` is ``true``\\, otherwise ``false``\\."
  [x]
  (operator/is- x true))

(defn ^:no-inline uuid?
  "Return ``true`` if ``x`` is a :external:py:class:`uuid.UUID`."
  [x]
  (instance? uuid/UUID x))

(defn uuid-like?
  "Return ``true`` if ``x`` is coercible to a :external:py:class:`uuid.UUID`.

  Python's UUID constructor supports byte sequences in big- and little-endian byte
  orders. This function checks only for big-endian bytes."
  [x]
  (try
    (cond
      (uuid? x)         true
      (string? x)       (do (uuid/UUID x) true)
      (int? x)          (do (uuid/UUID ** :int x) true)
      (byte-string? x)  (do (uuid/UUID ** :bytes x) true)
      (or (py-tuple? x)
          (vector? x))  (do (uuid/UUID ** :fields x) true)
      :else             false)
    (catch python/AttributeError _ false)
    (catch python/TypeError _ false)
    (catch python/ValueError _ false)))

(defn ^:inline var?
  "Return ``true`` if ``x`` is a Var."
  [x]
  (instance? basilisp.lang.runtime/Var x))

(defn ^:inline zero?
  "Return ``true`` if ``x`` is 0."
  [x]
  (= 0 x))

;;;;;;;;;;;;;;;;;;;;
;; Type Utilities ;;
;;;;;;;;;;;;;;;;;;;;

(defn ^:inline bases
  "Return the direct superclasses and interfaces of ``cls`` as a sequence."
  [cls]
  (apply list (.-__bases__ cls)))

(defn cast
  "Throws a ``TypeError`` if ``x`` is not a ``cls``\\. Otherwise, return ``x``\\."
  [cls x]
  (when-not (instance? cls x)
    (throw (python/TypeError
            (str "Cannot cast object of type " (python/type x) " to " cls))))
  x)

(defn ^:inline class
  "Return the class of ``x``\\."
  [x]
  (python/type x))

(defn ^:inline subclasses
  "Return a set of subclasses of ``cls``\\.

  This set is not guaranteed to be exhaustive because classes only retain a weak
  reference to their subclasses, so it is possible subclasses of ``cls`` have been
  garbage collected."
  [cls]
  (set (.__subclasses__ cls)))

(defn ^:inline supers
  "Return the direct and indirect superclasses and interfaces of ``cls`` as a set."
  [cls]
  (set (python/filter #(not= cls %) (.-__mro__ cls))))

(defn ^:inline type
  "Return the type of ``x``\\."
  [x]
  (python/type x))

;;;;;;;;;;;;;;;;;;;
;; Type Coercion ;;
;;;;;;;;;;;;;;;;;;;

(defn bigdec
  "Coerce ``x`` to a Python :external:py:class:`decimal.Decimal`\\."
  [x]
  (decimal/Decimal x))

(defn ^:inline bigint
  "Coerce ``x`` to an integer.

  Python's builtin ``int`` type is arbitrary precision, so there is no difference
  between ``bigint``\\, ``biginteger``\\, and Python's builtin
  :external:py:class:`int`\\."
  [x]
  (python/int x))

(defn ^:inline biginteger
  "Coerce ``x`` to an integer.

  Python's builtin ``int`` type is arbitrary precision, so there is no difference
  between ``bigint``\\, ``biginteger``\\, and Python's builtin
  :external:py:class:`int`\\."
  [x]
  (python/int x))

(defn ^:no-inline boolean
  "Coerce ``x`` to a boolean.

  Only ``false`` and ``nil`` are logical false and will return ``false``\\. All
  other values will return ``true``\\."
  [x]
  (if (or (nil? x) (false? x))
    false
    true))

(defn byte
  "Coerce ``x`` to a byte."
  [x]
  (let [b (python/bytes [x])]
    (if (= 1 (python/len b))
      b
      (throw
       (python/ValueError (str "cannot coerce " (python/repr x) " to byte"))))))

(defn byte-string
  "Coerce ``x`` to a byte string (Python :external:py:class:`bytes` object).

  Arguments shall be interpreted exactly as with that object's constructor."
  ([x]
   (python/bytes x))
  ([x encoding]
   (python/bytes x encoding))
  ([x encoding errors]
   (python/bytes x encoding errors)))

(defn char
  "Coerce ``x`` to a string of length 1.

  Natural integers are treated as ordinals and passed to Python's :external:py:func:`chr`.
  Strings of length 1 are returned as such. Other types will result in a ``ValueError``\\."
  [x]
  (cond
    (instance? python/int x) (python/chr x)
    (char? x)                x
    :else                    (throw
                              (python/ValueError
                               (str "cannot cast " (python/repr x) " to char")))))

(defn ^:inline double
  "Coerce ``x`` to a float.

  Python does not differentiate between ``float`` and ``double``. Python
  :external:py:class:`float`\\s are double precision."
  [x]
  (python/float x))

(defn ^:inline float
  "Coerce ``x`` to a :external:py:class:`float`\\.

  If ``x`` is string, it is parsed as a floating point number."
  [x]
  (python/float x))

(defn ^:inline int
  "Coerce ``x`` to an :external:py:class:`int`\\.

  If ``x`` is string, it is parsed as a base 10 number."
  [x]
  (python/int x))

(defn ^:inline long
  "Coerce ``x`` to an :external:py:class:`int`\\.

  Python does not support `long` types, so the value is coerced to an integer as by
  :lpy:fn:`int`\\."
  [x]
  (python/int x))

(defn ^:inline short
  "Coerce ``x`` to an :external:py:class:`int`\\.

  Python does not support `short` types, so the value is coerced to an integer as by
  :lpy:fn:`int`\\."
  [x]
  (python/int x))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unchecked Arithmetic ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro ^:private defcopy
  "Copy the Var ``var`` into a new Var as ``name``.

  Append the given docstring ``doc`` to the end of the new Var's ``doc``\\."
  ([name var]
   `(defcopy ~name nil ~var))
  ([name doc var]
   (let [orig-var      (basilisp.lang.runtime/resolve-var var *ns*)
         orig-var-meta (meta orig-var)
         var-doc       (:doc orig-var-meta)
         new-doc       (if doc
                         (str var-doc "\n\n" doc)
                         var-doc)
         vname         (vary-meta name
                                  assoc
                                  :doc new-doc
                                  :arglists (list 'quote (:arglists orig-var-meta)))]
     `(def ~vname ~var))))

(defcopy unchecked-add
  "Same as :lpy:fn:`+`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  +)
(defcopy unchecked-add-int
  "Same as :lpy:fn:`+`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  +)
(defcopy unchecked-subtract
  "Same as :lpy:fn:`-`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  -)
(defcopy unchecked-subtract-int
  "Same as :lpy:fn:`-`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  -)
(defcopy unchecked-multiply
  "Same as :lpy:fn:`*`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  *)
(defcopy unchecked-multiply-int
  "Same as :lpy:fn:`*`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  *)
(defcopy unchecked-divide-int
  "Same as :lpy:fn:`/`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  /)

(defcopy unchecked-inc
  "Same as :lpy:fn:`inc`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  inc)
(defcopy unchecked-inc-int
  "Same as :lpy:fn:`inc`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  inc)
(defcopy unchecked-dec
  "Same as :lpy:fn:`dec`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  dec)
(defcopy unchecked-dec-int
  "Same as :lpy:fn:`dec`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  dec)

(defn unchecked-negate
  "Return the negation of ``x``\\.

  Same as ``(- x)``\\. Python integers are unlimited precision so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  [x]
  (- x))
(defcopy unchecked-negate-int unchecked-negate)

(defn unchecked-byte
  "Coerce ``x`` to a byte. Value may be truncated or rounded."
  [x]
  (byte (mod x 256)))

(defn unchecked-char
  "Coerce ``x`` to a char. Value may be truncated or rounded."
  [x]
  (cond
    (instance? python/int x) (char (mod x sys/maxunicode))
    :else                    (char x)))

(defcopy unchecked-double
  "Same as :lpy:fn:`double`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  double)
(defcopy unchecked-float
  "Same as :lpy:fn:`float`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  float)

(defcopy unchecked-int
  "Same as :lpy:fn:`int`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  int)
(defcopy unchecked-long
  "Same as :lpy:fn:`long`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  long)
(defcopy unchecked-short
  "Same as :lpy:fn:`short`. Python integers are unlimited precision, so unchecked
  arithmetic is only provided for compatibility with platforms without unlimited
  precision integers."
  short)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arrays (Python List) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline to-array
  "Return a Python list with the contents of ``coll``\\."
  [coll]
  (python/list coll))

(defn ^:inline to-array-2d
  "Return a two-dimensional Python list from the contents of ``coll``\\.

  Python lists do not specify a fixed size, so the resulting two-dimensional list may
  be ragged (in the Java sense of the word) if the inner collections of the input are
  ragged."
  [coll]
  (python/list (python/map python/list coll)))

(defn into-array
  "Returns a Python list with the values from ``aseq``\\.

  The type argument is ignored and is provided only for Clojure compatibility."
  ([aseq]
   (python/list aseq))
  ([^:no-warn-when-unused type aseq]
   (python/list aseq)))

(defn make-array
  "Create a Python list with initial ``size``\\. If multiple sizes are provided,
  produces a multi-dimensional list-of-lists. There is no efficient way to allocate
  such multi-dimensional lists in Python, so this function will run in polynomial time.

  Python lists do not support pre-allocation by capacity, so this function pre-fills
  the created list(s) with ``nil``.

  The ``type`` argument is ignored and is provided only for Clojure compatibility."
  ([size]
   (operator/mul #py [nil] size))
  ([^:no-warn-when-unused type size]
   (operator/mul #py [nil] size))
  ([^:no-warn-when-unused type size & more-sizes]
   (let [final #py []]
     (loop [size size]
       (if (pos? size)
         (do
           (.append final (apply make-array type more-sizes))
           (recur (dec size)))
         final)))))

(defn object-array
  "Create an array of objects.

  If ``init-val-or-seq`` and is a ``seq`` yielding fewer than ``size`` elements, then
  the remaining indices of the resulting array will be filled with ``nil`` values.

  This function does not coerce its argument and is provided for Clojure compatibility."
  ([size-or-seq]
   (if (int? size-or-seq)
     (make-array size-or-seq)
     (to-array size-or-seq)))
  ([size init-val-or-seq]
   (if (and (seqable? init-val-or-seq) (seq init-val-or-seq))
     (let [final #py []]
       (loop [arr-seq (seq init-val-or-seq)
              idx     0]
         (when (< idx size)
           (.append final (first arr-seq))
           (recur (rest arr-seq) (inc idx))))
       final)
     (operator/mul #py [init-val-or-seq] size))))

(defn ^:inline aclone
  "Return a clone of the Python list."
  [array]
  (python/list array))

(defn aget
  "Return the value of the Python list at the index (or indices)."
  ([array idx]
   (operator/getitem array idx))
  ([array idx & idxs]
   (if (seq idxs)
     (recur (operator/getitem array idx) (first idxs) (rest idxs))
     (operator/getitem array idx))))

(defn aset
  "Sets the value of the Python list at the index (or indices). Returns ``val``\\."
  ([array idx val]
   (operator/setitem array idx val)
   val)
  ([array idx idx2 & idxs]
   (loop [target (operator/getitem array idx)
          idx    idx2
          idx2   (first idxs)
          idxs   (rest idxs)]
     (if (seq idxs)
       (recur (operator/getitem target idx) idx2 (first idxs) (rest idxs))
       (do
         (operator/setitem target idx idx2)
         idx2)))))

(defn ^:inline alength
  "Return the length of the Python list."
  [array]
  (python/len array))

(defmacro amap
  "Map ``expr`` over the Python list `array`, returning a new Python list with the
  result.

  This macro initially binds the symbol named by ``ret`` to a clone of ``array``\\. On
  each iteration, the index (named by ``idx``\\) of ``ret`` is set to the return value
  of ``expr``\\."
  [array idx ret expr]
  `(let [len# (alength ~array)
         ~ret (aclone ~array)]
     (loop [~idx 0]
       (when (< ~idx len#)
         (aset ~ret ~idx ~expr)
         (recur (inc ~idx))))
     ~ret))

(defmacro areduce
  "Reduce the Python list ``array`` by ``expr``\\, returning the reduced expression.

  This macro initially binds the symbol named by ``ret`` to ``init``\\. On each
  iteration, ``ret`` is rebound to the return value of ``expr``\\."
  [array idx ret init expr]
  `(let [len# (alength ~array)]
     (loop [~ret ~init
            ~idx 0]
       (if (< ~idx len#)
         (recur ~expr (inc ~idx))
         ~ret))))

(defn ^:inline booleans
  "Dummy cast to a Python list of booleans.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline bytes
  "Dummy cast to a Python list of bytes (distinct from Python's ``bytarray`` and
  ``bytes`` types).

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline chars
  "Dummy cast to a Python list of chars.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline doubles
  "Dummy cast to a Python list of doubles.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline floats
  "Dummy cast to a Python list of floats.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline ints
  "Dummy cast to a Python list of integers.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline longs
  "Dummy cast to a Python list of longs.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ^:inline shorts
  "Dummy cast to a Python list of shorts.

  This function is provided for Clojure compatibility."
  [x]
  x)

;;;;;;;;;;;;;;;;
;; Exceptions ;;
;;;;;;;;;;;;;;;;

(def ^{:doc     "During a REPL session, bound to the most recent value evaluated."
       :dynamic true}
  *1
  nil)
(def ^{:doc     "During a REPL session, bound to the second most recent value evaluated."
       :dynamic true}
  *2
  nil)
(def ^{:doc     "During a REPL session, bound to the third most recent value evaluated."
       :dynamic true}
  *3
  nil)
(def ^{:doc     "During a REPL session, bound to the most recently thrown exception."
       :dynamic true}
  *e
  nil)

(defn ex-cause
  "Return the cause (another Exception) of ``ex`` if it derives from ``Exception``\\,
  otherwise it returns ``nil``\\."
  [ex]
  (when (instance? python/Exception ex)
    (or (.- ex __cause__) (.- ex __context__))))

(defn ex-data
  "Return the data map of ``ex`` if is an instance of
  :py:class:`basilisp.lang.interfaces.IExceptionInfo`\\, otherwise it returns
  ``nil``\\."
  [ex]
  (when (instance? basilisp.lang.interfaces/IExceptionInfo ex)
    (.-data ex)))

(defn ex-message
  "Return the message of ``ex`` if is an Exception, otherwise it returns ``nil``\\."
  [ex]
  (when (instance? python/Exception ex)
    (python/getattr ex "message" (python/str ex))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Bit Manipulation Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn bit-and
  "Return the bitwise and of ``x`` and ``args``\\."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (first args)) rest-arg)
    (operator/and- x (first args))))

(defn bit-or
  "Return the bitwise or of ``x`` and ``args``\\."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/or- x (first args)) rest-arg)
    (operator/or- x (first args))))

(defn ^:inline bit-not
  "Invert the bits of ``x``\\."
  [x]
  (operator/invert x))

(defn ^:inline bit-shift-left
  "Return ``x`` shifted left ``n`` bits."
  [x n]
  (operator/lshift x n))

(defn ^:inline bit-shift-right
  "Return ``x`` shifted right ``n`` bits."
  [x n]
  (operator/rshift x n))

(defn bit-xor
  "Return the bitwise xor of ``x`` and ``args``\\."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/xor x (first args)) rest-arg)
    (operator/xor x (first args))))

(defn bit-and-not
  "Return the bitwise and complement of ``x`` and ``args``\\."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (operator/not- (first args))) rest-arg)
    (operator/and- x (operator/not- (first args)))))

(defn ^:inline bit-clear
  "Clear the bit of ``x`` at index ``n``\\."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn ^:inline bit-flip
  "Flip the bit of ``x`` at index ``n``\\."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn ^:inline bit-set
  "Set the bit of ``x`` at index ``n``\\."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn ^:inline bit-test
  "Test the bit of ``x`` at index ``n``\\."
  [x n]
  (bit-and (bit-shift-right x n) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn bounded-count
  "Return the count (as by :lpy:fn:`count`) of any ``coll`` for which ``counted?``
  returns ``true``, otherwise return the lesser of ``n`` and the length of
  ``coll``\\."
  [n coll]
  (if (counted? coll)
    (count coll)
    (let [counter (fn counter
                    [coll cur]
                    (cond
                      (>= cur n)       n
                      (not (seq coll)) cur
                      :else            (recur (rest coll) (inc cur))))]
      (counter coll 0))))

(defn empty
  "Return an empty collection of the same interface type as ``coll``\\, or ``nil``\\."
  [coll]
  (when (coll? coll)
    (.empty coll)))

(defn not-empty
  "Return ``coll`` when ``coll`` is not empty, otherwise return ``nil``\\."
  [coll]
  (when (seq coll)
    coll))

(defn ^:inline peek
  "For a list or a queue, return the first element.

  For a vector, return the last element (more efficiently than by last).

  For empty collections, returns ``nil``\\."
  [coll]
  (when coll (.peek coll)))

(defn ^:inline pop
  "For a list or a queue, return a new list without the first element.

  For a vector, return a new vector without the last element.

  If ``coll`` is empty, throw an exception."
  [coll]
  (when coll (.pop coll)))

(defn reverse
  "Return a seq containing the elements in ``coll`` in reverse order. The returned
  sequence is not lazy."
  [coll]
  (let [do-reverse (fn do-reverse
                     [in out]
                     (if (seq in)
                       (recur (rest in) (cons (first in) out))
                       out))]
    (do-reverse coll '())))

(defn ^:inline rseq
  "Return a sequence of the elements of ``coll`` in reverse order in constant time.
  Only Vectors support this operation."
  [coll]
  (.rseq coll))

(defn subvec
  "Return a vector of elements consisting of the elements of ``v`` from the index
  ``start`` (inclusive) to index ``end`` exclusive, or the end of the vector if no
  ``end`` is supplied."
  ([v start]
   (subvec v start nil))
  ([v start end]
   (when (> start (count v))
     (throw (python/IndexError "Start index out of range")))
   (when-not (nil? end)
     (when (> end (count v))
       (throw (python/IndexError "End index out of range")))
     (when (> start end)
       (throw (python/IndexError "Start index must be less than or equal to end index"))))
   (operator/getitem v (python/slice start end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline contains?
  "Return ``true`` if ``coll`` contains ``k``\\. For vectors, ``k`` is an index. For
  maps, ``k`` is a key. For sets, ``k`` is a value in the set."
  [coll k]
  (basilisp.lang.runtime/contains coll k))

(defn disj
  "Return a new version of the set ``s`` without the given elements. If the elements
  don't exist in ``s``\\, they are ignored."
  ([s] s)
  ([s elem]
   (when s
     (.disj s elem)))
  ([s elem & elems]
   (when s
     (apply (.-disj s) elem elems))))

(defn dissoc
  "Return a new version of ``m`` without the given keys. If the keys don't exist in
  ``m``\\, they are ignored."
  ([m] m)
  ([m k]
   (when m
     (.dissoc m k)))
  ([m k & ks]
   (when m
     (apply (.-dissoc m) k ks))))

(defn get
  "Return the entry of ``m`` corresponding to ``k`` if it exists or ``nil`` or
  ``default`` (if specified) otherwise.

  ``m`` may be any associative type (such as a vector or map), set type, or string.
  If ``m`` is not one of the supported types, ``get`` always returns ``nil`` or
  ``default`` (if specified)."
  ([m k]
   (basilisp.lang.runtime/get m k))
  ([m k default]
   (basilisp.lang.runtime/get m k default)))

(defn assoc-in
  "Associate value in a nested associative structure, with ``ks`` as a sequence of keys
  and ``v`` as the new value. If no map exists for any key in ``ks``\\, a new empty map
  will be created."
  [m ks v]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m fk (assoc-in (get m fk) rks v))
      (basilisp.lang.runtime/assoc m fk v))))

(defn get-in
  "Return the entry of an associative data structure addressed by the sequence of keys
  ``ks`` or ``default`` (default: ``nil``\\) if the value is not found."
  ([m ks]
   (get-in m ks nil))
  ([m ks default]
   (let [fk  (first ks)
         rks (rest ks)]
     (if (seq rks)
       (if-let [child-map (basilisp.lang.runtime/get m fk)]
         (get-in child-map rks default)
         default)
       (basilisp.lang.runtime/get m fk default)))))

(defn update
  "Updates the value for key ``k`` in associative data structure ``m`` with the return
  value from calling ``(f old-v & args)``\\. If ``m`` is ``nil``\\, use an empty map. If
  ``k`` is not in ``m``\\, ``old-v`` will be ``nil``\\."
  [m k f & args]
  (apply basilisp.lang.runtime/update m k f args))

(defn update-in
  "Updates the value for key ``k`` in associative data structure ``m`` with the return
  value from calling ``(f old-v & args)``\\. If ``m`` is ``nil``\\, use an empty map. If
  ``k`` is not in ``m``\\, ``old-v`` will be ``nil``\\."
  [m ks f & args]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m
                                   fk
                                   (apply update-in
                                          (or (basilisp.lang.runtime/get m fk) {})
                                          rks
                                          f
                                          args))
      (apply basilisp.lang.runtime/update m fk f args))))

(defn map-entry
  "With one argument, coerce the input to a map entry. With two arguments, return a
  map entry containing ``key`` and ``value``\\."
  ([coll]
   (if (= 2 (count coll))
     (basilisp.lang.map.MapEntry/from-vec coll)
     (throw
      (ex-info "Cannot coerce object to basilisp.lang.map.MapEntry"
               {:coll coll
                :type (type coll)}))))
  ([k v]
   (basilisp.lang.map.MapEntry/of k v)))

(defn find
  "Find the map entry of ``k`` in ``m``\\, if it exists. Return ``nil`` otherwise."
  [m k]
  (when (contains? m k)
    (map-entry k (get m k))))

(defn ^:inline key
  "Return the key from a map entry."
  [entry]
  (.-key entry))

(defn ^:inline val
  "Return the val from a map entry."
  [entry]
  (.-value entry))

(defn ^:inline keys
  "Return a seq of the keys from a map-like object.

  If ``m`` is ``nil``, return ``nil``.

  If ``m`` is castable to a seq, cast it to a seq and call ``keys`` on that.

  If ``m`` is a seq, yield the keys from successive entries (which must be map
  entries).

  If ``m`` is any type of mapping, return a seq of that mapping's keys."
  [m]
  (basilisp.lang.runtime/keys m))

(defn ^:inline vals
  "Return a seq of the values from a map-like object

  If ``m`` is ``nil``, return ``nil``.

  If ``m`` is castable to a seq, cast it to a seq and call ``vals`` on that.

  If ``m`` is a seq, yield the valuess from successive entries (which must be map
  entries).

  If ``m`` is any type of mapping, return a seq of that mapping's values."
  [m]
  (basilisp.lang.runtime/vals m))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transient Collections ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn transient
  "Return a transient copy of persistent collection ``coll``\\.

  Transients can be created from maps, sets, and vectors. Transients allow faster
  mutations than their persistent counterparts and are useful for performance
  sensitive code which makes many modifications to these data structures.

  Transient collections can be edited with the transient versions of the familiar
  collection functions (depending on the type of ``coll``\\): :lpy:fn:`assoc!`,
  :lpy:fn:`conj!`, :lpy:fn:`disj!`, :lpy:fn:`dissoc!`, and :lpy:fn:`pop!`. Transient
  collections are designed to be used in the same style as the builtin persistent
  collections, so callers should be sure to use the returned value from prior calls
  to these collection functions rather than repeatedly modifying the collection in
  place.

  Once you have completed all of your modifications to the local transient
  collection, you can call :lpy:fn:`persistent!` to return a persistent version of that
  data structure."
  [coll]
  (if (instance? basilisp.lang.interfaces/IEvolveableCollection coll)
    (.to-transient coll)
    (throw
     (ex-info (str "Object of type " (type coll) " does not implement "
                   "IEvolveableCollection interface")
              {:coll coll
               :type (type coll)}))))

(defn persistent!
  "Return a persistent copy of the transient collection ``coll`` which was created
  by calling ``transient``\\."
  [coll]
  (if (instance? basilisp.lang.interfaces/ITransientCollection coll)
    (.to-persistent coll)
    (throw
     (ex-info (str "Object of type " (type coll) " does not implement "
                   "ITransientCollection interface")
              {:coll coll
               :type (type coll)}))))

(defn assoc!
  "Associate keys to values in the transient associative data structure ``m``\\."
  ([m k v]
   (.assoc-transient m k v))
  ([m k v & kvs]
   (apply (.-assoc-transient m) k v kvs)))

(defn conj!
  "Conjoin ``xs`` to the transient collection ```coll``\\. New elements may be added in
  different positions depending on the type of ``coll``\\. ``conj!`` returns the same
  type as ``coll``\\."
  ([] (transient []))
  ([coll] coll)
  ([coll & xs]
   (apply (.-cons-transient coll) xs)))

(defn disj!
  "Return a new version of the transient set ``s`` without the given elements. If the
  elements don't exist in ``s``\\, they are ignored."
  ([s] s)
  ([s elem]
   (.disj-transient s elem))
  ([s elem & elems]
   (apply (.-disj-transient s) elem elems)))

(defn dissoc!
  "Return a new version of the transient associative collection ``m`` without the
  given keys. If the keys don't exist in ``m``\\, they are ignored."
  ([m k] (.dissoc-transient m k))
  ([m k & ks]
   (apply (.-dissoc-transient m) k ks)))

(defn ^:inline pop!
  "Return a new transient vector without the last element of ``coll``\\. If ``coll`` is
  empty, throw an exception."
  [coll]
  (.pop-transient coll))

;;;;;;;;;;;;;;;
;; Volatiles ;;
;;;;;;;;;;;;;;;

(defn ^:inline volatile!
  "Return a Volatile reference container with the initial value ``v``\\."
  [v]
  (basilisp.lang.volatile/Volatile v))

(defn ^:inline volatile?
  "Return ``true`` if ``x`` is a volatile reference container."
  [x]
  (instance? basilisp.lang.volatile/Volatile x))

(defn ^:inline vreset!
  "Reset the value of volatile ``v`` non-atomically to ``new-val``. Returns the new
  value."
  [v new-val]
  (.reset v new-val))

(defn vswap!
  "Swap the value of volatile ``v`` non-atomically to the return of
  ``(apply f old-val args)``\\. Returns the new value of that function call."
  [v f & args]
  (apply (.-swap v) f args))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transducer Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline reduced
  "Wraps a value ``x`` such that it will terminate a reduce operation.

  Callers can retrieve the inner reduced value using :lpy:fn:`deref` or ``@x``\\."
  [x]
  (basilisp.lang.reduced/Reduced x))

(defn ^:inline reduced?
  "Return true if ``x`` should be considered fully reduced."
  [x]
  (instance? basilisp.lang.reduced/Reduced x))

(defn ensure-reduced
  "If ``x`` is not a reduced value, wrap it (as by :lpy:fn:`reduced`) and return the
  wrapper. Otherwise return ``x``\\."
  [x]
  (if (reduced? x) x (reduced x)))

(defn unreduced
  "If ``x`` is a reduced value (as produced by :lpy:fn:`reduced`), unwrap it and return
  the inner value. Otherwise return ``x``\\."
  [x]
  (if (reduced? x) @x x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher Order and Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro lazy-seq
  "Takes a body of expressions which will produce a seq or ``nil``\\. When ``seq`` is
  first called on the resulting ``lazy-seq``\\, the sequence will be realized."
  [& body]
  (list 'basilisp.lang.seq/LazySeq
        (concat '(fn* []) body)))

(defmacro lazy-cat
  "Return a lazy sequence of the concatenation of ``colls``\\. None of the input
  collections will be evaluated until it is needed."
  [& colls]
  `(concat ~@(map (fn [coll] `(lazy-seq ~coll)) colls)))

(defn dorun
  "Force a lazy sequence be fully realized. Returns ``nil``\\.

  This is often useful when you have a lazy sequence whose function also performs side
  effects.

  Realizing an entire lazy sequence will force that sequence to exist fully in memory."
  ([coll]
   (loop [ptr coll]
     (when (seq ptr)
       (recur (rest ptr)))))
  ([n coll]
   (loop [ptr coll
          i   n]
     (when (and (seq ptr) (> i 0))
       (recur (rest ptr) (dec i))))))

(defn doall
  "Force a lazy sequence be fully realized. Returns the head of the sequence.

  This is often useful when you have a lazy sequence whose function also performs side
  effects.

  Realizing an entire lazy sequence will force that sequence to exist fully in memory."
  ([coll]
   (dorun coll)
   coll)
  ([n coll]
   (dorun n coll)
   coll))

(defn iterate
  "Returns a lazy sequence of ``x``\\, ``(f x)``\\, ``(f (f x))`` and so on."
  [f x]
  (lazy-seq
   (when x
     (cons x (iterate f (f x))))))

(defn range
  "Return a range of integers from ``start``\\. If ``end`` is specified, the sequence
  will terminate at ``end``\\. If ``step`` is specified, that amount will be added
  for each iteration. ``step`` may be negative."
  ([]
   (iterate inc 0))
  ([end]
   (lazy-seq (cons 0 (range 1 end))))
  ([start end]
   (lazy-seq
    (when (< start end)
      (cons start (range (inc start) end)))))
  ([start end step]
   (lazy-seq
    (when (or (and (>= step 0) (< start end))
              (and (< step 0) (> start end)))
      (cons start (range (+ start step) end step))))))

(defn complement
  "Return a function which returns the logical complement of the return value of
  ``(apply f args)``\\."
  [f]
  (fn
    ([x] (not (f x)))
    ([x y] (not (f x y)))
    ([x y z] (not (f x y z)))
    ([x y z & args]
     (not (apply f x y z args)))))

(defn constantly
  "Returns a function that accepts any number of arguments and returns ``x``\\."
  [x]
  (fn [& ^:no-warn-when-unused args] x))

;; reduce is defined after loading basilisp.core.protocols
(defn- reduce*
  "Internal implementation of reduce which uses seq iteration."
  ([f coll]
   (basilisp.lang.runtime/internal-reduce coll f))
  ([f val coll]
   (basilisp.lang.runtime/internal-reduce coll f val)))

(defn comp
  "Return a function which is the composition of all the functions given as arguments.
  Note that, as in mathematical function composition, the argument functions are called
  from right to left."
  ([] identity)
  ([f] f)
  ([f g]
   (fn
     ([x] (f (g x)))
     ([x y] (f (g x y)))
     ([x y z] (f (g x y z)))
     ([x y z & args] (f (apply g x y z args)))))
  ([f g & args]
   (reduce* comp f (cons g args))))

(defn juxt
  "Return a function which takes any number of arguments and applies each of the
  argument functions to this function in order, returning a vector of the return
  values from each function."
  [& args]
  (fn [& inner-args]
    (reduce* (fn [v f]
               (conj v (apply f inner-args)))
             []
             args)))

(defn fnil
  "Given a function ``f``, return a new function which replaces a ``nil`` first argument
  with the value ``x``. Higher arity variants will replace their corresponding ``nil``
  argument with the provided default value for that argument position.

  The function returned from ``fnil`` supports any number of arguments greater than or
  equal to the arity of the ``fnil`` that is called."
  ([f x]
   (fn [a & args]
     (apply f (or a x) args)))
  ([f x y]
   (fn [a b & args]
     (apply f (or a x) (or b y) args)))
  ([f x y z]
   (fn [a b c & args]
     (apply f (or a x) (or b y) (or c z) args))))

(defn partial
  "Return a function which is the partial application of ``f`` with ``args``\\."
  ([f] f)
  ([f & args]
   (apply basilisp.lang.runtime/partial f args)))

(defn partial-kw
  "Return a function which is the partial application of ``f`` with keyword arguments.

  If a single argument is provided, it will be interpreted as a map of keyword
  arguments.

  If multiple arguments are given, they are interpreted as key/value pairs and will
  be converted into a hash-map before being partially applied to the function.

  This function applies keyword arguments via :lpy:fn:`apply-kw`. As a consequence, Lisp
  keywords will be converted to munged Python strings (via :lpy:fn:`name`), meaning
  namespaces will be lost and identifiers which are not valid Python syntax will be
  converted to safe Python identifiers."
  ([f] f)
  ([f m]
   (apply-kw basilisp.lang.runtime/partial f m))
  ([f arg & args]
   (let [m (apply hash-map (cons arg args))]
     (partial-kw f m))))

(defn every?
  "Return ``true`` if every element in ``coll`` satisfies ``pred``\\."
  [pred coll]
  (cond
    (nil? (seq coll))   true
    (pred (first coll)) (recur pred (rest coll))
    :else               false))

(defn every-pred
  "Return a predicate composed of all of the input predicates, which returns ``true``
  if all input predicates return ``true`` for a value, otherwise returns ``false``\\.
  The returned predicate returns ``false`` on the first failing predicate and will
  not execute any remaining predicates."
  ([pred]
   (fn [& args]
     (every? pred args)))
  ([pred & preds]
   (let [comp-pred (reduce* (fn [f g]
                              (fn [v]
                                (if (and (f v) (g v))
                                  true
                                  false)))
                            pred
                            preds)]
     (fn [& args]
       (every? comp-pred args)))))

(def
  ^{:doc "Return ``true`` if not every element in ``coll`` satisfies ``pred``\\."}
  not-every?
  (comp not every?))

(defn some
  "Return ``true`` if at least one element in ``coll`` satisfies ``pred``\\."
  [pred coll]
  (when (seq coll)
    (or (pred (first coll))
        (recur pred (rest coll)))))

(defn some-fn
  "Return a predicate composed of all of the input functions, which returns the first
  truthy return value from one of the inputs, otherwise returns ``nil``\\. The returned
  predicate returns the first truthy value it encounters and will not execute any
  remaining functions."
  ([f]
   (fn [& args]
     (some f args)))
  ([f & fs]
   (let [comp-f (reduce* (fn [f g]
                           (fn [v]
                             (or (f v) (g v))))
                         f
                         fs)]
     (fn [& args]
       (some comp-f args)))))

(def
  ^{:doc "Return ``true`` if no element in ``coll`` satisfies ``pred``\\."}
  not-any?
  (comp not some))

(defn map
  "Return a lazy sequence of ``(f elem)`` for elements in ``coll``\\. More than one
  collection may be supplied. If more than one collection is supplied, the function
  ``f`` will be passed sequential elements from each collection on each invocation
  and must be able to accept as many arguments as there are collections. The sequence
  will terminate when at least one input collection is exhausted.

  Return a transducer if no collection is provided."
  ([f]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (rf result (f input)))
       ([result input & inputs]
        (rf result (apply f input inputs))))))
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (cons (f (first coll)) (map f (rest coll))))))
  ([f coll & colls]
   (lazy-seq
    (when (and (seq coll) (every? seq colls))
      (cons (apply f (first coll) (map first colls))
            (apply map f (rest coll) (map rest colls)))))))

(def ^{:doc "Return a vector of ``(f elem)`` for elements in ``coll``\\. More than one
             collection may be supplied. If more than one collection is supplied, the
             function ``f`` will be passed sequential elements from each collection on
             each invocation and must be able to accept as many arguments as there are
             collections. The sequence will terminate when at least one input collection
             is exhausted."}
  mapv (comp vec map))

(defn map-indexed
  "Return a lazy sequence of ``(f idx elem)`` for elements in ``coll``\\. The index
  starts at 0.

  Return a stateful transducer if no collection is provided."
  ([f]
   (fn [rf]
     (let [idx (volatile! -1)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (rf result (f (vswap! idx inc) input)))))))
  ([f coll]
   (map f (range) coll)))

;; Declare `cat` now for use in `mapcat`, though it is defined much later so
;; it can make use of more advanced transducer functions.
(def ^:redef cat)

(defn mapcat
  "Return a lazy sequence of the concatenated results of mapping ``f`` over ``colls``\\."
  ([f]
   (comp (map f) cat))
  ([f coll]
   (apply concat (map f coll)))
  ([f coll & colls]
   (apply concat (apply map f coll colls))))

(defn filter
  "Return a lazy sequence of elements from ``coll`` where ``(pred elem)`` returns a
  truthy value.

  Return a transducer if no collection is provided."
  ([pred]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (if (pred input)
          (rf result input)
          result)))))
  ([pred coll]
   (lazy-seq
    (when (seq coll)
      (if (pred (first coll))
        (cons (first coll) (filter pred (rest coll)))
        (filter pred (rest coll)))))))

(def ^{:doc "Return a vector of elements from ``coll`` where ``(pred elem)`` returns
             a truthy value."}
  filterv (comp vec filter))

(defn remove
  "Return elements from ``coll`` where ``(pred elem)`` returns a falsey value.

  Return a transducer if no collection is provided."
  ([pred]
   (filter (complement pred)))
  ([pred coll]
   (filter (complement pred) coll)))

(defn keep
  "Return a lazy sequence of non- ``nil`` results of ``(f elem)`` for elements in
  ``coll``\\.

  Return a transducer if no collection is provided."
  ([f]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (let [v (f input)]
          (if (nil? v)
            result
            (rf result v)))))))
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (let [elem (f (first coll))]
        (if (nil? elem)
          (keep f (rest coll))
          (cons elem (keep f (rest coll)))))))))

(defn keep-indexed
  "Return a lazy-sequence of non- ``nil`` results of ``(f index elem)`` for elements
  in ``coll``\\.

  Return a stateful transducer if no collection is provided."
  ([f]
   (fn [rf]
     (let [idx (volatile! -1)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (let [v (f (vswap! idx inc) input)]
            (if (nil? v)
              result
              (rf result v))))))))
  ([f coll]
   (let [keep-idx (fn keep-idx
                    [rng coll]
                    (lazy-seq
                     (when (seq coll)
                       (let [elem (f (first rng) (first coll))]
                         (if (nil? elem)
                           (keep-idx (rest rng) (rest coll))
                           (cons elem (keep-idx (rest rng) (rest coll))))))))]
     (keep-idx (range) coll))))

(defn take
  "Return the first ``n`` elements of ``coll``\\."
  ([n]
   (fn [rf]
     (let [idx (volatile! (inc n))]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (if (pos? (vswap! idx dec))
            (rf result input)
            (ensure-reduced result)))))))
  ([n coll]
   (lazy-seq
    (when (> n 0)
      (when (seq coll)
        (cons (first coll) (take (dec n) (rest coll))))))))

(defn take-while
  "Return elements of ``coll`` while ``(pred elem)`` is ``true``\\.

  Return a transducer if no collection is provided."
  ([pred]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (if (pred input)
          (rf result input)
          (ensure-reduced result))))))
  ([pred coll]
   (lazy-seq
    (when (seq coll)
      (when (pred (first coll))
        (cons (first coll) (take-while pred (rest coll))))))))

(defn drop
  "Drop the first ``n`` elements of ``coll``\\.

  Return a stateful transducer if no collection is provided."
  ([n]
   (fn [rf]
     (let [idx (volatile! (inc n))]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (if (pos? (vswap! idx dec))
            result
            (rf result input)))))))
  ([n coll]
   (lazy-seq
    (when (seq coll)
      (if (> n 0)
        (drop (dec n) (rest coll))
        (seq coll))))))

(defn drop-while
  "Drop elements of ``coll`` until ``(pred elem)`` returns ``true``\\.

  Return a stateful transducer if no collection is provided."
  ([pred]
   (fn [rf]
     (let [v (volatile! false)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (cond
            @v                 (rf result input)
            (not (pred input)) (do (vreset! v true) (rf result input))
            :else              result))))))
  ([pred coll]
   (lazy-seq
    (when (seq coll)
      (if (pred (first coll))
        (drop-while pred (rest coll))
        (seq coll))))))

(defn drop-last
  "Drop all but the last ``n`` items of ``coll``\\."
  ([coll]
   (drop-last 1 coll))
  ([n coll]
   (map (comp first vector) coll (drop n coll))))

(defn butlast
  "Return all but the last element in a sequence in linear time."
  [coll]
  (drop-last coll))

(defn split-at
  "Split a collection at the ``n`` th item. Returns a vector of
  ``[(take n coll) (drop n coll)]``\\."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Split a collection at the inflection point of ``pred``\\. Returns a vector of
  ``[(take-while pred coll) (drop-while pred coll)]``\\."
  [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

(defn frequencies
  "Return a map whose keys are the elements of ``coll`` and whose values are the counts
  for the number of times the key appears in ``coll``\\."
  [coll]
  (reduce* (fn [m v]
             (if (contains? m v)
               (update m v inc)
               (assoc m v 1)))
           {}
           coll))

(defn group-by
  "Return a map whose keys are the result of calling ``f`` on each element in ``coll``
  and whose values are vectors of the values which produced the corresponding key, in
  the order they were added."
  [f coll]
  (reduce* (fn [m v]
             (let [group (f v)]
               (if (contains? m group)
                 (update m group conj v)
                 (assoc m group [v]))))
           {}
           coll))

(defn interpose
  "Return a lazy sequence of elements of ``coll`` separated by ``sep``\\. If ``coll`` is
  empty, return an empty sequence.

  Return a stateful transducer if no collection is provided."
  ([sep]
   (fn [rf]
     (let [v (volatile! 1)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (if (zero? (vswap! v dec))
            (rf result input)
            (rf (rf result sep) input)))))))
  ([sep coll]
   (lazy-seq
    (when (seq coll)
      (if (seq (rest coll))
        (cons (first coll)
              (cons sep (interpose sep (rest coll))))
        (cons (first coll) nil))))))

(defn interleave
  "Return a lazy sequence consisting of the first element of ``coll` , then the first
  element of the following ``coll``\\, etc. until the shortest input collection is
  exhausted."
  ([] '())
  ([coll] (seq coll))
  ([coll & colls]
   (let [coll-firsts (fn coll-firsts
                       [& colls]
                       (lazy-seq
                        (when (seq colls)
                          (cons (ffirst colls) (apply coll-firsts (rest colls))))))]
     (lazy-seq
      (when (and (seq coll) (every? seq colls))
        (concat (apply coll-firsts coll colls)
                (apply interleave (rest coll) (map rest colls))))))))

(defn cycle
  "Cycle the items in ``coll`` infinitely."
  [coll]
  (let [coll-cycle (fn coll-cycle
                     [curr]
                     (lazy-seq
                      (if (seq curr)
                        (cons (first curr) (coll-cycle (rest curr)))
                        (coll-cycle coll))))]
    (coll-cycle coll)))

(defn repeat
  "Repeat ``x`` infinitely or ``n`` many times if ``n`` is specified. Returns a lazy
  sequence of the ``x``\\."
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (lazy-seq
    (when (> n 0)
      (cons x (repeat (dec n) x))))))

(defn repeatedly
  "Call ``f`` infinitely or ``n`` many times if ``n`` is specified. Returns a lazy
  sequence of the return values."
  ([f]
   (lazy-seq (cons (f) (repeatedly f))))
  ([n f]
   (lazy-seq
    (when (> n 0)
      (cons (f) (repeatedly (dec n) f))))))

(defn take-nth
  "Return a lazy sequence of every ``n`` th element of ``coll``\\.

  Return a stateful transducer if no collection is provided."
  ([n]
   (fn [rf]
     (let [v (volatile! 1)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (let [cur (vswap! v dec)]
            (if (zero? cur)
              (do (vreset! v n)
                  (rf result input))
              result)))))))
  ([n coll]
   (lazy-seq
    (when (seq coll)
      (if (<= n 0)
        (repeat (first coll))
        (cons (first coll)
              (take-nth n (drop (dec n) (rest coll)))))))))

(defn partition
  "Return a lazy sequence of partitions of ``coll`` of size ``n`` at offsets of
  ``step`` elements. If ``step`` is not given, steps of size ``n`` will be used and
  there will be no overlap between partitions. If ``pad`` is given, partition will pull
  elements from ``pad`` until the final sequence is equal to size ``n``\\. If there are
  fewer than ``n`` leftover elements in ``coll``\\, they will not be returned as a
  partial partition."
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (let [s (take n coll)]
        (when (= n (count s))
          (cons s (partition n step (drop step coll))))))))
  ([n step pad coll]
   (lazy-seq
    (when (seq coll)
      (let [s  (take n coll)
            ns (count s)
            s  (if (< ns n)
                 (concat s (take (- n ns) pad))
                 s)]
        (cons s (partition n step pad (drop step coll))))))))

(defn partition-all
  "Return a lazy sequence of partitions of ``coll`` of size ``n`` at offsets of
  ``step`` elements. If ``step`` is not given, steps of size ``n`` will be used and
  there will be no overlap between partitions. If there are leftover elements from
  ``coll`` which do not fill a full partition, then a partial partition will be
  returned, unlike :lpy:fn:`partition`.

  Return a stateful transducer if no collection is provided."
  ([n]
   (fn [rf]
     (let [lst (python/list)]
       (fn
         ([] (rf))
         ([result]
          (let [result (if (zero? (python/len lst))
                         result
                         (unreduced (rf result (vec lst))))]
            (rf result)))
         ([result input]
          (.append lst input)
          (if (< (python/len lst) n)
            result
            (let [v (vec lst)]
              (.clear lst)
              (rf result v))))))))
  ([n coll]
   (partition-all n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (cons (take n coll) (partition-all n step (drop step coll)))))))

(defn partition-by
  "Return a lazy sequence of partitions, splitting ``coll`` each time ``f`` returns a
  different value.

  Returns a stateful transducer if no collection is provided."
  ([f]
   (fn [rf]
     (let [prev (volatile! :basilisp.core.partition-by/default)
           lst  (python/list)]
       (fn
         ([] (rf))
         ([result]
          (let [result (if (zero? (python/len lst))
                         result
                         (unreduced (rf result (vec lst))))]
            (rf result)))
         ([result input]
          (let [v         (f input)
                prev-elem @prev]
            (cond
              (= prev-elem :basilisp.core.partition-by/default)
              (do (vreset! prev v)
                  (.append lst input)
                  result)

              (= prev-elem v)
              (do (.append lst input)
                  result)

              :else
              (let [elem (vec lst)]
                (vreset! prev v)
                (.clear lst)
                (.append lst input)
                (rf result elem)))))))))
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (let [elem  (first coll)
            felem (f elem)
            run   (cons elem (take-while #(= felem (f %)) (next coll)))]
        (cons run (partition-by f (seq (drop (count run) coll)))))))))

(defn distinct
  "Return a lazy sequence of the elements of ``coll``\\, removing duplicates.

  Return a stateful transducer if no collection is provided."
  ([]
   (fn [rf]
     (let [v (volatile! #{})]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (if (contains? @v input)
            result
            (do (vswap! v conj input)
                (rf result input))))))))
  ([coll]
   (let [coll-distinct (fn coll-distinct
                         [coll found]
                         (lazy-seq
                          (when (seq coll)
                            (let [e (first coll)]
                              (if-not (contains? found e)
                                (cons e (coll-distinct (rest coll) (conj found e)))
                                (coll-distinct (rest coll) found))))))]
     (coll-distinct coll #{}))))

(defn dedupe
  "Return a lazy sequence of the elements of ``coll``\\, removing consecutive
  duplicates.

  Return a stateful transducer if no collection is provided."
  ([]
   (fn [rf]
     (let [prev (volatile! :basilisp.core.dedupe/default)]
       (fn
         ([] (rf))
         ([result] (rf result))
         ([result input]
          (if (= @prev input)
            result
            (do
              (vreset! prev input)
              (rf result input))))))))
  ([coll]
   (let [coll-dedupe (fn coll-dedupe
                       [coll prev]
                       (lazy-seq
                        (when (seq coll)
                          (let [e (first coll)]
                            (if-not (= e prev)
                              (cons e (coll-dedupe (rest coll) e))
                              (coll-dedupe (rest coll) prev))))))]
     (lazy-seq
      (when-let [e (first coll)]
        (cons e (coll-dedupe (rest coll) e)))))))

(defn flatten
  "Flatten any combination of nested sequences (such as lists or vectors) into a single
  lazy sequence. Calling ``flatten`` on non-sequential values returns an empty
  sequence."
  [v]
  (lazy-seq
   (when (and (or (seq? v) (seqable? v)) (seq v))
     (let [e (first v)
           r (rest v)]
       (if (or (seq? e) (seqable? e))
         (concat (flatten e) (flatten r))
         (cons e (flatten r)))))))

(defn take-last
  "Return the last ``n`` items in ``coll`` in linear time."
  [n coll]
  (loop [c   (seq coll)
         rem (seq (drop n coll))]
    (if rem
      (recur (next c) (next rem))
      c)))

(defn min-key
  "Return the arg for which ``(k arg)`` is the smallest number. If multiple values
  return the same number, return the last."
  [k & args]
  (reduce* (fn [cur nxt]
             (if (<= (k nxt) (k cur))
               nxt
               cur))
           (first args)
           (rest args)))

(defn max-key
  "Return the arg for which ``(k arg)`` is the largest number. If multiple values
  return the same number, return the last."
  [k & args]
  (reduce* (fn [cur nxt]
             (if (>= (k nxt) (k cur))
               nxt
               cur))
           (first args)
           (rest args)))

(defn sort-by
  "Return a sorted sequence of the elements from ``coll`` using the ``cmp`` comparator
  on (``keyfn`` item)\\.

  The :lpy:fn:`compare` fn is used in if ``cmp`` is not provided."
  ([keyfn coll]
   (basilisp.lang.runtime/sort-by keyfn coll))
  ([keyfn cmp coll]
   (basilisp.lang.runtime/sort-by keyfn coll cmp)))

(defn zipmap
  "Return a map with the keys mapped to their corresponding indexed value in vals."
  [keys vals]
  (apply hash-map (interleave keys vals)))

(defn merge
  "Merge maps together from left to right as by :lpy:fn:`conj`. If a duplicate key
  appears in a map, the rightmost map's value for that key will be taken."
  [& maps]
  (when (some identity maps)
    (persistent!
     (reduce* #(conj! %1 %2)
              (transient {})
              maps))))

(defn merge-with
  "Merge maps together from left to right as by :lpy:fn:`conj`. If a
  duplicate key appears in a map, the resulting value of that key in
  the merged result will be the result of calling ``(f current-val
  next-val)``."
  [f & maps]
  (when (some identity maps)
    (reduce* (fn [acc kv]
               (let [k (first  kv)
                     v (second kv)]
                 (if (contains? acc k)
                   (update acc k f v)
                   (assoc acc k v))))
             (first maps) (apply concat (rest maps)))))

(defn trampoline
  "Trampoline ``f`` with starting arguments. If ``f`` returns a function (as determined
  by :lpy:fn:`fn?`), call its return value with no arguments, repeating that process
  until the return value is not a function."
  [f & args]
  (loop [ret (apply f args)]
    (if (fn? ret)
      (recur (ret))
      ret)))

(defn tree-seq
  "Return a lazy seq on the nodes of the tree-like data structure ``root``\\.

  ``branch?`` should be a function of a single argument which should return ``true``
  if a node might contain children (though it need not).

  ``children`` should be a function of one argument which should return a sequence of
  children of a node. ``children`` will only be called on a node if ``branch?`` returns
  ``true`` for that node."
  [branch? children root]
  (let [walk (fn walk
               [node]
               (lazy-seq
                (cons node
                      (when (branch? node)
                        (mapcat walk (children node))))))]
    (walk root)))

(def ^:dynamic *pmap-cpu-count*
  (* 2 (multiprocessing/cpu-count)))

(defn pmap
  "Apply ``f`` as by :lpy:fn:`map`, but in parallel using futures.

  This may only be useful for functions which are mainly blocked on IO, since
  Python threads do not allow parallel computation using threads.

  This function is not fully lazy. Chunks of elements from the input collection are
  grabbed eagerly to spawn Futures of ``f``\\. Elements after the chunk size in the
  input collection are grabbed lazily. The chunk size is set by
  :lpy:var:`*pmap-cpu-count*` and defaults to 2 times the number of CPU cores on the
  machine; the value of ``*pmap-cpu-count*`` is captured when ``pmap`` is first called,
  so it should be safe to bind in the initial calling thread. The sequence of futures
  is fed into a final (fully lazy) sequence to deref the Future and return its final
  value."
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (let [chunk-size *pmap-cpu-count*
            futs       (mapv #(future (f %)) (take chunk-size coll))]
        (concat (map deref futs)
                (pmap f (drop chunk-size coll)))))))
  ([f coll & colls]
   (lazy-seq
    (when (seq coll)
      (let [chunk-size *pmap-cpu-count*
            futs       (apply mapv (fn [& args]
                                     (future (apply f args)))
                              (take chunk-size coll)
                              (map #(take chunk-size %) colls))]
        (concat (map deref futs)
                (apply pmap f (drop chunk-size coll) (map #(drop chunk-size %) colls))))))))

(defn pcalls
  "Return a lazy seq of the result of executing the no arg functions ``fns``\\, which
  will be evaluated in parallel."
  [& fns]
  (pmap (fn [f] (f)) fns))

(defmacro pvalues
  "Returns a lazy seq of the result of ``exprs``\\, which will be evaluated in
  parallel."
  [& exprs]
  `(pcalls
    ~@(map (fn [expr]
             (concat '(fn* []) [expr]))
           exprs)))

(defn memoize
  "Retuns a fn that caches the results of the previous invocations of ``f``.

  The memoized fn keeps a cache of the mapping from arguments to results."
  [f]
  (let [cache (atom {})]
    (fn [& args]
      (if-let [kv (find @cache args)]
        (second kv)
        (let [res (apply f args)]
          (swap! cache assoc args res)
          res)))))

;;;;;;;;;;;;;;;;;;;;;;
;; Random Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(defn rand
  "Return a random real number between ``lower`` (default: 0) and ``upper``
  (default: 1) inclusive."
  ([] (random/uniform 0 1))
  ([upper] (random/uniform 0 upper))
  ([lower upper] (random/uniform lower upper)))

(defn rand-int
  "Return a random integer between ``lower`` (default: 0) and ``upper`` inclusive."
  ([upper]
   (rand-int 0 upper))
  ([lower upper]
   (cond
      (= upper lower) upper
      (< upper lower) (random/randrange upper lower)
      :else           (random/randrange lower upper))))

(defn rand-nth
  "Return a random element from ``coll``\\."
  [coll]
  (nth coll (rand-int (count coll))))

(defn random-uuid
  "Return a random type 4 UUID."
  []
  (uuid/uuid4))

(defn random-sample
  "Return elements from ``coll`` with the random probability of ``prob``\\.

  Return a transducer if no collection is provided."
  ([prob]
   (filter (fn [_] (< (rand) prob))))
  ([prob coll]
   (filter (fn [_] (< (rand) prob)) coll)))

(defn shuffle
  "Return a random permutation of ``coll``\\."
  [coll]
  (vec (random/sample (python/list coll) (count coll))))

;;;;;;;;;;;;;;;;;;;;
;; Utility Macros ;;
;;;;;;;;;;;;;;;;;;;;

(defn gensym
  "Generate a unique symbol name of the form ``prefix_#``\\. If no ``prefix`` is given,
  then ``v_`` will be used."
  ([]
   (gensym "v_"))
  ([prefix]
   (symbol (basilisp.lang.util/genname prefix))))

(def ^:dynamic *assert* true)

(defmacro assert
  "Evaluate ``expr`` and if it returns logical false, throw an ``AssertionError``\\.

  This macro does not emit an assertion if the dynamic Var :lpy:var:`*assert*` is set
  to a logical false value."
  ([expr]
   `(assert ~expr (str "Assert failed: " ~(str expr))))
  ([expr message]
   (when *assert*
     `(when-not ~expr
        (throw (python/AssertionError ~message))))))

(defmacro apply-method
  "Apply arguments to a method call. Equivalent to ``(apply (.-method o) args)``\\."
  [o method & args]
  `(apply (. ~o ~(symbol (str "-" method))) ~@args))

(defmacro apply-method-kw
  "Apply keyword arguments to a method call. Equivalent to ``(apply-kw (.-method o) ... args)``\\."
  [o method & args]
  `(apply-kw (. ~o ~(symbol (str "-" method))) ~@args))

(defmacro comment
  "Ignore all the forms passed, returning ``nil``\\."
  [& ^:no-warn-when-unused forms]
  nil)

(defmacro case
  "Switch on ``expr`` to return a matching clause from the set of input clauses.

  The input expression may be any valid Basilisp expression. A single default expression
  can follow the clauses, and its value will be returned if no clause matches.

  The clauses are pairs of a matching value and a return value. The matching values are
  not evaluated and must be compile-time constants. Symbols will not be resolved. Lists
  may be passed to match multiple compile time values to a single return value. The
  dispatch is done in constant time."
  [expr & clauses]
  (let [default (if (odd? (count clauses))
                  (last clauses)
                  :basilisp.core.case/no-default)
        pairs   (mapcat identity
                        (mapcat (fn [pair]
                                  (let [binding (first pair)
                                        expr    `(fn [] ~(second pair))]
                                    (if (list? binding)
                                      (map #(vector (list 'quote %) expr) binding)
                                      [[(list 'quote binding) expr]])))
                                (partition 2
                                           (if (= default :basilisp.core.case/no-default)
                                             clauses
                                             (drop-last clauses)))))
        expr-gs (gensym "expr")]
    `(let [~expr-gs ~expr
           m#       ~(apply hash-map pairs)]
       (if-not (contains? m# ~expr-gs)
         ~(if (= default :basilisp.core.case/no-default)
            `(throw (python/ValueError (str "No case clause matches " ~expr-gs)))
            `~default)
         ((get m# ~expr-gs))))))

(defmacro condp
  "Take a predicate and an expression and a series of clauses, call ``(pred test expr)``
  on the first expression for each clause. The result expression from first the set of
  clauses for which this expression returns a truthy value will be returned from the
  ``condp`` expression.

  Clauses can take two forms:

  - ``test-expr result-expr``
  - ``test-expr :>> result-fn`` where :>> is a keyword literal

  For the ternary expression clause, the unary ``result-fn`` will be called with the
  result of the predicate.

  A single final expression can be included at the end with no test expression which
  will be returned if no other clause matches the predicate. If no default is provided
  and no clause matches the predicate, a ``ValueError`` will be thrown."
  [pred expr & clauses]
  (when (seq clauses)
    (let [test-expr (first clauses)
          remaining (rest clauses)]
      (if (seq remaining)
        (let [result    (first remaining)
              remaining (rest remaining)]
          (cond
            (not (seq remaining)) `(throw
                                    (python/ValueError
                                     (str "Expected result expression for condp " {:test ~test-expr})))
            (= result :>>)        `(let [res# ~(list pred test-expr expr)]
                                     (if res#
                                       (~(first remaining) res#)
                                       (condp ~pred ~expr ~@(rest remaining))))
            :else                 `(if ~(list pred test-expr expr)
                                     ~result
                                     (condp ~pred ~expr ~@remaining))))
        test-expr))))

(defmacro declare
  "Declare the given ``names`` as Vars with no bindings, as a forward declaration."
  [& names]
  `(do
     ~@(map (fn [nm]
              `(def ~(vary-meta nm assoc :redef true)))
            names)))

(defmacro defonce
  "Define the Var named by ``name`` with root binding set to ``expr`` if and only if a
  ``name`` is not already defined as a Var in this namespace. ``expr`` will not be
  evaluated if the Var already exists."
  [name expr]
  `(let [v# (def ~name)]
     (when-not (.-is-bound v#)
       (def ~name ~expr))))

(defmacro for
  "Produce a list comprehension from 1 or more input sequences, subject to optional
  modifiers.

  For comprehensions consist of a vector of bindings, with optional modifiers, and a
  user specified body in an implicit ``do`` block.

  Symbol bindings look like standard ``let`` bindings. Values bound to symbols should be
  sequences or otherwise seqable. The body of the ``for`` comprehension will be executed
  with the given symbol bound to successive values of the sequence. If multiple sequences
  are bound to symbols, iteration will proceed in a nested fashion with latest sequences
  iterated first and earlier sequences iterated later (as nested ``for`` loops in
  procedural languages).

  For example, a simple non-nested for comprehension will yield::

    (for [x [1 2 3 4]] x) ;;=> [1 2 3 4]

  However, a nested comprehension will yield a longer sequence::

    (for [x (range 3)
          y [:a :b :c]]
      [x y])
    ;;=> ([0 :a] [0 :b] [0 :c]
          [1 :a] [1 :b] [1 :c]
          [2 :a] [2 :b] [2 :c])

  Each set of symbol bindings may be modified by applying trailing bindings denoted with
  keywords. The keyword modifiers are:

    :keyword ``:let [sym val]``: ``:let`` bindings work like any standard let bindings;
        destructuring is permitted; may refer to any previous bindings in other ``:let``
        modifiers or normal symbol bindings. Multiple pairs of bindings may appear in
        ``:let`` bindings.
    :keyword ``:when expr``: ``:when`` bindings are applied to the sequence roughly like
        in the core :lpy:fn:`filter` function; the expression is evaluated and if it is
        not falsey, yield the next value. As with ``:let`` bindings, the expression may
        refer to any previously bound names.
    :keyword ``:while expr``: ``:while`` bindings terminate the current sequence at the
        first point when ``expr`` returns a falsey value. ``:while`` bindings may refer
        to any previous bound names.

  Multiple keyword modifiers may be applied to the previous binding. Their effects will
  be applied at the point they appear in the bindings vector."
  [bindings & body]
  (cond
    (< (count bindings) 2)
    (throw (ex-info "for expression must have at least one pair of bindings"
                    {:bindings bindings}))

    (not (even? (count bindings)))
    (throw (ex-info "for expression must have an even number of bindings"
                    {:bindings bindings})))

  (let [;; Generate the body of a for binding iterator, applying any relevant
        ;; modifier clauses.
        ;;
        ;;   pairs      - pairs of modifiers/modifier binding values
        ;;   for-iter   - the gensym'ed name for the current lazy-seq function
        ;;   seq-arg    - the gensym'ed name of the seq arg input to the
        ;;                lazy-seq function
        ;;   inner-body - either: the body of the for comprehension specified
        ;;                by the user, or another nested lazy-seq function
        ;;   inner-body-is-seq? - if true, inner-body is nested lazy-seq function
        gen-iter-body (fn gen-iter-body
                        [pairs for-iter seq-arg inner-body inner-body-is-seq?]
                        (if (seq pairs)
                          (let [pair     (first pairs)
                                binding  (first pair)
                                val      (second pair)
                                mod-body (gen-iter-body (rest pairs) for-iter seq-arg inner-body inner-body-is-seq?)]
                            (cond
                              (= :when binding)
                              `(if ~val
                                 ~mod-body
                                 (recur (rest ~seq-arg)))

                              (= :while binding)
                              `(when ~val
                                 ~mod-body)

                              (= :let binding)
                              `(let [~@val]
                                 ~mod-body)

                              :else
                              (throw
                               (ex-info "invalid for modifier; use one of :let, :when, or :while"
                                        {:modifier binding}))))
                          ;; If the inner body is another sequence (presumably
                          ;; generated by gen-iter), concatenate it rather than
                          ;; cons, to ensure the output is flattened in the
                          ;; final output sequence.
                          (if inner-body-is-seq?
                            `(concat ~inner-body (~for-iter (rest ~seq-arg)))
                            `(cons ~inner-body (~for-iter (rest ~seq-arg))))))

        ;; Generate the outer function body of a for loop symbol binding lazy seq.
        ;;
        ;; Each symbol binding generates an anonymous lazy sequence function which
        ;; contains blocks for any modifier bindings which follow the initial
        ;; symbol binding.
        ;;
        ;; Additional symbol bindings are generated as inner bodies (which contain)
        ;; the ultimate inner body given by the user. Modifiers are handled by
        ;; gen-iter-body and applied to the body of the current lazy seq.
        ;;
        ;;  pairs - pairs of bindings; either symbol/seq pairs or modifier pairs
        gen-iter (fn gen-iter [pairs]
                   (if (seq pairs)
                     (let [for-iter (gensym "for")
                           seq-arg  (gensym "seq")
                           pair     (first pairs)
                           binding  (first pair)
                           val      (second pair)

                           ;; Split the remaining binding pairs into modifiers
                           ;; (which will be applied to this iterator) and additional
                           ;; bindings (which will be generated as new, inner iterators).
                           groups        (split-with (fn [pair]
                                                       (keyword? (first pair)))
                                                     (rest pairs))
                           mods          (first groups)
                           rest-bindings (second groups)

                           seq-body (gen-iter-body mods for-iter seq-arg (gen-iter rest-bindings) (seq rest-bindings))]
                       `(let [iter# (fn ~for-iter [seq#]
                                      (lazy-seq
                                       (loop [~seq-arg seq#]
                                         (when (seq ~seq-arg)
                                           (let [~binding (first ~seq-arg)]
                                             ~seq-body)))))]
                          (iter# ~val)))
                     `(do ~@body)))]
    (gen-iter (partition 2 bindings))))

(defmacro doseq
  "Repeatedly run the body (likely for side effects) with bindings as described in the
  :lpy:fn:`for` macro. Returns ``nil``\\."
  [bindings & body]
  `(dorun (for ~bindings ~@body)))

(defmacro ..
  "Expand into nested method calls on the returned objects from previous method calls.

  Successive method invocations are represented as successive lists::

    (.. \"abc\" (lower))              ;=> (. \"abc\" lower)
    (.. \"abc\" lower (split \",\"))  ;=> (. (. \"abc\" lower) split \",\")

  Methods invoked without arguments may be supplied as bare symbols."
  [x & method-calls]
  (if (seq method-calls)
    (let [joining (first method-calls)]
      `(..
        ~(if (seq? joining)
           (apply list '. x joining)
           (list '. x joining))
        ~@(rest method-calls)))
    x))

(defmacro memfn
  "Expands into a function that calls the method ``name`` on the first argument of the
  resulting function. If ``args`` are provided, the resulting function will have
  arguments of these names.

  This is a convenient way of producing a first-class function for a Python method."
  [name & args]
  `(fn [t# ~@args]
     (. t# ~name ~@args)))

(defmacro new
  "Create a new instance of ``class`` with ``args``\\.

  New objects may be created as any of::

    (new python/str *args)
    (new python.str *args)
    (new python.str. *args)

  This is compatibility syntax for Clojure, since Python (and therefore Basilisp) do not
  require the ``new`` keyword for object instantiation."
  [class & args]
  (cond
    (not (symbol? class))
    (throw
     (ex-info "Expected a class name as a symbol"
              {:class-name class}))

    (namespace class)
    (let [n  (name class)
          ns (namespace class)
          s  (symbol (str ns "."
                          (if (.endswith n ".")
                            n
                            (str n "."))))]
      `(~s ~@args))

    :else
    (let [n (name class)
          s (symbol (if (.endswith n ".")
                      n
                      (str n ".")))]
      `(~s ~@args))))

(defmacro with
  "Evaluate ``body`` within a ``try`` / ``except`` expression, binding the named
  expressions as per Python's context manager protocol spec (Python's ``with`` blocks)."
  [bindings & body]
  (let [binding (first bindings)
        expr    (second bindings)]
    `(let [obj#        ~expr
           ~binding    (. obj# ~'__enter__)
           hit-except# (volatile! false)]
       (try
         (let [res# ~@(if (nthnext bindings 2)
                        [(concat
                          (list 'with (vec (nthrest bindings 2)))
                          body)]
                        (list (concat '(do) body)))]
           res#)
         (catch python/Exception e#
           (vreset! hit-except# true)
           (when-not (. obj# (~'__exit__ (python/type e#) e# (.- e# ~'__traceback__)))
             (throw e#)))
         (finally
           (when-not @hit-except#
             (. obj# (~'__exit__ nil nil nil))))))))

(def ^{:doc   "Evaluate ``body`` within a ``try`` / ``except`` expression, binding the
               named expressions as per Python's context manager protocol spec (Python's
               ``with`` blocks)."
       :macro true}
  with-open with)

(def ^:private decimal-rounding-modes
  {"CEILING"      decimal/ROUND_CEILING
   "DOWN"         decimal/ROUND_DOWN
   "FLOOR"        decimal/ROUND_FLOOR
   "HALF_DOWN"    decimal/ROUND_HALF_DOWN
   "HALF_EVEN"    decimal/ROUND_HALF_EVEN
   "HALF_UP"      decimal/ROUND_HALF_UP
   "UP"           decimal/ROUND_UP
   "ZERO_FIVE_UP" decimal/ROUND_05UP})

(defn local-decimal-context
  "Return a :external:py:func:`decimal.localcontext` context manager which sets
  the precision and rounding behavior of :external:py:class:`decimal.Decimal` instances
  in the current thread as by :external:py:func:`decimal.setcontext`.

  .. warning::

     This function is an implementation detail of :lpy:fn:`with-precision` and it is not
     considered part of the public API. Use at your own peril."
  ([precision]
   (local-decimal-context precision nil))
  ([precision rounding]
   (let [current-ctx (.copy (decimal/getcontext))]
     (when-not (nil? rounding)
       (when-not (contains? decimal-rounding-modes rounding)
         (throw
          (python/ValueError
           (str "Unexpected rounding mode "
                rounding
                "; expected one of: "
                (.join ", " (keys decimal-rounding-modes)))))))
     (set! (.-prec current-ctx) precision)
     (when-let [rounding (decimal-rounding-modes rounding)]
       (set! (.-rounding current-ctx) rounding))
     (decimal/localcontext current-ctx))))

(defmacro with-precision
  "Set the current precision and (optionally) rounding behavior of
  :external:py:class:`decimal.Decimal` instances in the current thread while executing
  ``exprs``\\.

  Rounding should be a symbol and may be one of:
  - ``CEILING``
  - ``FLOOR``
  - ``UP``
  - ``DOWN``
  - ``HALF_UP``
  - ``HALF_EVEN``
  - ``HALF_DOWN``
  - ``ZERO_FIVE_UP`` (corresponding with Python's :external:py:obj:`decimal.ROUND_05UP`)"
  [precision & exprs]
  (let [rounding-kwarg (first exprs)
        rounding       (when (= rounding-kwarg :rounding)
                         (name (second exprs)))
        exprs          (if rounding
                         (nthrest exprs 2)
                         exprs)]
    `(with [ctx# (local-decimal-context ~precision ~@(filter identity [rounding]))]
           ~@exprs)))

(defn ^:inline get-thread-bindings
  "Return the current thread-local bindings as a map of Var/value pairs."
  []
  (basilisp.lang.runtime/get-thread-bindings))

(defn ^:inline push-thread-bindings
  "Takes a map of Var/value pairs and applies the given value to the Var in the current
  thread.

  This call should be accompanied with a :lpy:fn:`pop-thread-bindings` call in a
  ``try`` / ``finally`` block.

  This function is a very low level function and its use is discouraged in favor of a
  higher level construct like the :lpy:fn:`binding` macro."
  [bindings]
  (basilisp.lang.runtime/push-thread-bindings bindings))

(defn ^:inline pop-thread-bindings
  "Pop thread bindings set by a corresponding call to :lpy:fn:`push-thread-bindings`.
  This should not be called without a prior call to :lpy:fn:`push-thread-bindings` ."
  []
  (basilisp.lang.runtime/pop-thread-bindings))

(defmacro binding
  "Establish thread-local bindings for the vars given. The bindings are guaranteed to
  clear once execution passes outside the scope of this block."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [var-bindings (reduce* (fn [v pair]
                                (let [vvar (first pair)
                                      vval (second pair)]
                                  (conj v `(var ~vvar) vval)))
                              []
                              (partition 2 bindings))]
    `(do
       (push-thread-bindings (hash-map ~@var-bindings))
       (try
         ~@body
         (finally
           (pop-thread-bindings))))))

(defn with-bindings*
  "Execute the function ``f`` with the given arguments ``args`` (as by ``apply``\\) with
  the thread-local Var bindings specified in the Var/value map ``bindings-map``
  installed.

  The thread-local Var bindings will be popped after executing ``f`` in all cases.

  Returns the return value of ``f``\\."
  [bindings-map f & args]
  (push-thread-bindings bindings-map)
  (try
    (apply f args)
    (finally
      (pop-thread-bindings))))

(defmacro with-bindings
  "Execute the expressions given in the ``body`` with the thread-local Var bindings
  specified in the Var/value map ``bindings-map`` installed.

  The thread-local Var bindings will be popped after executing the body in all cases.

  Returns the value of ``body``\\."
  [bindings-map & body]
  `(with-bindings* ~bindings-map (fn [] ~@body)))

(defn bound-fn*
  "Return a function which executes ``f`` with the same thread-local Var bindings as
  were in effect when ``bound-fn*`` was called.

  ``f`` will be called with the same arguments as the returned function.

  Returns the return value of ``f``\\.

  This is primarily useful for creating functions which might need to run on a different
  thread, but which should have the same Var bindings in place as when it was defined."
  [f]
  (let [current-bindings (get-thread-bindings)]
    (fn [& args]
      (apply with-bindings* current-bindings f args))))

(defmacro bound-fn
  "Return a function with the same function tail (everything after ``fn`` when defining
  a function) which will be executed with the same thread-local Var bindings as were
  in effect when ``bound-fn`` was called.

  Returns the return value of the defined function.

  This is primarily useful for creating functions which might need to run on a different
  thread, but which should have the same Var bindings in place as when it was defined."
  [& fn-tail]
  `(bound-fn* (fn ~@fn-tail)))

(defn with-redefs-fn
  "Temporarily re-bind the given Var roots to the given values while executing the
  function ``f``, binding back to the original value afterwards.

  Changes to the Var roots will be visible in all threads.

  Note that Basilisp directly links Var references in compiled code by default for
  performance reasons. Direct linking can be disabled for all Vars during compilation
  by setting the ``--use-var-indirection`` compiler flag at startup. Direct linking
  can be disabled for individual Vars by setting the ``^:redef`` meta flag where the
  Var is ``def`` 'ed.

  ``with-redefs-fn`` will throw an Exception if directly linked Vars are given in the
  bindings."
  [bindings-map f]
  (when-not (or (:use-var-indirection *compiler-options*)
                (every? #(:redef (meta %)) (keys bindings-map)))
    (throw
     (ex-info (str "Cannot redef selected Vars; either apply ^:redef meta to Vars or "
                   "restart Basilisp with '--use-var-indirection false' compiler flag")
              {:unredefable-vars (remove #(:redef (meta %)) (keys bindings-map))})))
  (let [redef-vars (fn [m]
                     (doseq [v    m
                             :let [vvar (first v)
                                   vval (second v)]]
                       (.bind-root vvar vval)))
        originals  (reduce* (fn [m elem]
                              (let [vvar (first elem)]
                                (assoc m vvar (.-root vvar))))
                            {}
                            bindings-map)]
    (redef-vars bindings-map)
    (try
      (f)
      (finally
        (redef-vars originals)))))

(defmacro with-redefs
  "Temporarily re-bind the given Var roots to the given values while executing the
  body, binding back to the original value afterwards.

  Changes to the Var roots will be visible in all threads.

  Note that Basilisp directly links Var references in compiled code by default for
  performance reasons. Direct linking can be disabled for all Vars during compilation
  by setting the ``--use-var-indirection`` compiler flag at startup. Direct linking
  can be disabled for individual Vars by setting the ``^:redef`` meta flag where the
  Var is ``def`` 'ed.

  ``with-redefs`` will throw an Exception if directly linked Vars are given in the
  bindings."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [var-bindings (reduce* (fn [v pair]
                                (let [vvar (first pair)
                                      vval (second pair)]
                                  (conj v `(var ~vvar) vval)))
                              []
                              (partition 2 bindings))]
    `(with-redefs-fn
       ~(apply hash-map var-bindings)
       (fn []
         ~@body))))

(defn perf-counter
  "Implementation detail of :lpy:fn:`time`."
  []
  (py-time/perf-counter))

(defmacro time
  "Time the execution of ``expr``\\. Return the result of ``expr`` and print the time
  execution took in milliseconds."
  [expr]
  `(let [start# (perf-counter)]
     (try
       (do ~expr)
       (finally
         (println (* 1000 (- (perf-counter) start#)) "msecs")))))

;;;;;;;;;;;;;;;;;;;;;;
;; Threading Macros ;;
;;;;;;;;;;;;;;;;;;;;;;

(defmacro ->
  "Thread ``x`` through the ``forms``\\. Places x in the second position of the first
  form, and then the resulting expression into the second position of the second form,
  etc. Forms which are not lists will be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->
        ~(if (seq? joining)
           (apply list (first joining) x (rest joining))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro ->>
  "Thread ``x`` through the ``forms``\\. Places ``x`` in the last position of the first
  form, and then the resulting expression into the last position of the second form,
  etc. Forms which are not lists will be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->>
        ~(if (seq? joining)
           (concat joining (list x))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro some->
  "Thread ``x`` through the forms (as by :lpy:fn:`->`) until the resulting expression
  is ``nil`` or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(when-not (nil? ~x)
       (let [result# (-> ~x ~(first forms))]
         (some-> result# ~@(next forms))))
    x))

(defmacro some->>
  "Thread ``x`` through the forms (as by :lpy:fn:`->>`) until the resulting expression
  is ``nil`` or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(when-not (nil? ~x)
       (let [result# (->> ~x ~(first forms))]
         (some->> result# ~@(next forms))))
    x))

(defmacro cond->
  "Takes a test and form pair, threading ``x`` (as by :lpy:fn:`->`) through each form
  for which the corresponding test evaluates as ``true``\\. ``cond->`` does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (-> ~x ~(second clauses))
                ~x)]
       (cond-> e#
           ~@(nthnext clauses 2)))
    x))

(defmacro cond->>
  "Takes a test and form pair, threading ``x`` (as by :lpy:fn:`->>`) through each form
  for which the corresponding test evaluates as ``true``\\. ``cond->>`` does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (->> ~x ~(second clauses))
                ~x)]
       (cond->> e#
         ~@(nthnext clauses 2)))
    x))

(defmacro as->
  "Bind ``x`` to name and thread it through the ``forms``\\, replacing instances of
  ``name`` in forms with the threaded expression."
  [x name & forms]
  (if (seq forms)
    `(as->
         (let [~name ~x]
           ~(first forms))
         ~name
       ~@(next forms))
    x))

(defmacro doto
  "Evaluate ``x`` and thread it as the first argument in all of the given ``forms``\\.
  Returns ``x``\\.

  Useful for creating a Python class and calling methods on it for initialization
  before returning the class."
  [x & forms]
  (let [obj-gs (gensym "obj")]
    `(let [~obj-gs ~x]
       ~@(map (fn [form]
                (apply list (first form) obj-gs (rest form)))
              forms)
       ~obj-gs)))

;;;;;;;;;;;;;;;;;;;;;;
;; String Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(def char-escape-string
  "Return the escape string for an escape character, or ``nil`` if the provided
  character is not an escape character."
  {\newline   "\\n"
   \space     "\\ "
   \tab       "\\t"
   \formfeed  "\\f"
   \backspace "\\b"
   \return    "\\r"})

(def char-name-string
  "Return the name of an escape character, or ``nil`` if the provided character
  is not an escape character."
  {\newline   "newline"
   \space     "space"
   \tab       "tab"
   \formfeed  "formfeed"
   \backspace "backspace"
   \return    "return"})

(defn format
  "Format a string as by Python's ``%`` operator."
  [fmt & args]
  (if (= 1 (count args))
    (let [arg (first args)]
      (if (or (map? arg) (py-dict? arg))
        (operator/mod fmt (python/dict arg))
        (operator/mod fmt arg)))
    (operator/mod fmt (python/tuple args))))

(defn subs
  "Return a substring of ``s`` from the index ``start`` (inclusive) to index ``end``
  exclusive, or the end of the string if no ``end`` is supplied."
  ([s start]
   (subs s start nil))
  ([s start end]
   (when (> start (count s))
     (throw (python/IndexError "Start index out of range")))
   (when-not (nil? end)
     (when (> end (count s))
       (throw (python/IndexError "End index out of range")))
     (when (> start end)
       (throw (python/IndexError "Start index must be less than or equal to end index"))))
   (operator/getitem s (python/slice start end))))

;;;;;;;;;;;;;;;;;;;;
;; File Functions ;;
;;;;;;;;;;;;;;;;;;;;

(defn file-seq
  "Return a seq of :external:py:class:`pathlib.Path` objects for all files and
  subdirectories of ``dir``\\."
  [dir]
  (-> (pathlib/Path dir)
      (.resolve)
      (.rglob "*")
      (seq)))

;;;;;;;;;;;;;;;;;;;;;;
;; Output Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;

(def ^:dynamic *in*
  "The current value of *standard in* used by Basilisp.

  Note that binding a new value to this Var will not affect *Python* code (which
  generally respects :external:py:data:`sys.stdin`\\), though all Basilisp code should
  respect the value."
  sys/stdin)

(def ^:dynamic *out*
  "The current value of *standard out* used by Basilisp.

  Note that binding a new value to this Var will not affect *Python* code (which
  generally respects :external:py:data:`sys.stdout`\\), though all Basilisp code should
  respect the value."
  sys/stdout)

(def ^:dynamic *err*
  "The current value of *standard error* used by Basilisp.

  Note that binding a new value to this Var will not affect *Python* code (which
  generally respects :external:py:data:`sys.stderr`\\), though all Basilisp code should
  respect the value."
  sys/stderr)

(def ^:dynamic *print-sep* " ")

(def ^:dynamic *flush-on-newline*
  "Indicates whether the :lpy:fn:`prn` and :lpy:fn:`println` functions should flush the
  output stream after the last newline is written.

  Defaults to ``true``\\."
  true)

(defn ^:inline repr
  "Return the reader representation of an object."
  [x]
  (basilisp.lang.runtime/lrepr x))

(defn ^:inline read-line
  "Read the next line from the buffer currently bound to :lpy:var:`*in*`."
  []
  (.rstrip (.readline *in*)))

(defn ^:inline flush
  "Flush the buffer currently bound to :lpy:var:`*out*`."
  []
  (.flush *out*))

(defn newline
  "Write a platform specific newline to :lpy:var:`*out*`."
  []
  (.write *out* os/linesep)
  nil)

(defmacro with-in-str
  "Evaluate body with :lpy:var:`*in*` bound to a :external:py:class:`io.StringIO`
  instance containing the string ``s``\\."
  [s & body]
  `(binding [*in* (io/StringIO ~s)]
     ~@body))

(defmacro with-out-str
  "Capture the contents of text sent to :lpy:var:`*out*` and return the contents as a
  string."
  [& body]
  `(binding [*out* (io/StringIO)]
     ~@body
     (. *out* ~'getvalue)))

(defn pr
  "Print the arguments to the stream bound to :lpy:var:`*out*` in a format which is
  readable by the Basilisp reader. Multiple arguments will be separated by the string
  value bound to :lpy:var:`*print-sep*` (default is an ASCII space).

  Note that some dynamically created Basilisp forms (such keywords and symbols) and
  Python objects may not be readable again.

  It can be dynamically bound."
  {:dynamic true}
  ([] nil)
  ([x]
   (.write *out* (repr x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn prn
  "Same as :lpy:fn:`pr`, but appending a newline afterwards.

  Observes :lpy:var:`*flush-on-newline*`."
  ([]
   (.write *out* os/linesep)
   (when *flush-on-newline*
     (.flush *out*))
   nil)
  ([x]
   (let [stdout *out*]
     (.write stdout (repr x))
     (.write stdout os/linesep)
     (when *flush-on-newline*
       (.flush stdout))
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout os/linesep)
     (when *flush-on-newline*
       (.flush *out*))
     nil)))

(defn pr-str
  "Return the contents of calling :lpy:fn:`pr` on the ``args`` as a string."
  [& args]
  (with-out-str
    (apply pr args)))

(defn prn-str
  "Return the contents of calling :lpy:fn:`prn` on the ``args`` as a string."
  [& args]
  (with-out-str
    (apply prn args)))

(defn print
  "Print the arguments to the stream bound to :lpy:var:`*out*` in a format which is
  readable by humans. Multiple arguments will be separated by the string value bound to
  :lpy:var:`*print-sep*` (default is an ASCII space)."
  ([] (print ""))
  ([x]
   (.write *out* (basilisp.lang.runtime/lstr x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map basilisp.lang.runtime/lstr args))]
     (.write stdout (basilisp.lang.runtime/lstr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn println
  "Print the arguments to the stream bound to :lpy:var:`*out*` in a format which is
  readable by humans. ``println`` always prints a trailing newline. Multiple arguments
  will be separated by the string value bound to :lpy:var:`*print-sep*` (default is an
  ASCII space).

  Observes :lpy:var:`*flush-on-newline*`."
  ([] (println ""))
  ([x]
   (let [stdout *out*]
     (.write stdout (basilisp.lang.runtime/lstr x))
     (.write stdout os/linesep)
     (when *flush-on-newline*
       (.flush stdout))
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map basilisp.lang.runtime/lstr args))]
     (.write stdout (basilisp.lang.runtime/lstr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout os/linesep)
     (when *flush-on-newline*
       (.flush stdout))
     nil)))

(defn print-str
  "Return the contents of calling :lpy:fn:`print` on the ``args`` as a string."
  [& args]
  (with-out-str
    (apply print args)))

(defn println-str
  "Return the contents of calling :lpy:fn:`println` on the ``args`` as a string."
  [& args]
  (with-out-str
    (apply println args)))

(defn printf
  "Prints formatted output as per format.

  Does not append a newline."
  [fmt & args]
  (print (apply format fmt args)))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reading and Loading ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(def
  ^{:doc "The default data readers used in reader macros. Overriding or
          attempting to change the root binding of this var will not
          change the default data readers."}
  default-data-readers
  basilisp.lang.reader.ReaderContext/_DATA_READERS)

(def
  ^{:doc     "Data readers map which will be merged in to the default data
              reader map used by the reader. Mappings should be qualified
              symbols to functions taking one argument. The function will
              receive an unevaluated data structure and must return some
              value to the reader."
    :dynamic true}
  *data-readers*
  {})

(def
  ^{:doc     "Resolver used for resolving namespace aliases when reading
              forms using read, read-string, etc."
    :dynamic true}
  *resolver*
  basilisp.lang.runtime/resolve-alias)

(def ^{:doc "When no data reader is found for a tag and ``*default-data-reader-fn*``
            is non-``nil``, it will be called with two arguments, the tag and the value.
            If ``*default-data-reader-fn*`` is ``nil`` (the default), raise a
            ``basilisp.lang.compiler.SyntaxError``."
       :dynamic true}
  *default-data-reader-fn*
  nil)

(defn read-seq
  "Create an lazy sequence that will contain each form from the
  ``stream``\\. If no stream is specified, uses the value currently
  bound to :lpy:var:`*in*`. It is the callers responsibility to ensure
  that the stream resource is not closed before the sequence has been
  realised.

  Callers may bind a map of readers to :lpy:var:`*data-readers*` to customize
  the data readers used reading this string

  The stream must satisfy the interface of :external:py:class:`io.TextIOBase`\\, but
  does not require any pushback capabilities. The default
  ``basilisp.lang.reader.StreamReader`` can wrap any object implementing ``TextIOBase``
  and provide pushback capabilities.

  ``opts`` may include, among other things, the following keys:

  :keyword ``:init-line``:  optional initial line number for reader metadata;
      helpful for contextualizing errors for chunks of code read from a
      larger source document.
  :keyword ``:init-column``: optional initial column number for reader metadata;
      helpful for contextualizing errors for chunks of code read from a
      larger source document."
  ([stream]
   (read-seq {} stream))
  ([opts stream]
   (let [read (:read opts basilisp.lang.reader/read)]
      (seq (read stream
                 *resolver*
                 *data-readers*
                 (:eof opts)
                 (= (:eof opts) :eofthrow)
                 (:features opts)
                 (not= :preserve (:read-cond opts))
                 *default-data-reader-fn*
                 **
                 :init-line (:init-line opts)
                 :init-column (:init-column opts))))))

(defn read-string
  "Read a string of Basilisp code.

  Callers may bind a map of readers to :lpy:var:`*data-readers*` to customize the data
  readers used reading this string.

  Note that ``read-string`` should not be used to read string input from untrusted
  sources. For reading EDN input from untrusted sources, instead consider using
  :lpy:ns:`basilisp.edn`."
  ([s]
   (read-string {:eof :eofthrow} s))
  ([opts s]
   (first (read-seq (assoc opts :read basilisp.lang.reader/read-str) s))))

(defn read
  "Read the next form from the ``stream``\\. If no stream is specified, uses the value
  currently bound to :lpy:var:`*in*`.

  Callers may bind a map of readers to :lpy:var:`*data-readers*` or a default data
  reader function to :lpy:var::`*default-data-reader-fn*` to customize the data
  readers used reading this string

  The stream must satisfy the interface of :external:py:class:`io.TextIOBase`\\, but
  does not require any pushback capabilities. The default
  ``basilisp.lang.reader.StreamReader`` can wrap any object implementing ``TextIOBase``
  and provide pushback capabilities."
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([opts stream]
   (first (read-seq opts stream)))
  ([stream eof-error? eof-value]
   (first (read-seq {:eof (if eof-error? :eofthrow eof-value)} stream))))

(defn eval
  "Evaluate a form (not a string) and return its result.

  If ``namespace`` is given, evaluate code in that Namespace. Otherwise, the current
  value of :lpy:var:`*ns*` is used."
  ([form]
   (eval form *ns*))
  ([form namespace]
   (let [ctx (basilisp.lang.compiler.CompilerContext. "<Eval Input>")]
     (basilisp.lang.compiler/compile-and-exec-form form
                                                   ctx
                                                   namespace))))

(defn load-reader
  "Read and evaluate the set of forms in the :external:py:class:`io.TextIOBase` instance
  ``reader``.

  Most often this is useful if you want to split your namespace across multiple source
  files. :lpy:fn:`require` will try to force you into a namespace-per-file paradigm
  (which is generally preferred, but not right in every scenario). ``load-reader`` will
  load the contents of the named file directly into the current namespace.

  Note that unlike ``require``\\, files loaded by ``load-reader`` will not be cached and
  will thus incur compilation time on subsequent loads."
  [reader]
  (let [src (some-> (python/getattr reader "name" nil)
                    (pathlib/Path)
                    (.resolve)
                    (python/str))
        ctx (basilisp.lang.compiler.CompilerContext. (or src "<Load Input>"))]
    (last
     (for [form (read-seq {} reader)]
       (basilisp.lang.compiler/compile-and-exec-form form
                                                     ctx
                                                     *ns*)))))

(defn load-file
  "Read and evaluate the set of forms contained in the file located at ``path``.

  Most often this is useful if you want to split your namespace across multiple source
  files. :lpy:fn:`require` will try to force you into a namespace-per-file paradigm
  (which is generally preferred, but not right in every scenario). ``load-file`` will
  load the contents of the named file directly into the current namespace.

  Note that unlike ``require``\\, files loaded by ``load-file`` will not be cached and
  will thus incur compilation time on subsequent loads."
  [path]
  (with-open [f (python/open path ** :mode "r")]
    (load-reader f)))

(defn- resolve-load-path
  "Resolve load ``path`` relative to the current namespace, or, if it
  begins with \"/\", relative to the syspath, and return it.

  Throw a :external:py:exc:`FileNotFoundError` if the ``path`` cannot be resolved."
  [path]
  (let [path-rel (if (.startswith path "/")
                   path
                   (let [path-parent (-> (name *ns*)
                                         (.rsplit "." 1)
                                         (first)
                                         (.replace "." "/"))]
                     (str "/" path-parent "/" path)))
        path-rel (.replace path-rel "-" "_")]
    (if-let [path-full (some (fn [p]
                               (let [pf (str p path-rel)]
                                 (when (os.path/exists (str pf ".lpy"))
                                   pf)))
                             sys/path)]
      path-full
      (throw (python/FileNotFoundError (str "Could not locate `"
                                            (subs path-rel 1) ".lpy` on syspath."))))))

(defn load
  "Read and evaluate the set of forms contained in the files identified by ``paths``.

  The provided paths should not include a file suffix.

  Most often this is useful if you want to split your namespace across multiple source
  files. :lpy:fn:`require` will try to force you into a namespace-per-file paradigm
  (which is generally preferred, but not right in every scenario). ``load`` will load
  the contents of the named file directly into the current namespace.

  A path is interpreted relative to the syspath if it starts with a
  forward slash or relative to the root directory of the current
  namespace otherwise.

  Note that unlike ``require``\\, files loaded by ``load`` will not be cached and will
  thus incur compilation time on subsequent loads.

  This function is provided for compatibility with Clojure. Users should prefer
  :lpy:fn:`load-file` (or perhaps :lpy:fn:`load-reader` or :lpy:fn:`load-string`) to
  this function."
  [& paths]
  (last (for [path (seq paths)]
          (load-file (str (resolve-load-path path) ".lpy")))))

(defn ^:inline load-string
  "Read and evaluate the set of forms contained in the string ``s``\\."
  [s]
  (load-reader (io/StringIO s)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reference (Atom/Namespace/Var) Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn alter-meta!
  "Atomically swap the metadata on reference ``o`` to the result of ``(apply f m args)``
  where ``m`` is the current metadata of ``o``\\. ``f`` should be free of side effects.
  References include atoms, namespaces, and vars."
  [o f & args]
  (apply-method o alter-meta f args))

(defn ^:inline reset-meta!
  "Atomically swap the metadata on reference ``o`` to meta. References include atoms,
  namespaces, and vars."
  [o meta]
  (.reset-meta o meta))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Ref (Atom/Var) Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline add-watch
  "Add a watch function ``wf`` identified by the key ``k`` to the ref (Atom or Var).

  Watch functions should be functions of four arguments: the key associated with the
  watch function, the ref object, the old value, and the new value.

  Watch functions will be called synchronously. Note that the value of a ref may have
  changed by the time a watch function is called, so watch functions should use the
  old and new state arguments rather than attempting to :lpy:fn:`deref` the ref.

  Watch functions cannot prevent state changes to a ref, regardless of the result of
  the watch function.

  Watch function keys are used to identify watches and may be used to remove a watch
  from a ref (using :lpy:fn:`remove-watch`), but are otherwise unused by the watch
  feature.

  Watches for a Var are only notified for Var root changes, not thread-local bindings."
  [ref k wf]
  (.add-watch ref k wf))

(defn ^:inline remove-watch
  "Remove the watch function identified by ``k`` from the ref (Atom or Var), if it
  exists. Returns the ref."
  [ref k]
  (.remove-watch ref k))

(defn ^:inline get-validator
  "Return the validator defined for the ref (Atom or Var), or ``nil`` if no validator is
  defined."
  [ref]
  (.get-validator ref))

(defn ^:inline set-validator!
  "Set the validator function for the ref (Atom or Var).

  Validator functions should be side-effect free functions of one argument: the proposed
  new value of the ref. The validator should either return false or throw an error if
  the ref value is invalid.

  ``nil`` may be passed to remove the validator for a ref.

  If the existing ref value is not valid according to ``vf``, an exception will be
  thrown and the new validator function will not be applied."
  [ref vf]
  (.set-validator ref vf))

;;;;;;;;;;;;;;;;;;;
;; Var Utilities ;;
;;;;;;;;;;;;;;;;;;;

(defn alter-var-root
  "Atomically alter the Var root by calling ``(apply f root args)`` and setting the root
  as the result."
  [v f & args]
  (apply-method v alter-root f args))

(defn ^:inline find-var
  "Return the Var named by namespace-qualified ``sym`` if it exists, or ``nil``
  otherwise."
  [sym]
  (basilisp.lang.runtime.Var/find sym))

(defn thread-bound?
  "Return ``true`` if vars are thread-bound, which implies that a ``set!`` will succeed.
  Returns ``true`` if no vars are given."
  [& vars]
  (loop [v (first vars)
         r (rest vars)]
    (if-not v
      true
      (if (.-is-thread-bound v)
        (recur (first r) (rest r))
        false))))

(defn var-get
  "Return the value inside the Var. Return thread local bindings if they exist,
  otherwise, return the root binding."
  [v]
  @v)

(defn var-set
  "Set the binding of the Var. Must be thread-local."
  [v val]
  (if (thread-bound? v)
    (do
      (.set-value v val)
      val)
    (throw
     (ex-info "Cannot set non-thread-bound Var binding" {:var v}))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:inline all-ns
  "Return a sequence of all namespaces."
  []
  (vals (basilisp.lang.runtime.Namespace/ns-cache)))

(defn ^:inline find-ns
  "Return the namespace named by ``sym`` if it exists, or ``nil`` otherwise."
  [sym]
  (basilisp.lang.runtime.Namespace/get sym))

(defn the-ns
  "If ``v`` is a symbol, return the Namespace named by that symbol if it exists. If
  ``v`` is a Namespace, return it. Otherwise, throw an exception."
  [v]
  (cond
    (symbol? v)
    (.get basilisp.lang.runtime/Namespace v)

    (instance? basilisp.lang.runtime/Namespace v)
    v

    :else
    (throw
     (ex-info "Expected a Symbol or a Namespace"
              {:value v
               :type  (python/type v)}))))

(defn intern
  "Finds or creates a Var in ``ns`` (which may be either a namespace or symbol), setting
  the root binding to ``val``\\, if provided. The namespace must exist. Return the Var."
  ([ns name]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name ** :meta {:ns ns :name name})]
     (.intern ns name v)))
  ([ns name val]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name ** :meta {:ns ns :name name})]
     (.bind-root v val)
     (.intern ns name v))))

(defn ^:inline create-ns
  "Create a Namespace with the name ``ns-sym`` or return the existing one if it already
  exists."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/get-or-create ns-sym))

(defn ^:inline remove-ns
  "Remove the namespace named by the symbol."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/remove ns-sym))

(defn ^:inline ns-name
  "Return the name of the namespace, a symbol."
  [ns]
  (.-name ns))

(defn ns-aliases
  "Return a map of Basilisp namespaces which are aliased in the current namespace."
  [ns]
  (reduce* (fn [m entry]
             (let [alias     (key entry)
                   namespace (symbol (name (val entry)))]
               (if (= alias namespace)
                 m
                 (assoc m alias namespace))))
           {}
           (.-aliases (the-ns ns))))

(defn ^:inline ns-imports
  "Return a set of Python modules which are imported in the current namespace."
  [ns]
  (.-imports (the-ns ns)))

(defn ^:inline ns-interns
  "Return a map of symbols to Vars which are interned in the current namespace."
  [ns]
  (.-interns (the-ns ns)))

(defn ^:inline ns-unalias
  "Remove the alias for the symbol ``sym`` from ``ns``\\. Return ``nil``\\."
  [ns sym]
  (.remove-alias (the-ns ns) sym))

(defn ^:inline ns-unmap
  "Remove the mapping for the symbol ``sym`` from ``ns``\\. Return ``nil``\\."
  [ns sym]
  (.unmap (the-ns ns) sym))

(defn ns-publics
  "Return a map of symbols to public Vars which are interned in the current namespace.

  Public vars are Vars which are declared without ``:private`` metadata."
  [ns]
  (reduce* (fn [m entry]
             (if (:private (meta (val entry)))
               m
               (assoc m (key entry) (val entry))))
           {}
           (ns-interns (the-ns ns))))

(defn ^:inline ns-refers
  "Return a map of symbols to Vars which are referred in the current namespace."
  [ns]
  (.-refers (the-ns ns)))

(defn ns-map
  "Return a map of all the mapped symbols in the namespace.

  Includes the return values of :lpy:fn:`ns-interns` and :lpy:fn:`ns-refers` in one
  map."
  ([] (ns-map *ns*))
  ([ns]
   (let [resolved-ns (the-ns ns)]
     (merge
      (ns-interns resolved-ns)
      (ns-refers resolved-ns)))))

(defn ^:inline ns-resolve
  "Return the Var which will be resolved by the symbol in the given namespace."
  [ns sym]
  (basilisp.lang.runtime/resolve-var sym (the-ns ns)))

(defn ^:inline resolve
  "Return the Var which will be resolved by the symbol in the namespace currently bound
  to :lpy:var:`*ns*`."
  [sym]
  (ns-resolve *ns* sym))

(defmacro import
  "Import Python modules by name.

  Modules may be specified either as symbols naming the full module path or as a
  vector taking the form ``[full.module.path :as alias]``\\.

  Note that unlike in Python, ``import`` ed Python module names are always hoisted to
  the current Namespace, so imported names will be available within a Namespace even
  if the ``import`` itself occurs within a function or method.

  Use of ``import`` directly is discouraged in favor of the ``:import`` directive in
  the :lpy:fn:`ns` macro.

  Importing and attempting to reference an import within a top level form other than
  a :lpy:form:`do` is a compile-time error because the compiler cannot verify that
  the imported name exists. In cases where you may need to import and reference an
  imported symbol within a single top-level form, you can use
  :lpy:fn:`importing-resolve`."
  [& modules]
  ;; We need to use eval here, because there could have been an ns
  ;; switch inside an eval earlier, and although *ns* is correctly set
  ;; to the new ns, the global python namespace can still refer to the
  ;; old python global ns where the import would have been evaluated
  ;; otherwise.
  (let [form `(import* ~@modules)]
    `(eval '~form  *ns*)))

(defn ^:private rewrite-clojure-libspec
  "Rewrite libspecs which point to namespaces starting with 'clojure.' to use a
  Basilisp alternative if the original library cannot be found on the import path.

  If a matching library is found, configure an alias to be original requested
  namespace name."
  [libspec]
  (let [ns-name (name (:namespace libspec))]
    (if (and (.startswith ns-name "clojure.")
             (not
              (try
                (importlib.util/find-spec (basilisp.lang.util/munge ns-name))
                (catch python/ModuleNotFoundError _
                  nil))))
      (let [basilisp-ns-name (str (.replace ns-name "clojure" "basilisp" 1))]
        ;; Add the original name as an alias if no alias was given
        ;;
        ;; If an `:as` alias is not given, we'll just use that. Otherwise, we use
        ;; `:original-namespace` to let the require machinery know to set an
        ;; extra alias here.
        (cond-> (assoc libspec :namespace (symbol basilisp-ns-name))
          (not (:as libspec)) (assoc :as (symbol ns-name))
          (:as libspec)       (assoc :original-namespace (symbol ns-name))))
      libspec)))

(defn ^:private require-libspec
  "Convert a user-specified require libspec into a map with well-defined keys.

  Required keys:

  - ``:namespace ns-sym`` a symbol naming the Namespace being required

  Optional keys:

  - ``:as ns-alias`` a symbol which will alias the Namespace when required (if given)
  - ``:as-alias ns-alias`` a symbol which will alias the Namespace when required; if
    the namespace does not exist, it will be created as an empty namespace; if it does
    exist, it will not be loaded
  - ``:refer [sym1, sym2]`` a sequence of symbols naming Vars to refer
  - ``:refer :all`` if every Var should be referred
  - ``:only [sym1, sym2]`` a sequence of symbols naming Vars to refer
  - ``:exclude [sym1, sym2]`` to refer all except the specified symbols
  - ``:rename {sym1 new-sym1}`` to rename all the specified symbols to the given new name

  If a namespace name beginning with 'clojure.' does not exist on the import path,
  Basilisp will attempt to load a corresponding namespace starting with 'basilisp.'
  automatically, aliasing the imported namespace as the requested namespace name.
  This should allow for automatically importing Clojure's included core libraries such
  as ``clojure.string``."
  [req]
  (rewrite-clojure-libspec
   (cond
     (vector? req) (merge {:namespace (first req)}
                          (apply hash-map (rest req)))
     (symbol? req) {:namespace req}
     :else         (throw
                    (ex-info "Invalid libspec for require"
                             {:value req})))))

(def ^:private require-flags #{:reload :reload-all})

(defn ^:private libspecs-and-flags
  "Return a vector of ``[libspecs flags]``."
  [req]
  (let [groups (group-by #(if (contains? require-flags %)
                            :flags
                            :libspecs)
                         req)]
    [(:libspecs groups) (set (:flags groups))]))

(defn ^:private require-lib
  "Require the library described by ``libspec`` into the Namespace ``requiring-ns``\\
  subject to the provided ``flags``."
  [requiring-ns libspec flags]
  (let [required-ns-sym  (:namespace libspec)
        existing-ns      (find-ns required-ns-sym)]
    (cond
      #?@(:lpy39+
          [(and existing-ns (contains? flags :reload-all))
           (.reload-all (the-ns required-ns-sym))])

      (and existing-ns (contains? flags :reload))
      (.reload (the-ns required-ns-sym))

      :else
      (do
        ;; In order to enable direct linking of Vars as Python variables, required
        ;; namespaces must be `require*`ed into the namespace. That's not possible
        ;; to do without a macro, so we're using this hacky approach to eval the
        ;; code directly (which will effectively add it to the root namespace module).
        (eval (list 'require*
                    (if-let [ns-alias (:as libspec)]
                      [required-ns-sym :as ns-alias]
                      required-ns-sym))
              requiring-ns)
        ;; Add a special alias for the original namespace (e.g. `clojure.*`), if we
        ;; rewrote the namespace on require.
        (when-let [original-ns (:original-namespace libspec)]
          (.add-alias requiring-ns (the-ns required-ns-sym) original-ns))
        ;; If an `:as-alias` is requested, apply that as well.
        (when-let [as-alias (:as-alias libspec)]
          (.add-alias requiring-ns (the-ns required-ns-sym) as-alias))))
    ;; Reset the namespace to the requiring namespace, since it was likely changed
    ;; during the require process
    (set! *ns* requiring-ns)))

(defn ^:private refer-filtered-interns
  "Return a map of symbols to interned Vars in the Namespace ``referred-ns`` subject
  to the filters described in ``libspec``\\."
  [referred-ns libspec]
  (when (= :all (:refer libspec))
    (throw
     (ex-info "cannot specify :refer :all for refer; use (refer 'ns-sym) instead"
              {:libspec libspec})))
  (let [only    (set (or (:refer libspec) (:only libspec)))
        exclude (set (:exclude libspec))
        rename  (get libspec :rename {})]
    (cond->> (ns-interns referred-ns)
      (seq only)    (filter (fn [entry]
                              (contains? only (key entry))))
      (seq exclude) (remove (fn [entry]
                              (contains? exclude (key entry))))
      (seq rename)  (reduce* (fn [m entry]
                               (if (rename (key entry))
                                 (assoc m (rename (key entry)) (val entry))
                                 m))
                             {}))))

(defn ^:private refer-lib
  "Refer Vars into ``requiring-ns`` as described by ``libspec``\\.

  This function assumes the referred-to Namespace has already been loaded by
  ``require-lib``\\."
  [requiring-ns libspec]
  (let [referred-ns (the-ns (:namespace libspec))]
    (if-not (some #(contains? libspec %) [:refer :only :exclude :rename])
      (.refer-all requiring-ns referred-ns)
      (doseq [intern-entry (refer-filtered-interns referred-ns libspec)]
        (let [sym (key intern-entry)
              var (val intern-entry)]
          (.add-refer requiring-ns sym var))))))

(defn require
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:

  - symbols, which name fully qualified namespaces
  - vectors, which take the form ``[namespace-symbol & opts]``

  Vector libspec arguments must be one of:

  - ``:as name`` which will alias the imported namespace to the symbol name
  - ``:as-alias name`` which will alias the namespace to the symbol name but not
    require the namespace, which can be useful for namespaces used primarily for
    keywords; the namespace need not exist at all; can be combined with ``:as``
  - ``:refer [& syms]`` which will refer syms in the local namespace directly
  - ``:refer :all`` which will refer all symbols from the namespace directly

  Arguments may also be flags, which are optional. Flags are keywords. The following
  flags are supported:

  - ``:reload`` if provided, attempt to reload the namespace
  - ``:reload-all`` if provided, attempt to reload all named namespaces and the
    namespaces loaded by those namespaces as a directed graph

  Use of ``require`` directly is discouraged in favor of the ``:require`` directive in
  the :lpy:fn:`ns` macro.

  Requiring and attempting to reference a required namespace within a top level form
  other than a :lpy:form:`do` is a compile-time error because the compiler cannot
  verify that the required name exists. In cases where you may need to require and
  reference a required symbol within a single top-level form, you can use
  :lpy:fn:`requiring-resolve`.

  .. warning::

     Reloading namespaces has many of the same limitations described for
     :external:py:func:`importlib.reload`. Below is a non-exhaustive set of
     limitations of reloading Basilisp namespace:

     - Vars will be re-``def``'ed based on the current definition of the underlying
       file. If the file has not changed, then the namespace file will be reloaded
       according to the current :ref:`namespace_caching` settings. If a Var is
       removed from the source file, it will not be removed or updated by a reload.
     - References to objects from previous versions of modules (particularly those
       external to the namespace) are not rebound by reloading. In Basilisp code,
       this problem can be limited by disabling :ref:`inlining` and
       :ref:`direct_linking`.
     - Updates to type or record definitions will not be reflected to previously
       instantiated objects of those types."
  [& args]
  (let [current-ns *ns*
        groups     (libspecs-and-flags args)
        libspecs   (first groups)
        flags      (second groups)]
    (doseq [libspec (map require-libspec libspecs)]
      (if (and (:as-alias libspec) (not (:as libspec)))
        (let [alias-target (or (find-ns (:namespace libspec))
                               (create-ns (:namespace libspec)))]
          (.add-alias current-ns alias-target (:as-alias libspec)))
        (do
          (require-lib current-ns libspec flags)

          ;; Add refers
          (let [new-ns    (the-ns (:namespace libspec))
                refer-opt (:refer libspec)]
            (cond
              (= :all refer-opt)
              (.refer-all current-ns new-ns)

              (seq refer-opt)
              (let [new-ns-interns (ns-interns new-ns)]
                (doseq [var-sym refer-opt]
                  (let [var (get new-ns-interns var-sym)]
                    (.add-refer current-ns var-sym var))))

              :else nil)))))
    nil))

(defn refer
  "Refer Vars from the namespace named by ``ns-sym``\\, subject to the filters
  specified.

  Supported filters:

  - ``:only [sym1 sym2]`` to only refer the specified symbols
  - ``:exclude [sym1, sym2]`` to refer all except the specified symbols
  - ``:rename {sym1 new-sym1}`` to rename all the specified symbols to the given new
    name

  Use of ``refer`` directly is discouraged in favor of the ``:refer`` modifier in the
  ``:require`` directive of the :lpy:fn:`ns` macro or the ``:use`` directive of the
  ``ns`` macro."
  [ns-sym & filters]
  (let [current-ns *ns*
        groups     (group-by #(if (contains? require-flags %)
                                :flags
                                :filters)
                             filters)]
    ;; It is necessary to first require the Namespace directly, otherwise
    ;; when refer attempts to load the Namespace later, it will fail.
    (require-lib current-ns
                 (require-libspec ns-sym)
                 (set (:flags groups)))
    (->> (:filters groups)
         (apply vector ns-sym)
         (require-libspec)
         (refer-lib current-ns))))

(def refer-basilisp
  "Refer Vars from ``basilisp.core`` using the same filter syntax as :lpy:fn:`refer`."
  (partial refer 'basilisp.core))

(def refer-clojure
  "Compatibility layer with JVM Clojure, which points to :lpy:fn:`refer-basilisp`."
  refer-basilisp)

(defn use
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:

  - symbols, which name fully qualified namespaces
  - vectors, which take the form ``[namespace-symbol & opts]``

  ``use`` is like :lpy:fn:`require` which also refers all Vars from the requiring
  Namespace afterwards. Libspecs passed to ``use`` may include filters as defined in
  :lpy:fn:`refer` to narrow down the referred Vars.

  Supported filters:

  - ``:only [sym1 sym2]`` to only refer the specified symbols
  - ``:exclude [sym1, sym2]`` to refer all except the specified symbols
  - ``:rename {sym1 new-sym1}`` to rename all the specified symbols to the given new name

  Use of ``use`` directly is discouraged in favor of the ``:use`` directive in the
  :lpy:fn:`ns` macro."
  [& args]
  (let [current-ns *ns*
        groups     (libspecs-and-flags args)
        libspecs   (first groups)
        flags      (second groups)]
    (doseq [libspec (map require-libspec libspecs)]
      ;; Remove the :refer key to avoid having require-lib
      ;; perform a full :refer, instead we'll use refer-lib
      (require-lib current-ns
                   (dissoc libspec :refer)
                   flags)
      (refer-lib current-ns libspec))
    nil))

(defonce ^:dynamic *loaded-libs*
  (atom #{}))

(defn loaded-libs
  "Return a set of all loaded Basilisp namespace names as symbols.

  Namespace names are only added to this list if they appear in an :lpy:fn:`ns` macro."
  []
  @*loaded-libs*)

(defmacro ns
  "Use this namespace pre-amble at the top of every namespace to declare the namespace
  name and import necessary Python modules and require Basilisp namespaces.

  You may include an optional docstring for the namespace to describe its purpose. The
  docstring will be applied as the ``:doc`` key on the namespace metadata map.

  Example::

    (ns my.namespace
       \"My namespace with code\"
       (:refer-basilisp :exclude [get])
       (:require
         [basilisp.string :as str])
       (:use
         [basilisp.set :only [intersection]])
       (:import inspect))

  Flags and contents of each of the various sections are detailed further at each of
  their respective function definitions.

   - ``:refer-basilisp`` (``:refer-clojure`` is also accepted) controls how names from
     :lpy:ns:`basilisp.core` are exposed in the namespace. Refer to :lpy:fn:`refer` for
     usage.
   - ``:require`` imports other Basilisp namespaces. Refer to :lpy:fn:`require` for
     usage.
   - ``:use`` is a variant of ``:require``, although ``:require`` is preferred in most
     cases. See :lpy:fn:`use` for usage.
   - ``:import`` imports Python modules and packages. Refer to :lpy:fn:`import` for
     usage.

  Use of the ``ns`` macro to control requires and imports is recommended in all cases.
  The various functions that ``ns`` delegates to and whose documentation are referred
  to above are generally useful for interactive usage at the REPL but not appropriate
  for usage in a larger application."
  [name & opts]
  (when-not (and (symbol? name) (nil? (namespace name)))
    (throw (ex-info "Namespace name must be a non-namespaced symbol"
                    {:name name})))
  (let [doc  (when (string? (first opts))
               (first opts))
        opts (if doc (rest opts) opts)
        opts (reduce* (fn [m opt]
                        (let [opt-name (first opt)
                              options  (rest opt)]
                          (when-not (keyword? opt-name)
                            (throw (ex-info "Namespace option must be a keyword"
                                            {:option opt-name})))
                          (assoc m opt-name (vec options))))
                      {}
                      opts)

        refer-filters (when-let [filters (or (:refer-basilisp opts)
                                             (:refer-clojure opts))]
                        (map #(list 'quote %) filters))
        requires      (when (:require opts)
                        `(require ~@(map #(list 'quote %) (:require opts))))
        uses          (when (:use opts)
                        `(use ~@(map #(list 'quote %) (:use opts))))
        imports       (when (:import opts)
                        (map (fn [v]
                               `(import ~v))
                             (:import opts)))]
    `(^:use-var-indirection do
       (in-ns (quote ~name))
       (swap! *loaded-libs* conj (quote ~name))
       ~(when doc
          `(alter-meta! (the-ns (quote ~name)) assoc :doc ~doc))
       (refer-basilisp ~@refer-filters)
       ~requires
       ~uses
       ~@imports)))

(defn importing-resolve
  "Resolve the namespaced symbol ``sym`` as a Python module member. If resolution fails,
  attempts to import ``sym`` 's namespace (as by :lpy:fn:`import`\\) before resolving
  again."
  [sym]
  (if (qualified-symbol? sym)
    (let [mod-name   (basilisp.lang.util/munge (namespace sym))
          obj-name   (basilisp.lang.util/munge (name sym))
          py-resolve #(some-> (get sys/modules mod-name)
                              (python/getattr obj-name nil))]
      (or (py-resolve)
          (do (eval `(import* ~(symbol (namespace sym))) *ns*)
              (py-resolve))))
    (throw
     (ex-info "Cannot resolve an unqualified symbol"
              {:sym sym}))))

(defn requiring-resolve
  "Resolve the namespaced symbol ``sym`` as by :lpy:fn:`resolve`\\. If resolution fails,
  attempts to require ``sym`` 's namespace (as by :lpy:fn:`require`\\) before resolving
  again."
  [sym]
  (if (qualified-symbol? sym)
    (or (resolve sym)
        (do (require (symbol (namespace sym)))
            (resolve sym)))
    (throw
     (ex-info "Cannot resolve an unqualified symbol"
              {:sym sym}))))

;;;;;;;;;;;;;;;;;;;;;
;; Regex Functions ;;
;;;;;;;;;;;;;;;;;;;;;

(defn re-pattern
  "Return a new :external:py:class:`re.Pattern` instance."
  [s]
  (re/compile s))

(defn re-find
  "Returns the first match of a string to a pattern using :external:py:func:`re.search`\\.

  If the string matches the pattern exactly and there are no match groups, return the
  string. Otherwise, return a vector with the string in the first position and the
  match groups in the following positions."
  [pattern s]
  (let [match (re/search pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn re-matches
  "Returns a match of a string to a pattern using :external:py:func:`re.fullmatch`\\.

  If the string matches the pattern exactly and there are no match groups, return the
  string. Otherwise, return a vector with the string in the first position and the
  match groups in the following positions."
  [pattern s]
  (let [match (re/fullmatch pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn ^:private lazy-re-seq
  "Return a lazy sequence of the matches in a match iterator."
  [iter]
  (lazy-seq
   (when (first iter)
     (let [match (.group (first iter) 0)]
       (cons match (when (seq (rest iter))
                     (lazy-re-seq (rest iter))))))))

(defn re-seq
  "Returns a lazy sequence of matches of a string to a pattern using
  :external:py:func:`re.finditer`\\.

  If the string matches the pattern exactly and there are no match groups, return the
  string. Otherwise, return a vector with the string in the first position and the
  match groups in the following positions."
  [pattern s]
  (lazy-re-seq (seq (re/finditer pattern s))))

;;;;;;;;;;;;;;;;;
;; Hierarchies ;;
;;;;;;;;;;;;;;;;;

(defn make-hierarchy
  "Return a hierarchy that may be used to establish parent and child relationships via
  :lpy:fn:`derive` (relationships may be removed via :lpy:fn:`underive`).

  Relationships can be queried using :lpy:fn:`ancestors`, :lpy:fn:`descendants`,
  :lpy:fn:`parents`, and :lpy:fn:`isa?`."
  []
  {:parents     {}
   :ancestors   {}
   :descendants {}})

(def ^:private ^:redef global-hierarchy (make-hierarchy))

(defn ancestors
  "Return the set of all ancestors (parents and grandparents and so forth) of ``tag``
  in hierarchy ``h``\\.

  ``tag`` may be either a valid Python type or a namespace-qualified keyword or symbol.
  If ``tag`` is a Python type, ancestors include any relationships established via
  calls to :lpy:fn:`derive` as well as any superclasses (as returned by
  :lpy:fn:`supers`). If ``tag``  is a namespace-qualified keyword, only relationships
  from ``derive`` are returned.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy`. If ``h`` is not
  supplied, the global hierarchy will be used."
  ([tag]
   (ancestors global-hierarchy tag))
  ([h tag]
   (not-empty
    (let [hierarchy-ancestors (get-in h [:ancestors tag] #{})]
      (if (class? tag)
        (reduce* conj hierarchy-ancestors (supers tag))
        hierarchy-ancestors)))))

(defn descendants
  "Return the set of all descendants (children and grandchildren and so forth) of
  ``tag`` in hierarchy ``h``\\.

  ``tag`` must be a namespace-qualified keyword or symbol. Python types are not
  supported for ``descendants`` checks.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy`. If ``h`` is not
  supplied, the global hierarchy will be used."
  ([tag]
   (descendants global-hierarchy tag))
  ([h tag]
   (not-empty
    (let [hierarchy-ancestors (get-in h [:descendants tag] #{})]
      (if (class? tag)
        (throw (python/TypeError "Cannot get descendants of classes"))
        hierarchy-ancestors)))))

(defn parents
  "Return the set of all direct parents of ``tag`` in hierarchy ``h``\\.

  ``tag`` may be either a valid Python type or a namespace-qualified keyword or symbol.
  If ``tag`` is a Python type, ancestors include any relationships established via
  calls to :lpy:fn:`derive` as well as any immediate superclasses (as returned by
  :lpy:fn:`bases`). If ``tag``  is a namespace-qualified keyword, only relationships
  from ``derive`` are returned.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy`. If ``h`` is not
  supplied, the global hierarchy will be used."
  ([tag]
   (parents global-hierarchy tag))
  ([h tag]
   (not-empty
    (let [hierarchy-ancestors (get-in h [:parents tag] #{})]
      (if (class? tag)
        (reduce* conj hierarchy-ancestors (bases tag))
        hierarchy-ancestors)))))

(defn isa?
  "Return true if ``tag`` is equal to ``parent`` or is a descendant of ``parent`` in
  hierarchy ``h``\\.

  Both ``tag`` and ``parent`` may be a valid Python type or a namespace-qualified
  keyword or symbol or a vector of namespace-qualified keywords or symbols. If either
  of ``tag`` or ``parent`` is a vector, the other must be a vector as well.

  Ancestors will be fetched for ``tag`` using :lpy:fn:`ancestors`.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy`. If ``h`` is not
  supplied, the global hierarchy will be used."
  ([tag parent]
   (isa? global-hierarchy tag parent))
  ([h tag parent]
   (or (= tag parent)
       (and (vector? tag)
            (vector? parent)
            (->> (map (partial isa? h) tag parent)
                 (every? identity)))
       (contains? (ancestors h tag) parent)
       ;; in certain cases, in particular with the Python `io` module, the types
       ;; in a class's MRO are not identical to the types users have access to.
       ;; this is likely the case due to so-called "virtual" subclasses such as
       ;; those supported by Python's `abc` module. we need to use `issubclass`
       ;; to detect those edge cases.
       (and (instance? python/type tag)
            (instance? python/type parent)
            (python/issubclass tag parent)))))

(defn derive
  "Derive a parent/child relationship between ``tag`` and ``parent``\\.

  ``tag`` may be either a valid Python type or a namespace-qualified keyword or symbol.

  ``parent`` must be a namespace-qualified keyword or symbol.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy` . If ``h`` is not
  supplied, the global hierarchy will be used.

  Relationships may be removed via :lpy:fn:`underive`."
  ([tag parent]
   (alter-var-root #'global-hierarchy derive tag parent))
  ([h tag parent]
   (assert (qualified-ident? parent) "Parent must be a qualified keyword or symbol")
   (assert (or (qualified-ident? tag)
               (class? tag))
           "Tag must be a valid Python type or a qualified keyword or symbol")

   (let [parent-ancestors (get-in h [:ancestors parent] #{})
         cur-descendants  (get-in h [:descendants tag] #{})]
     {:parents     (as-> (get-in h [:parents tag] #{}) $
                     (conj $ parent)
                     (assoc (:parents h) tag $))
      :ancestors   (reduce* (fn [ancestors descendant]
                              (->> (get ancestors descendant)
                                   (apply conj parent-ancestors parent)
                                   (set)
                                   (assoc ancestors descendant)))
                            (:ancestors h)
                            (conj cur-descendants tag))
      :descendants (reduce* (fn [descendants ancestor]
                              (->> (get descendants ancestor)
                                   (apply conj cur-descendants tag)
                                   (set)
                                   (assoc descendants ancestor)))
                            (:descendants h)
                            (conj parent-ancestors parent))})))

(defn underive
  "Remove a parent/child relationship between ``tag`` and ``parent`` originally created
  via :lpy:fn:`derive`.

  ``tag`` may be either a valid Python type or a namespace-qualified keyword or symbol.

  ``parent`` must be a namespace-qualified keyword or symbol.

  ``h`` must be a hierarchy returned by :lpy:fn:`make-hierarchy`. If ``h`` is not
  supplied, the global hierarchy will be used."
  ([tag parent]
   (alter-var-root #'global-hierarchy underive tag parent))
  ([h tag parent]
   (assert (qualified-ident? parent) "Parent must be a qualified keyword or symbol")
   (assert (or (qualified-ident? tag)
               (class? tag))
           "Tag must be a valid Python type or a qualified keyword or symbol")

   (let [tag-parents (-> (get-in h [:parents tag] #{})
                         (disj parent))
         new-parents (if (seq tag-parents)
                       (assoc (:parents h) tag tag-parents)
                       (dissoc (:parents h) tag))]
     (->> new-parents
          (mapcat (fn [pair]
                    (let [tag     (first pair)
                          parents (second pair)]
                      (map #(vector tag %) parents))))
          (reduce* (fn [h pair]
                     (derive h (first pair) (second pair)))
                   (make-hierarchy))))))

;;;;;;;;;;;;;;;;;;
;; Multimethods ;;
;;;;;;;;;;;;;;;;;;

(defmacro defmulti
  "Define a new multimethod with the given ``name`` and a ``body`` consisting of an
  optional docstring, optional metadata map, a dispatch function and options of key/value
  pairs.

  Multimethod dispatch functions should be defined with the same arity or arities as
  the registered methods. The provided dispatch function will be called first on all
  calls to the multimethod and should return a dispatch value which will be used to
  identify a registered method. If the value returned by the dispatch function does
  not correspond to a registered method, the method registered with the default
  dispatch value, if one is registered, will be called instead. Methods can be
  registered with the ``defmethod`` macro.

  Multimethods select a dispatch method by using :lpy:fn:`isa?` on all available
  dispatch values. Callers can provide a hierarchy to use for ``isa?`` resolution. For
  cases where multiple dispatch values are registered which may return `true` for a call
  to ``isa?`` callers must select preferred values using :lpy:fn:`prefer-method` or a
  ``RuntimeException`` will be thrown when a unique method cannot be selected. Callers
  can view multimethod preferences by calling :lpy:fn:`prefers`.

  Callers may specify options as key/value pairs after the dispatch function. Options
  include:

    :keyword ``:default``: the default value to use if no matching method is found for
        the selected dispatch value; the default value is ``:default``
    :keyword ``:hierarchy``: the default hierarchy to use for resolving ``isa?``
        relationships; the default value is the global hierarchy; hierarchies should be
        passed as reference types (e.g. as a ``Var``\\)

  Multimethods are useful for defining polymorphic functions based on characteristics
  of their arguments. This behavior is often called multiple dispatch. Unlike typical
  multiple dispatch implementations, however, it is possible to define multimethods
  which dispatch on characteristics other than the types of input values (though you
  may define multimethods which dispatch solely on the types of arguments).

  For cases where you might want to define a polymorphic function or functions based
  solely on the type of the first argument, you should consider defining a protocol
  (via :lpy:fn:`defprotocol`) instead. Protocols should generally perform better in
  cases where the primary goal is dispatching on the type of the first argument."
  [name & body]
  (let [doc         (when (string? (first body))
                      (first body))
        body        (if doc
                      (rest body)
                      body)
        mt          (when (map? (first body))
                      (first body))
        body        (if mt
                      (rest body)
                      body)
        name        (vary-meta name merge mt)
        name        (if doc
                      (vary-meta name assoc :doc doc)
                      name)
        dispatch-fn (first body)
        opts        (apply hash-map (rest body))]
    `(def ~name (basilisp.lang.multifn/MultiFunction (quote ~name)
                                                     ~dispatch-fn
                                                     ~(or (:default opts) :default)
                                                     ~(:hierarchy opts)))))

(defmacro defmethod
  "Add a new method to the multimethod ``multifn`` which responds to ``dispatch-val``\\.

  ``fn-tail`` is the trailing part of a function definition after ``fn`` including any
  relevant argument vectors.

  Methods added to a multimethod can be removed using :lpy:fn:`remove-method`. All
  methods may be removed using :lpy:fn:`remove-all-methods`.

  See :lpy:fn:`defmulti` for more information about multimethods."
  [multifn dispatch-val & fn-tail]
  `(. ~multifn (~'add-method ~dispatch-val (fn ~@fn-tail))))

(defn ^:inline methods
  "Return a map of dispatch values to methods for the given multimethod."
  [multifn]
  (.-methods multifn))

(defn ^:inline get-method
  "Return the method of multimethod ``multifn`` which would respond to ``dispatch-val``
  or ``nil`` if no method exists for ``dispatch-val``\\."
  [multifn dispatch-val]
  (.get-method multifn dispatch-val))

(defn prefer-method
  "Update the mulitmethod ``multifn`` to prefer ``dispatch-val-x`` over
  ``dispatch-val-y`` in cases where the dispatch value selection might be ambiguous
  between the two.

  Returns the multimethod."
  [multifn dispatch-val-x dispatch-val-y]
  (.prefer-method multifn dispatch-val-x dispatch-val-y)
  multifn)

(defn ^:inline prefers
  "Return a map of the set of preferred values to the set of other conflicting values."
  [multifn]
  (.-prefers multifn))

(defn remove-method
  "Remove the method from the multimethod ``multifn`` which responds to
  ``dispatch-val``\\, if it exists.

  Return the multimethod."
  [multifn dispatch-val]
  (.remove-method multifn dispatch-val)
  multifn)

(defn remove-all-methods
  "Remove all methods for the multimethod ``multifn``\\.

  Return the multimethod."
  [multifn]
  (.remove-all-methods multifn)
  multifn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Destructuring Support ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmulti ^:private destructure-def
  (fn [arg]
    (cond
      (symbol? arg) :symbol
      (vector? arg) :vector
      (map? arg)    :map
      :else         :default)))

(defmethod destructure-def :map
  [arg]
  (let [alias (or (:as arg) (gensym "map_arg_"))

        ;; :or bindings allow users to specify default values for certain
        ;; associative keys.
        or-bindings (:or arg)

        ;; Namespaced keywords can destructure into non-namespaced
        ;; local names by specifying the namespace and with the name
        ;; "keys", just as the non-namespaced name "keys" will access
        ;; non-namespaced keywords.
        ;;
        ;; (let [{:movie/keys [title actors]} {:movie/title  "Die Hard"
        ;;                                     :movie/actors ["Bruce Willis"]}]
        ;;   ...)
        ;;
        kw-keys (->> (keys arg)
                     (filter keyword?)
                     (filter #(= "keys" (name %))))

        ;; Symbols may also be destructured from namespaced values as
        ;; keywords can.
        sym-keys (->> (keys arg)
                      (filter keyword?)
                      (filter #(= "syms" (name %))))

        ;; Keyword, string, and symbol keys may all be destructured from
        ;; associative types.
        kws  (mapcat (fn [kw]
                       (let [kw-ns (namespace kw)
                             syms  (get arg kw)]
                         (cond->> syms
                           kw-ns (map #(symbol kw-ns (name %))))))
                     kw-keys)
        strs (:strs arg)
        syms (mapcat (fn [sym]
                       (let [sym-ns (namespace sym)
                             syms   (get arg sym)]
                         (cond->> syms
                           sym-ns (map #(symbol sym-ns (name %))))))
                     sym-keys)

        ;; Fetch all the remaining keys in the map which do not
        ;; correspond to special functionality.
        ;; Destructuring forms may be nested arbitrarily, so generate the
        ;; definitions for any nested destructured forms as well.
        children (->> [:as :or :strs :syms]
                      (concat kw-keys sym-keys)
                      (apply dissoc arg)
                      (map (fn [arg]
                             ;; The val in this case is actually the key from
                             ;; the source data structure
                             (let [k (key arg)
                                   v (val arg)]
                               {:key     v
                                :binding (destructure-def k)}))))]
    {:name        alias
     :type        :map
     :keys        kws
     :strs        strs
     :syms        syms
     :or-bindings or-bindings
     :children    children}))

(defmethod destructure-def :symbol
  [arg]
  {:name arg
   :type :symbol})

(defmethod destructure-def :vector
  [arg]
  (let [;; Fetch the name bound to this argument with any trailing
        ;; :as key.
        alias-args (drop-while (partial not= :as) arg)
        alias      (->> alias-args (apply hash-map) :as)

        ;; Split the remaining arguments into sequential arguments
        ;; and the rest arg (if one at all).
        args (->> arg
                  (drop-last (count alias-args))
                  (split-with (partial not= '&)))

        sequential-args (first args)
        rest-arg        (second args)]
    {:name       (or alias (gensym "vec_arg_"))
     :type       :vector
     :rest       (when (seq rest-arg)
                   {:starts (count sequential-args)
                    :name   (second rest-arg)})
     :children   (map destructure-def sequential-args)}))

(defmethod destructure-def :default
  [arg]
  {:name arg
   :type :other})

(defmulti ^:private destructure-binding
  (fn [ddef]
    (:type ddef)))

(defmethod destructure-binding :vector
  [ddef]
  (let [fn-arg          (:name ddef)
        sequential-args (->> (:children ddef)
                             (map-indexed (fn [idx child]
                                            (let [alias (:name child)]
                                              (concat
                                               [alias `(nth ~fn-arg ~idx nil)]
                                               (when-not (= :symbol (:type child))
                                                 (destructure-binding child))))))
                             (apply concat))
        rest-def        (:rest ddef)
        rest-arg        (when rest-def
                          [(:name rest-def) `(nthnext ~fn-arg ~(:starts rest-def))])]
    (concat
     sequential-args
     rest-arg
     (->> (:children ddef)
          (filter #(not= :symbol (:type %)))
          (mapcat destructure-binding)))))

(defmethod destructure-binding :map
  [ddef]
  (let [fn-arg   (:name ddef)
        ors      (:or-bindings ddef)
        children (group-by
                  #(if (= (get-in % [:binding :type]) :symbol)
                     :symbol
                     :other)
                  (:children ddef))

        kw-binding (fn [arg]
                     (let [kw-ns   (namespace arg)
                           kw-name (name arg)
                           sym     (symbol kw-name)
                           kw      (if kw-ns
                                     (keyword kw-ns kw-name)
                                     (keyword kw-name))]
                       (if (contains? ors sym)
                         [sym `(get ~fn-arg ~kw ~(get ors sym))]
                         [sym `(get ~fn-arg ~kw)])))

        map-binding (fn [f arg]
                      (let [k (f arg)]
                        (if (contains? ors arg)
                          [arg `(get ~fn-arg ~k ~(get ors arg))]
                          [arg `(get ~fn-arg ~k)])))

        sym-binding (fn [arg]
                      (let [sym-name (name arg)
                            sym      (symbol sym-name)]
                        (if (contains? ors sym)
                          [sym `(get ~fn-arg (quote ~arg) ~(get ors sym))]
                          [sym `(get ~fn-arg (quote ~arg))])))

        named-binding (fn [arg]
                        (let [binding (get-in arg [:binding :name])
                              key     (:key arg)]
                          (if (contains? ors binding)
                            [binding `(get ~fn-arg (quote ~key) ~(get ors binding))]
                            [binding `(get ~fn-arg ~key)])))

        child-binding (fn [child]
                        (let [arg (get-in child [:binding :name])
                              k   (:key child)]
                          [arg `(get ~fn-arg ~k)]))]
    (concat
     [fn-arg
      `(if (seq? ~fn-arg)
         (if (next ~fn-arg)
           (apply hash-map ~fn-arg)
           (first ~fn-arg))
         ~fn-arg)]
     (mapcat kw-binding (:keys ddef))
     (mapcat (partial map-binding name) (:strs ddef))
     (mapcat sym-binding (:syms ddef))
     (mapcat named-binding (:symbol children))
     (mapcat child-binding (:other children))
     (mapcat (comp destructure-binding :binding) (:other children)))))

(defmethod destructure-binding :default
  [ddef]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (:type ddef)})))

(defn -collect-keyword-args
  "Implementation detail for associative destructuring of function keyword arguments.

  Collect all keyword arguments into a single map. Support trailing map arguments which
  are joined into the final map."
  [kwargs]
  (when (seq kwargs)
    (let [rest-args-vec  (vec kwargs)
          final-rest-arg (peek rest-args-vec)]
      (->> (if (map? final-rest-arg)
             (mapcat identity final-rest-arg)
             [final-rest-arg])
           (concat (pop rest-args-vec))
           (apply hash-map)))))

(defn ^:private fn-arity-with-destructuring
  "Take a function arity definition (an argument vector and 0 or more body expressions)
  whose argument vector may or may not require destructuring and return a function
  arity definition which uses only bare symbols and wraps the original definition in a
  let binding which performs the destructuring steps.

  As an example, for sequential destructuring like::

    (fn [[f & r]]
      {:first f
       :rest  r})

  This function would emit a list of::

    [vec_arg_3432]
    (let* [f (get vec_arg_3432 0)
           r (nthnext vec_arg_3432 1)]
      {:first f
       :rest  r})"
  [body]
  (let [args         (first body)
        arg-vec-meta (meta args)
        body         (rest body)

        arg-groups (split-with (partial not= '&) args)
        args       (first arg-groups)
        rest-args  (second arg-groups)
        rest-defs  (map destructure-def rest-args)

        rest-binding (concat
                      (let [rest-arg (second rest-defs)]
                        (when (= :map (:type rest-arg))
                          `[~(:name rest-arg) (-collect-keyword-args ~(:name rest-arg))]))
                      (->> rest-defs
                           (filter #(not= :symbol (:type %)))
                           (mapcat destructure-binding)))

        defs     (map destructure-def args)
        arg-vec  (with-meta
                   (vec (concat
                         (map :name defs)
                         (map :name rest-defs)))
                   arg-vec-meta)
        bindings (->> defs
                      (filter #(not= :symbol (:type %)))
                      (mapcat destructure-binding)
                      (concat rest-binding))
        new-body (if (seq bindings)
                   [`(let* [~@bindings]
                       ~@body)]
                   body)]
    (apply list arg-vec new-body)))

(defmacro ^:no-warn-on-redef fn
  "Return an anonymous (but possibly named) function.

  Function argument vectors support sequential and associative :ref:`destructuring` .

  See :lpy:form:`fn` for more details."
  [& body]
  (let [name    (when (symbol? (first body))
                  (first body))
        body    (cond-> body name rest)
        arities (cond
                  (vector? (first body))
                  (fn-arity-with-destructuring body)

                  (seq? (first body))
                  (apply list (map fn-arity-with-destructuring body))

                  :else
                  body)]
    (as-> arities $
      (cond->> $ name (cons name))
      (cons 'fn* $)
      (cond-> $
        (meta &form) (with-meta (meta &form))))))

(defn destructure
  "Take a ``[binding expr]`` pair (as from a ``let`` block) and produce all of the
  replacement bindings for the binding which perform destructuring on the initial
  expression.

  As an example, for sequential destructuring like::

    [f & r :as v] [1 2 3 4]

  This function would emit a list of bindings which can be inserted directly into a
  ``let*`` binding to perform destructuring::

     (v [1 2 3 4]
      f (nth v 0)
      r (nthnext v 1))"
  [[binding expr]]
  (let [ddef      (destructure-def binding)
        orig-name (:name ddef)
        bindings  (if (= :symbol (:type ddef))
                    []
                    (destructure-binding ddef))]
    (apply list orig-name expr bindings)))

(defmacro ^:no-warn-on-redef let
  ":lpy:form:`let` bindings with :ref:`destructuring` support."
  [bindings & body]
  `(let* [~@(->> (partition 2 bindings)
                 (mapcat destructure))]
     ~@body))

(defmacro letfn
  "Let form specifically for local function definitions.

  Functions are defined as bindings::

    (letfn [(plus-two [x] (+ (plus-one x) 1))
            (plus-one [x] (+ x 1))]
      (plus-two 3))

  Functions defined in ``letfn`` bindings may refer to each other regardless of their
  order of definition.

  See :lpy:form:`letfn` for more details."
  [bindings & body]
  `(letfn* [~@(mapcat (fn [fn-body]
                        [(first fn-body) (cons `fn fn-body)])
                      bindings)]
           ~@body))

(defn ^:private loop-with-destructuring
  "Take a loop definition (an binding vector and 0 or more body expressions) whose
  binding vector may or may not require destructuring and return a loop binding vector
  and loop body."
  [bindings body]
  (let [defs           (->> (take-nth 2 bindings)
                            (map destructure-def))
        binding-vec    (vec (mapcat (fn [ddef binding]
                                      [(:name ddef) binding])
                                    defs
                                    (take-nth 2 (drop 1 bindings))))
        inner-bindings (->> defs
                            (filter #(not= :symbol (:type %)))
                            (mapcat destructure-binding))
        new-body       (if (seq inner-bindings)
                         [`(let* [~@inner-bindings]
                             ~@body)]
                         body)]
    [binding-vec new-body]))

(defmacro ^:no-warn-on-redef loop
  ":lpy:form:`loop` bindings with :ref:`destructuring` support."
  [bindings & body]
  (let [[bindings body] (loop-with-destructuring bindings body)]
    `(loop* ~bindings
        ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Interop Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

(defn lisp->py
  "Recursively convert Basilisp data structures into Python data structures.

  Callers can specify a keyword argument ``:keyword-fn``, which names a function which
  is called for each keyword value in the input structure to return a new value. By
  default ``:keyword-fn`` is the function :lpy:fn:`name`."
  ([o]
   (basilisp.lang.runtime/to-py o))
  ([o & {:keys [keyword-fn] :or {keyword-fn name}}]
   (basilisp.lang.runtime/to-py o keyword-fn)))

(defn py->lisp
  "Recursively convert Python data structures into Basilisp data structures.

  Callers can specify a keyword argument ``:keywordize-keys``\\, which defaults to
  ``true``\\. If ```:keywordize-keys is ``true``\\, then all string keys in Python
  ``dicts`` will be converted into keywords in the final return value."
  ([o]
   (basilisp.lang.runtime/to-lisp o))
  ([o & {:keys [keywordize-keys] :or {keywordize-keys true}}]
   (basilisp.lang.runtime/to-lisp o keywordize-keys)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Parsing Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

(defn ^:private parsing-error
  [s]
  (python/TypeError
   (str "Expected string; got " (type s))))

(defn parse-double
  "Parse the string argument ``s`` as a floating point number as by Python's
  builtin :external:py:class:`float` function, returning the float if the string
  contains one, or ``nil`` otherwise.

  This function will throw a ``TypeError`` for non-string types."
  [s]
  (if (string? s)
    (try
      (python/float s)
      (catch python/ValueError _ nil))
    (throw (parsing-error s))))

(defn parse-long
  "Parse the string argument ``s`` as an integer (base 10) as by Python's builtin
  :external:py:class:`int` function, returning the integer if the string contains one,
  or ``nil`` otherwise.

  This function will throw a ``TypeError`` for non-string types."
  [s]
  (if (string? s)
    (try
      (python/int s)
      (catch python/ValueError _ nil))
    (throw (parsing-error s))))

(defn parse-boolean
  "Parse the string argument ``s`` as either boolean ``true`` or ``false`` returning the
  boolean if the string contains one, or ``nil`` otherwise.

  This function will throw a ``TypeError`` for non-string types."
  [s]
  (if (string? s)
    (get {"true" true "false" false} s)
    (throw (parsing-error s))))

(defn parse-uuid
  "Parse the string argument ``s`` as a :external:py:class:`uuid.UUID`, returning the
  UUID if the string contains one, or ``nil`` otherwise.

  This function will throw a ``TypeError`` for non-string types."
  [s]
  (if (string? s)
    (try
      (uuid/UUID s)
      (catch python/ValueError _ nil))
    (throw (parsing-error s))))

;;;;;;;;;;;;;;;;
;; Interfaces ;;
;;;;;;;;;;;;;;;;

(defmulti munge
  "Munge the input value into a Python-safe string. Converts keywords and symbols into
  strings as by :lpy:fn:`name` prior to munging.

  Returns a string."
  python/type)

(defmethod munge basilisp.lang.keyword/Keyword
  [kw]
  (basilisp.lang.util/munge (name kw)))

(defmethod munge basilisp.lang.symbol/Symbol
  [s]
  (basilisp.lang.util/munge (name s)))

(defmethod munge python/str
  [s]
  (basilisp.lang.util/munge s))

(defn demunge
  "De-munge a Python-safe string identifier into a Lisp identifier."
  [s]
  (basilisp.lang.util/demunge s))

(def namespace-munge
  "Convert a Basilisp namespace name to a valid Python name."
  munge)

(defn gen-interface
  "Generate and return a new Python interface (abstract base clase).

  Options may be specified as key-value pairs. The following options are supported:

    :keyword ``:name``: the name of the interface as a string; required
    :keyword ``:extends``: a vector of interfaces the new interface should extend;
        optional
    :keyword ``:methods``: an optional vector of method signatures without ``self``
        or ``this``, like::

          [ (method-name [args ...] docstring) ... ]

  Callers should use :lpy:fn:`definterface` to generate new interfaces."
  [& opts]
  (let [opt-map        (apply hash-map opts)
        interface-name (:name opt-map)
        extends        (as-> (:extends opt-map []) $
                         (remove #(identical? abc/ABC %) $)
                         (concat $ [abc/ABC])
                         (python/tuple $))]
    (->> (:methods opt-map)
         (map (fn [[method-name args docstring]]
                (let [includes-self? (contains? #{'self 'this} (first args))
                      total-arity    (cond-> (count args) includes-self? (dec))
                      is-variadic?   (let [[_ [amp rest-arg]] (split-with #(not= '& %) args)]
                                       (and (= '& amp) (not (nil? rest-arg))))
                      fixed-arity    (cond-> total-arity is-variadic? (- 2))]
                  {:method-name  method-name
                   :args         args
                   :fixed-arity  fixed-arity
                   :is-variadic? is-variadic?
                   :docstring    docstring
                   :python-name  (->> (if is-variadic? "_rest" fixed-arity)
                                      (str "_" (munge method-name) "_arity"))})))
         (group-by :method-name)
         (mapcat (fn [[method-name arities]]
                   (if (> (count arities) 1)
                     (let [fixed-arities            (->> arities
                                                         (remove :is-variadic?)
                                                         (map :fixed-arity))
                           variadic-arities         (filter :is-variadic? arities)
                           fixed-arity-for-variadic (some-> variadic-arities first :fixed-arity)
                           num-variadic             (count variadic-arities)]
                       (when (not= (count (set fixed-arities))
                                   (count fixed-arities))
                         (throw
                          (ex-info (str "Interface methods may not have multiple methods "
                                        "with the same fixed arity")
                                   {:arities       arities
                                    :fixed-arities (vec fixed-arities)})))
                       (when (> num-variadic 1)
                         (throw
                          (ex-info "Interface methods may have at most one variadic arity"
                                   {:arities      arities
                                    :num-variadic num-variadic})))
                       (when (and fixed-arity-for-variadic
                                  (some #(< fixed-arity-for-variadic %) fixed-arities))
                         (throw
                          (ex-info (str "Interface methods may not have a fixed arity "
                                        "greater than the arity of a variadic method")
                                   {:arities                  arities
                                    :fixed-arity-for-variadic fixed-arity-for-variadic
                                    :fixed-arities            fixed-arities})))
                       ;; multi-arity methods need to include an outer dispatch method,
                       ;; which will not be defined by the user and must be defined here
                       (conj arities
                             {:method-name method-name
                              :python-name (munge method-name)
                              :args        '[& args]
                              :docstring   (-> arities first :docstring)}))
                     ;; single arity methods should not have a private Python name
                     ;; since they do not have an outer dispatch method
                     (map (fn [{:keys [method-name] :as arity}]
                            (assoc arity :python-name (munge method-name)))
                          arities))))
         (reduce* (fn [m {:keys [method-name python-name args docstring]}]
                    (let [method (->>  args
                                       (map #(vary-meta % assoc :no-warn-when-unused true))
                                       (apply vector)
                                       (list 'fn* method-name)
                                       (eval)
                                       (abc/abstractmethod))]
                      (when docstring
                        (set! (.- method __doc__) docstring))
                      (assoc m python-name method)))
                  {})
         (lisp->py)
         (python/type interface-name extends))))

(defmacro definterface
  "Define a new Python interface (abstract base clase) with the given name and method
  signatures.

  Method signatures are in the form ``(method-name [arg1 arg2 ...])``\\. ``self`` or
  ``this`` arguments must be omitted from all interfaces.

  Interface objects cannot be directly instantiated. Instead, you must create a concrete
  implementation of an interface (perhaps via :lpy:fn:`deftype`) and supply
  implementations for all of the abstract methods.

  The generated interface derives from Python's :external:py:class:`abc.ABC` and all
  method definitions are declared as :external:py:func:`abc.abstractmethod` s and thus
  must be implemented by a concrete type.

  Interfaces created by ``definterface`` cannot be declared as properties, class
  methods, or static methods, as with :lpy:fn:`deftype`."
  [interface-name & methods]
  (let [name-str    (name interface-name)
        method-sigs (->> methods
                         (map (fn [[method-name args docstring]]
                                [method-name (conj args 'self) docstring]))
                         (map #(list 'quote %)))]
    `(def ~interface-name
       (gen-interface :name ~name-str
                      :methods [~@method-sigs]))))

;;;;;;;;;;;;;;;
;; Protocols ;;
;;;;;;;;;;;;;;;

(defn ^:private gen-protocol-dispatch
  "Return the dispatch function for a single protocol method."
  [protocol-name interface-name [method-name & args+docstring :as method-def]]
  (let [[arglists [docstring]] (split-with (complement string?) args+docstring)]
    [`(def ~(vary-meta method-name
                       assoc
                       :doc docstring
                       :arglists (list 'quote arglists)
                       :basilisp.core/source-protocol (list 'var protocol-name))
        (functools/singledispatch
         (fn ~method-name
           ~@(map (fn [[obj-sym & args]]
                    (list `[~obj-sym ~@(map #(vary-meta % assoc :no-warn-when-unused true) args)]
                          `(let [obj-type# (python/type ~obj-sym)]
                             (throw
                              (ex-info (str
                                        ~(str "No implementation of method " method-name " found for type ")
                                        obj-type#)
                                       {:protocol    (var ~protocol-name)
                                        :method      ~method-name
                                        :object-type obj-type#})))))
                  arglists))))
     (let [dotted-method-name (symbol (str "." (name method-name)))]
       `(.register ~(vary-meta method-name assoc :no-warn-on-var-indirection true)
                   ~interface-name
                   (fn ~method-name
                     ~@(map (fn [[obj-sym & args]]
                              (let [has-varargs (some #(= '& %) args)
                                    clean-args  (filter #(not= '& %) args)]
                                (list `[~obj-sym ~@args]
                                      (if has-varargs
                                        `(apply-method ~obj-sym ~method-name ~@clean-args)
                                        `(~dotted-method-name ~obj-sym ~@clean-args)))))
                            arglists))))]))

;; For each protocol, the following keys are defined:
;;
;; - :impls     - a set of types which dynamically extend the Protocol
;;                (e.g. by `extend`)
;; - :interface - the Python interface type which backs the Protocol
;; - :methods   - a mapping of method names (as Basilisp keywords) to the dispatch
;;                method backing the Protocol method
;; - :var       - a reference to the Var the Protocol is stored in

(defmacro defprotocol
  "Define a new protocol.

  Protocols are similar to classical programming interfaces. Rather than defining an
  interface and implementing that interface on different objects, protocols generate
  a set of functions which dispatch to the correct implementation on the type of their
  first argument (which is similar to the Python ``self`` argument).

  Also like interfaces, Protocols do not include implementations for any of their
  member methods. Instead, implementations can be provided using :lpy:fn:`deftype`,
  :lpy:fn:`defrecord`, :lpy:fn:`reify`, or :lpy:fn:`extend` (or any of the ``extend-*``
  macros).

  Despite their differences from interfaces, Protocols do also generate a standard
  Python interface type (deriving from :external:py:class:`abc.ABC`) which is used for
  efficient dispatch for implementing types.

  Method signatures are in the form::

    (method-name [self arg1] [self arg1 arg2] \"This method foos the bars.\")

  Callers must provide the ``self`` or ``this`` arguments for each method."
  [protocol-name & methods]
  (let [doc           (when (string? (first methods))
                        (first methods))
        methods       (if doc (rest methods) methods)
        protocol-name (vary-meta
                       (cond-> protocol-name
                         doc (vary-meta assoc :doc doc))
                       assoc
                       :protocol true
                       :redef true)
        interface-sym (gensym "interface-name")]
    `(do
       (defonce ~protocol-name {})
       (alter-meta! (var ~protocol-name)
                    assoc
                    :doc ~doc
                    :basilisp.core/protocol true)
       (let [~interface-sym (gen-interface :name ~(name protocol-name)
                                           :methods [~@(mapcat
                                                        (fn [[method-name & args+docstring]]
                                                          (let [[arglists [docstring]] (split-with
                                                                                        (complement string?)
                                                                                        args+docstring)]
                                                            (map (fn [args]
                                                                   (list 'quote
                                                                         `(~method-name
                                                                           ~args
                                                                           ~@(when docstring [docstring]))))
                                                                 arglists)))
                                                        methods)])]
         ~@(mapcat #(gen-protocol-dispatch protocol-name interface-sym %) methods)
         (->> {:impls     #{}
               :interface ~interface-sym
               :methods   ~(apply hash-map
                                  (mapcat #(let [v (first %)]
                                             [(keyword (name v)) (vary-meta v assoc :no-warn-on-var-indirection true)])
                                          methods))
               :var       (var ~protocol-name)}
              (alter-var-root (var ~protocol-name) merge ~protocol-name)))
       ~protocol-name)))

(defn protocol?
  "Return ``true`` if ``x`` is a Protocol."
  [x]
  (boolean (and (map? x) (:interface x))))

(defn extend
  "Extend a type dynamically with one or Protocol implementations. This is useful for
  types which were defined outside your control or which were not otherwise defined
  as direct implementors of the named Protocol(s). With ``extend``, such types may be
  extended without modifying the types directly.

  ``target-type`` should name a type which is to be extended. Virtually any type is
  permitted, so long as that that type is not also a Protocol. If ``target-type`` is an
  interface, objects of types implementing that interface will be extended by the given
  implementation unless a more concrete implementation is available (by the Python
  method resolution order of the object's type). If ``target-type` is ``nil``\\, it will
  be interpreted as ``(python/type nil)``\\.

  ``proto+methods`` are interleaved Protocol names and maps of Protocol method
  implementations intended for ``target-type``\\. The keys of each map are keywords
  corresponding to the names of the Protocol methods (as defined in the
  :lpy:fn:`defprotocol`). Each value should be either an existing function (referenced
  by its Var or name binding) or a new function definition.

  ``extend`` may be called multiple times for a single ``target-type``\\, so not all
  implementations need to be known a priori. Successive calls to ``extend`` on
  ``target-type`` with the same Protocol implementations will overwrite previous
  implementations.

  If you are extending types with explicit function definitions, the
  :lpy:fn:`extend-protocol` and :lpy:fn:`extend-type` macros offer some additional
  conveniences.

  Returns ``nil``.

  Example::

    (extend SomeType
      FirstProto
      {:spam spam-fn
       :eggs (fn [...] ...)}
      OtherProto
      {:ham  (fn [...] ...)})"
  [target-type & proto+methods]
  (let [target-type (cond-> target-type (nil? target-type) (python/type))]
    (cond
      (protocol? target-type)
      (throw (ex-info "Protocols may not be extended with other Protocols"
                      {:target-type target-type}))

      (not (instance? python/type target-type))
      (throw (ex-info "extend target-type must be a type"
                      {:target-type target-type})))

    (doseq [proto-pair (apply hash-map proto+methods)
            :let       [[proto method-map] proto-pair]]
      (when-not (protocol? proto)
        (throw (ex-info "extend protocol must be protocol as defined by defprotocol"
                        {:target-type target-type
                         :proto       proto})))
      (when (identical? target-type proto)
        (throw (ex-info "Protocol may not extend itself"
                        {:target-type target-type
                         :proto       proto})))

      (->> (fn [old-root]
             (let [proto-methods (:methods proto)]
               (let [proto-method-names (set (keys proto-methods))
                     impl-method-names  (set (keys method-map))]
                 (when-not (= proto-method-names impl-method-names)
                   (throw (ex-info "target-type must implement all protocol methods"
                                   {:missing-methods (->> proto-method-names
                                                          (remove impl-method-names)
                                                          (set))}))))
               (let [proto-method-arity-map (reduce* (fn [m kv]
                                                         (assoc m (key kv) (.-arities (val kv))))
                                                       {}
                                                       proto-methods)
                     impl-method-arity-map  (reduce* (fn [m kv]
                                                         (assoc m (key kv) (.-arities (val kv))))
                                                       {}
                                                       method-map)]
                 (doseq [proto-method proto-method-arity-map
                         :let         [[proto-method-name proto-method-arities] proto-method]]
                   (let [impl-method-arities (get impl-method-arity-map proto-method-name)]
                     (when (not= impl-method-arities proto-method-arities)
                       (throw (ex-info "target-type must implement all protocol method arities"
                                       {:proto-method         proto-method-name
                                        :proto-method-arities proto-method-arity-map
                                        :impl-method-arities  impl-method-arity-map
                                        :missing-arities      (->> proto-method-arities
                                                                   (remove impl-method-arities)
                                                                   (set))}))))))
               (doseq [method-def method-map
                       :let       [[method-name fn] method-def]]
                 (let [dispatch-method (get proto-methods method-name)]
                   (.register dispatch-method target-type fn))))
             (update old-root :impls conj target-type))
           (alter-var-root (:var proto)))))

  nil)

(defn ^:private sym-and-method-groups
  "Group methods for ``extend-protocol`` and ``extend-type`` into a map of interface
  names to a vector of method bodies."
  [specs]
  (loop [iface   (first specs)
         specs   (rest specs)
         methods []
         groups  {}]
    (cond
      (not (seq specs))
      (assoc groups iface methods)

      (list? (first specs))
      (recur iface
             (rest specs)
             (conj methods (first specs))
             groups)

      (or (symbol? (first specs)) (nil? (first specs)))
      (recur (first specs)
             (rest specs)
             []
             (assoc groups iface methods)))))

(defn ^:private extend-map
  "Convert a vector of method definitions (as expected by ``extend-protocol`` and
  ``extend-type``\\) into a map of method definitions which can be passed to
  ``extend``\\."
  [target-type methods]
  (->> (group-by first methods)
       (reduce* (fn [m [method-name arities]]
                  (let [genned-method-name (symbol
                                            (str (name method-name)
                                                 "-"
                                                 (if (nil? target-type)
                                                   "nil"
                                                   (name target-type))))]
                    (->> (map rest arities)
                         (apply list `fn genned-method-name)
                         (assoc! m (keyword (name method-name))))))
                (transient {}))
       (persistent!)))

(defmacro extend-protocol
  "Extend a Protocol with implementations for multiple types.

  This convenience macro is useful for extending multiple different types with a single
  Protocol definition in one call. Note that this macro only supports new function
  declarations. If you intend to reference an existing function, call :lpy:fn:`extend`
  directly.

  For example, this call::

    (extend-protocol SomeProto
      FirstType
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...)
      OtherType
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...))

  Would be turned into the following ``extend`` calls::

    (do
      (extend FirstType
        SomeProto
        {:spam (fn spam
                 ([this] ...)
                 ([this arg] ...))
         :eggs (fn [this arg1 arg2] ...)})
      (extend OtherType
        SomeProto
        {:spam (fn spam
                 ([this] ...)
                 ([this arg] ...))
         :eggs (fn [this arg1 arg2] ...)}))"
  [proto & specs]
  `(do ~@(map (fn [[target-type methods]]
                `(extend ~target-type
                   ~proto
                   ~(extend-map target-type methods)))
              (sym-and-method-groups specs))))

(defmacro extend-type
  "Extend a type with multiple Protocol implementations.

  This convenience macro is useful for extending a single type with multiple different
  Protocol definitions in one call. Note that this macro only supports new function
  declarations. If you intend to reference an existing function, call :lpy:fn:`extend`
  directly.

  For example, this call::

    (extend-type SomeType
      FirstProto
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...)
      SecondProto
      (ham [this & args] ...))

  Would be turned into the following ``extend`` call::

    (extend SomeType
      FirstProto
      {:spam (fn spam
               ([this] ...)
               ([this arg] ...))
       :eggs (fn eggs [this arg1 arg2] ...)}
      SecondProto
      {:ham (fn ham [this & args] ...)})"
  [target-type & specs]
  `(extend ~target-type
     ~@(mapcat (fn [[proto methods]]
                 [proto (extend-map target-type methods)])
               (sym-and-method-groups specs))))

(defn extenders
  "Return a collection of types explicitly extending protocol ``proto``\\.

  The returned collection will not include types which extend proto via inheritance
  (as by :lpy:fn:`deftype` and :lpy:fn`defrecord`). Only types extending proto via
  :lpy:fn:`extend` (or :lpy:fn:`extend-protocol` or :lpy:fn:`extend-type`) will appear."
  [{:keys [impls] :as proto}]
  (apply list impls))

(defn extends?
  "Return ``true`` ``if`` type extends protocol ``proto``\\."
  [{:keys [interface impls] :as proto} type]
  (or (python/issubclass type interface)
      (contains? impls type)))

(defn satisfies?
  "Return true if ``x`` satisfies protocol ``proto``\\."
  [{:keys [interface impls] :as proto} x]
  (or (instance? interface x)
      (python/isinstance x (python/tuple impls))))

;;;;;;;;;;;;;;;;
;; Data Types ;;
;;;;;;;;;;;;;;;;

(defn ^:private collect-methods
  "Collect method and interface declarations for :lpy:fn:`deftype`, :lpy:fn:`defrecord`,
  and :lpy:fn:`reify` into a map containing ``:interfaces`` and ``:methods`` keys."
  [method-impls]
  (group-by (fn [v]
              (cond
                (symbol? v) :interfaces
                (seq v)     :methods
                :else       (throw
                             (ex-info "Expected method definition or interface name"
                                      {:value v :type (type v)}))))
            method-impls))

(defmacro deftype
  "Define a new Python concrete type which can implement 0 or more Python interfaces
  or Basilisp protocols.

  The new type will have fields matching the names in ``fields``. Fields may be
  referred to unqualified in the bodies of implemented methods. By default the fields
  of this type are immutable. Attempting to set non-mutable fields from a method body
  will result in a compiler error.

  Fields may be made mutable by annotating their definition with ``:mutable`` metadata.
  Mutable fields may be set within method bodies using the ``set!`` special form. It is
  not advised to use mutable fields unless you are sure you know what you are doing. As
  a consequence of Python's lax policy towards immutability, types with even one
  mutable field may be mutated by outside callers using ``set!``\\, so bear that in mind
  when choosing mutability.

  Interface or protocol implementations are declared as the name of the interface or
  protocol as a symbol, followed by 1 or more method definitions for that interface.
  Types are not required to declare any interface implementations. Types which do
  declare interface implementations are required to implement all interface methods.
  Failing to implement all interface methods is a compile time error. Types
  implementing ``object`` are not required to implement all ``object`` methods.

  Method declarations should appear as::

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Unlike in Clojure, interface and protocol methods are permitted to include variadic
  arguments. Single-arity methods may also declare support for keyword arguments using
  either the ``:apply`` or ``:collect`` strategy on the ``:kwargs`` metadata on the
  method name. Methods may be declared as static (using the ``:staticmethod`` meta key)
  or class methods (using the ``:classmethod`` meta key). Both static methods and class
  methods can be declared with multiple arities or may be defined with a single arity
  and keyword arguments. Finally, single-arity methods may be declared as Python
  properties using the ``:property`` metadata on the method name. These facilities are
  provided as a means to interoperate with Python code and their use is discouraged in
  pure Basilisp code.

  Type objects are created with sensible ``object`` defaults as by ``attrs``\\. New
  types may override ``object`` defaults. An ``__init__`` function is automatically
  created which takes positional arguments matching the  order of definition in
  ``fields``. Additionally, given a name ``NewType``\\, a factory function will be
  created ``->NewType`` which can be used to generate new instances of the type.

  Methods must supply a ``this`` or ``self`` parameter. ``recur`` special forms used in
  the body of a method should not include that parameter, as it will be supplied
  automatically."
  [type-name fields & method-impls]
  (let [ctor-name (with-meta
                    (symbol (str "->" (name type-name)))
                    (meta type-name))

        {:keys [interfaces methods]} (collect-methods method-impls)]
    `(do
       (declare ~type-name ~ctor-name)
       (deftype* ~type-name ~fields
         :implements [~@interfaces
                      ~'basilisp.lang.interfaces/IType
                      ~'python/object]
         ~@methods)
       (def ~ctor-name ~type-name)
       ~type-name)))

(defmacro reify
  "Create a new Python object of an anonymous type which implements 0 or more
  Python interfaces or Basilisp protocols.

  Unlike types created via :lpy:fn:`deftype`, ``reify`` returns an object which
  implements the named interfaces using the implementations provided. You may not
  provide fields as such to ``reify``\\, though ``reify`` closes over any local names
  defined in the same lexical context. These fields may serve as private fields of the
  created object.

  Interface or protocol implementations are declared as the name of the interface or
  protocol as a symbol, followed by 1 or more method definitions for that interface.
  Types are not required to declare any interface implementations. Types which do
  declare interface implementations are required to implement all interface methods.
  Failing to implement all interface methods is a compile time error. Types
  implementing ``object`` are not required to implement all ``object`` methods.

  Method declarations should appear as::

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Unlike in Clojure, interface and protocol methods are permitted to include variadic
  arguments. Single-arity methods may also declare support for keyword arguments using
  either the ``:apply`` or ``:collect`` strategy on the ``:kwargs`` metadata on the
  method name. Finally, single-arity methods may be declared as Python properties
  using the ``:property`` metadata on the method name. These facilities are provided
  as a means to interoperate with Python code and their use is discouraged in pure
  Basilisp code.

  ``reify`` does not support class method or static method members and attempting to
  declare ``reify`` members as class or static members will result in a compile time
  error.

  Type objects are created with sensible ``object`` defaults as by ``attrs``\\. New
  types may override ``object`` defaults.

  Reified objects always implement ``basilisp.lang.interfaces/IWithMeta`` and transfer
  the metadata from the form to the created object.

  Methods must supply a ``this`` or ``self`` parameter. ``recur`` special forms used in
  the body of a method should not include that parameter, as it will be supplied
  automatically."
  [& method-impls]
  (let [{:keys [interfaces methods]} (collect-methods method-impls)
        reify-sym                    (with-meta 'reify* (meta (first &form)))]
    (with-meta
      `(~reify-sym :implements [~@interfaces python/object]
               ~@methods)
      (meta &form))))

;;;;;;;;;;;;;
;; Proxies ;;
;;;;;;;;;;;;;

(def ^:private excluded-proxy-methods
  #{"__getattribute__"
    "__init__"
    "__new__"})

(def ^:private proxy-cache (atom {}))

(defn ^:private proxy-base-methods
  [base]
  (->> (inspect/getmembers base inspect/isroutine)
       (remove (comp excluded-proxy-methods first))
       (mapcat (fn [[method-name method]]
                 (let [meth-sym (symbol method-name)
                       meth `(fn ~meth-sym [~'self & args#]
                               (if-let [override (get (.- ~'self ~'-proxy-mappings) ~method-name)]
                                 (apply override ~'self args#)
                                 (-> (.- ~'self __class__)
                                     (python/super ~'self)
                                     (.- ~meth-sym)
                                     (apply args#))))]
                   [method-name (eval meth *ns*)])))))

(defn ^:private proxy-type
  "Generate a proxy class with the given bases."
  [bases]
  (let [methods      (apply hash-map (mapcat proxy-base-methods bases))
        base-methods {"__init__"               (fn __init__ [self proxy-mappings & args]
                                                 (apply (.- (python/super (.- self __class__) self) __init__) args)
                                                 (set! (.- self -proxy-mappings) proxy-mappings)
                                                 nil)
                      "_get_proxy_mappings"    (fn _get_proxy_mappings [self]
                                                 (.- self -proxy-mappings))
                      "_set_proxy_mappings"    (fn _set_proxy_mappings [self proxy-mappings]
                                                 (set! (.- self -proxy-mappings) proxy-mappings)
                                                 nil)
                      "_update_proxy_mappings" (fn _update_proxy_mappings [self proxy-mappings]
                                                 (let [updated-mappings (->> proxy-mappings
                                                                             (reduce* (fn [m [k v]]
                                                                                        (if v
                                                                                          (assoc m k v)
                                                                                          (dissoc m k)))
                                                                                      (.- self -proxy-mappings))
                                                                             (persistent!))]
                                                   (set! (.- self -proxy-mappings) updated-mappings)
                                                   nil))
                      "_proxy_mappings"        nil}]
    (python/type (basilisp.lang.util/genname "Proxy")
                 (python/tuple (concat bases [basilisp.lang.interfaces/IProxy]))
                 (python/dict (merge methods base-methods)))))

;; TODO: support object as super
(defn get-proxy-class
  "Given one or more base classes, return a proxy class for the given classes.

  Generated classes are cached, such that the same set of base classes will always
  return the same resulting proxy class."
  [& bases]
  (let [base-set (set bases)]
    (-> (swap! proxy-cache (fn [cache]
                             (if (get cache base-set)
                               cache
                               (assoc cache base-set (proxy-type bases)))))
        (get base-set))))

(defn proxy-mappings
  "Return the current method map for the given proxy.

  Throws an exception if ``proxy`` is not a proxy."
  [proxy]
  (if-not (instance? basilisp.lang.interfaces/IProxy proxy)
    (throw
     (ex-info "Cannot get proxy mappings from object which does not implement IProxy"
              {:obj proxy}))
    (. proxy (_get-proxy-mappings))))

(defn construct-proxy
  "Construct an instance of the proxy class ``c`` with the given constructor arguments.

  Throws an exception if ``c`` is not a subclass of
  :py:class:`basilisp.lang.interfaces.IProxy`.

  .. note::

     In JVM Clojure, this function is useful for selecting a specific constructor based
     on argument count, but Python does not support multi-arity methods (including
     constructors), so this is likely of limited use."
  [c & ctor-args]
  (if-not (python/issubclass c basilisp.lang.interfaces/IProxy)
    (throw
     (ex-info "Cannot construct instance of class which is not a subclass of IProxy"
              {:class c :args ctor-args}))
    (apply c {} ctor-args)))

(defn init-proxy
  "Set the current proxy method map for the given proxy.

  Method maps are maps of string method names to their implementations as Basilisp
  functions.

  Throws an exception if ``proxy`` is not a proxy."
  [proxy mappings]
  (if-not (instance? basilisp.lang.interfaces/IProxy proxy)
    (throw
     (ex-info "Cannot get proxy mappings from object which does not implement IProxy"
              {:obj proxy}))
    (do
      (. proxy (_set-proxy-mappings mappings))
      proxy)))

(defn update-proxy
  "Update the current proxy method map for the given proxy.

  Method maps are maps of string method names to their implementations as Basilisp
  functions. If ``nil`` is passed in place of a function for a method, that method will
  revert to its default behavior.

  Throws an exception if ``proxy`` is not a proxy."
  [proxy mappings]
  (if-not (instance? basilisp.lang.interfaces/IProxy proxy)
    (throw
     (ex-info "Cannot update proxy mappings for object which does not implement IProxy"
              {:obj proxy}))
    (do
      (. proxy (_update-proxy-mappings mappings))
      proxy)))

;; TODO: how to handle multi-arity fns
;; TODO: kwargs on supertypes
(defmacro proxy
  [class-and-interfaces args & fs]
  (let [formatted-arity (fn [method-name [arg-vec & body]]
                          [method-name
                           (apply list method-name (vec (concat ['this] arg-vec)) body)])
        methods         (mapcat (fn [[method-name & body]]
                                  (if (vector? (first body))
                                    [(formatted-arity method-name body)]
                                    (map (partial formatted-arity method-name) body)))
                                fs)]
    `((get-proxy-class ~@class-and-interfaces) {} ~@args)))

;; TODO: handle explicit class and self
(defmacro proxy-super
  "Macro which expands to a call to the method named ``meth`` on the superclass
  with the provided ``args``.

  Note that the default"
  [meth & args]
  `(. (~'python/super) (~meth ~@args)))

;;;;;;;;;;;;;
;; Records ;;
;;;;;;;;;;;;;

(defn ^:inline record?
  "Return ``true`` if ``v`` is a record type."
  [v]
  (instance? basilisp.lang.interfaces/IRecord v))

(defmulti evolve
  "Implementation detail of :lpy:fn:`defrecord`."
  (fn [v & _] (type v)))

(defmethod evolve basilisp.lang.interfaces/IPersistentMap
  [m & kwargs]
  (apply assoc m kwargs))

(defmethod evolve basilisp.lang.interfaces/IRecord
  [rec & kwargs]
  (->> (apply hash-map kwargs)
       (apply-kw attr/evolve rec)))

(prefer-method evolve basilisp.lang.interfaces/IRecord basilisp.lang.interfaces/IPersistentMap)

(defn -mangle-py-field
  "Implementation detail of :lpy:fn:`defrecord` to support Python's managled field
  names."
  [type-sym field-name]
  (if (and (.startswith field-name "__")
           (not (.endswith field-name "__")))
    (let [munged-type-name (.lstrip (munge type-sym) "_")]
      (str "_" munged-type-name field-name))
    field-name))

(defn ^:private validate-record-fields
  "Validate that record fields do not contain any reserved entries, are not declared as
  mutable, and do not declare any default values."
  [fields field-kws]
  (when (some #(#{:meta :_recmap} %) field-kws)
    (throw
     (ex-info "Reserved fields cannot be used for Record field names"
              {:fields (.intersection #{:meta :_recmap} (set field-kws))})))

  (when (some #(:mutable (meta %)) fields)
    (throw
     (ex-info "Mutable fields not permitted in Record types"
              {:fields (filter #(:mutable (meta %)) fields)})))

  (when (some #(contains? (meta %) :default) fields)
    (throw
     (ex-info "Record fields may not specify defaults"
              {:fields (filter #(contains? (meta %) :default) fields)}))))

(defn ^:private validate-record-methods
  "Validate that record methods are not declared as class methods, properties, or
  static methods."
  [methods]
  (when (->> methods
             (mapcat (fn [method]
                       [(meta method) (meta (first method))]))
             (some #(or (:classmethod %) (:property %) (:staticmethod %))))
    (throw
     (ex-info "Record methods may not be class methods, properties, or static methods"
              {:methods methods}))))

(defmacro defrecord
  "Define a new Basilisp record.

  The new record will have fields matching the names in ``fields``\\. Fields may be
  referred to unqualified in the bodies of implemented methods.

  Interface or protocol implementations are declared as the name of the interface or
  protocol as a symbol, followed by 1 or more method definitions for that interface.
  Types are not required to declare any interface implementations. Types which do
  declare interface implementations are required to implement all interface methods.
  Failing to implement all interface methods is a compile time error. Types
  implementing ``object`` are not required to implement all ``object`` methods.

  Method declarations should appear as::

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Records objects are created with sensible ``object`` defaults as by ``attrs``\\. New
  records may override ``object`` defaults. An ``__init__`` function is automatically
  created which takes positional arguments matching the order of definition in
  ``fields``. Additionally, given a name ``NewRecord``\\, a factory function will be
  created ``->NewRecord`` which can be used to generate new instances of the record.

  Methods must supply a ``this`` or ``self`` parameter. ``recur`` special forms used
  in the body of a method should not include that parameter, as it will be supplied
  automatically."
  [type-name fields & method-impls]
  (let [ctor-name (with-meta
                    (symbol (str "->" (name type-name)))
                    (meta type-name))
        map-ctor  (with-meta
                    (symbol (str "map->" (name type-name)))
                    (meta type-name))

        record-fields (vec (concat fields
                                   ['^{:default nil} meta
                                    '^{:default {}} _recmap]))
        field-kws     (->> fields (map (comp keyword name)))
        field-kw-set  (set field-kws)

        {:keys [interfaces methods]} (collect-methods method-impls)

        interfaces (concat interfaces
                           '[basilisp.lang.interfaces/IPersistentMap
                             basilisp.lang.interfaces/IWithMeta
                             basilisp.lang.interfaces/IRecord
                             basilisp.lang.interfaces/IReduceKV
                             python/object])

        ;; We can use these gensyms repeatedly and interpolate them in
        ;; multiple layers of syntax quoting, unlike gensyms using # syntax.
        this-gs  (gensym "this")
        other-gs (gensym "other")
        map-gs   (gensym "m")
        key-gs   (gensym "k")]

    (validate-record-fields fields field-kws)
    (validate-record-methods methods)

    `(do
       (declare ~type-name ~ctor-name ~map-ctor)
       (deftype* ~type-name ~record-fields
         :implements [~@interfaces]

         ;; IPersistentMap
         (~'assoc [~this-gs ~'& args#]
          (let [{fields# :fields map# :map} (->> (partition 2 args#)
                                                 (group-by (fn [[k#]]
                                                             (if (contains? ~field-kw-set k#)
                                                               :fields
                                                               :map))))

                new-recmap# (when (seq map#)
                              ["_recmap" (->> (mapcat identity map#)
                                              (apply assoc ~'_recmap))])]
            (->> fields#
                 (map (fn [[k# v#]] [(munge k#) v#]))
                 (mapcat identity)
                 (concat new-recmap#)
                 (apply evolve ~this-gs))))
         (~'cons [~this-gs ~'& elems#]
          (loop [[f# ~'& r#] elems#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (map? f#)
              (recur r#
                     (->> (seq f#)
                          (mapcat identity)
                          (apply assoc new-rec#)))

              (map-entry? f#)
              (recur r# (assoc new-rec# (key f#) (val f#)))

              (vector? f#)
              (recur r# (apply assoc new-rec# f#))

              (py-dict? f#)
              (recur r#
                     (->> (seq (.items f#))
                          (map (fn [[k v]] (map-entry k v)))
                          (apply conj new-rec#)))

              :else
              (throw
               (ex-info "Argument to record conj must be another Map or castable to MapEntry"
                        {:value f#
                         :type  (python/type f#)})))))
         (~'empty [~this-gs]
          (throw
           (python/TypeError
            ~(str "Cannot create empty " type-name))))
         (~'seq [~this-gs]
          (concat
           [~@(map (fn [field]
                     (map-entry (keyword (name field)) field))
                   fields)]
           (seq ~'_recmap)))
         (~'dissoc [~this-gs ~'& ks#]
          (loop [[f# ~'& r#] ks#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (contains? ~field-kw-set f#)
              (recur r#
                     (->> (seq new-rec#)
                          (filter (fn [[k#]]
                                    (not= k# f#)))
                          (mapcat identity)
                          (apply hash-map)))

              (contains? (.- new-rec#  ~'_recmap) f#)
              (recur r#
                     (->> (dissoc (.- new-rec# ~'_recmap) f#)
                          (evolve new-rec# "_recmap")))

              :else
              (recur r# new-rec#))))
         (~'contains [~this-gs ~key-gs]
          (or (~field-kw-set ~key-gs)
              (contains? ~'_recmap ~key-gs)))
         (~'entry [~this-gs ~key-gs]
          (when-let [val# (.val-at ~this-gs ~key-gs)]
            (map-entry ~key-gs val#)))
         (~'val-at [~this-gs ~key-gs ~'& args#]
          (let [[default#] args#]
            (cond
              (contains? ~field-kw-set ~key-gs)
              (python/getattr ~this-gs (-mangle-py-field '~type-name (munge ~key-gs)))

              (contains? ~'_recmap ~key-gs)
              (get ~'_recmap ~key-gs default#))))
         (~'__getitem__ [~this-gs ~key-gs]
          (.val-at ~this-gs ~key-gs))
         (~'__iter__ [~this-gs]
          (python/iter (map first (seq ~this-gs))))
         (~'__len__ [~this-gs]
          (+ ~(count field-kw-set)
             (count ~'_recmap)))

         ;; IWithMeta
         (~'with-meta [~this-gs new-meta#]
          (evolve ~this-gs "meta" new-meta#))

         ;; IRecord
         (~' ^:classmethod create [cls# ~map-gs]
          (cls#
           ~@(map (fn [field-kw]
                    `(get ~map-gs ~field-kw))
                  field-kws)
           nil
           (dissoc ~map-gs ~@field-kws)))
         (~'_record_lrepr [~this-gs py-kwargs#]
          (let [{print-meta :print_meta} (py->lisp py-kwargs#)

                ;; Accessing this type name directly as `(.-__qualname__ this)`
                ;; can fail in cases where the type name is munged and starts
                ;; with a leading double underscore. Python apparently mangles
                ;; the name as it would for any object field prefixed with a
                ;; dunder.
                qual-name (.- (python/type ~this-gs) ~'__qualname__)]
            (cond->> (->> (mapcat identity ~this-gs)
                          (apply hash-map)
                          (repr)
                          (str "#" ~(name *ns*) "." qual-name))
              print-meta (str "^" (repr (meta ~this-gs)) " "))))

         ;; IReduceKV
         (~'reduce-kv [~this-gs f# init#]
          (loop [res#    init#
                 fields# (seq ~this-gs)]
            (cond
              (reduced? res#) (deref res#)
              (seq fields#)   (let [[k# v#] (first fields#)]
                                (recur (f# res# k# v#)
                                       (rest fields#)))
              :else           res#)))

         ;; object
         (~'__eq__ [~this-gs ~other-gs]
          (or (identical? ~this-gs ~other-gs)
              (and (instance? (python/type ~this-gs) ~other-gs)
                   (= [~@fields
                       ~'_recmap]
                      [~@(map (fn [field]
                                `(.- ~other-gs ~field))
                              fields)
                       (.- ~other-gs ~'_recmap)]))))
         (~'__hash__ [~this-gs]
          (hash [~@fields ~'_recmap]))

         ~@methods)

       (defn ~ctor-name
         ~(str
           "Create a new instance of the record " type-name ".")
         ~fields
         (~type-name ~@fields nil {}))

       (defn ~map-ctor
         ~(str
           "Create a new instance of the record " type-name " from a "
           "map whose keys correspond to the fields of " type-name ".")
         [m#]
         ((.- ~type-name ~'create) m#))

       ~type-name)))

;;;;;;;;;;;
;; Insts ;;
;;;;;;;;;;;

(def ^:private unix-epoch
  (datetime.datetime/fromtimestamp 0 datetime.timezone/utc))

(defprotocol Inst
  (inst-ms* [inst]
    "Return the number of milliseconds since the Unix epoch
    (January 1, 1970 00:00:00 UTC)."))

(extend-protocol Inst
  datetime/datetime
  (inst-ms* [inst]
    (-> inst
        (- unix-epoch)
        (.total-seconds)
        (* 1000)
        (int))))

(defn ^:inline inst-ms
  "Return the number of milliseconds since the Unix epoch
  (January 1, 1970 00:00:00 UTC) as an integer."
  [inst]
  (inst-ms* inst))

(defn ^:inline inst?
  "Return ``true`` if ``x`` satisfies protocol :lpy:proto:`Inst`\\."
  [x]
  (satisfies? Inst x))

;;;;;;;;;;;;
;; Reduce ;;
;;;;;;;;;;;;

(require 'basilisp.core.protocols)

(defn reduce
  "Reduce ``coll`` by ``f``\\.

  If ``val`` is not supplied and ``coll`` has no elements, ``f`` will be called with no
  arguments and the result will be returned.

  If ``val`` is not supplied and ``coll`` has one element, the result of
  ``(f (first val))`` is returned.

  If ``val`` is not supplied and ``coll`` has elements, repeatedly reduce ``coll`` by
  calling ``f`` on successive elements in ``coll``\\.

  If ``val`` is supplied and ``coll`` has no elements, return ``val` and ``f`` will not
  be called.

  If ``val`` is supplied and ``coll`` has elements, repeatedly reduce ``coll`` by
  calling ``f`` on successive elements in ``coll``\\, starting with ``val``\\.

  If ``f`` returns a ``reduced`` value at any point, reduction will terminate and the
  reduced value will be returned immediately."
  ([f coll]
   (basilisp.core.protocols/coll-reduce coll f))
  ([f val coll]
   (basilisp.core.protocols/coll-reduce coll f val)))

(defn reduce-kv
  "Reduce an associative ``coll`` by ``f``\\. ``f`` must be a function of 3 arguments:
  the initially supplied value ``init`` (in later invocations, the return from previous
  invocations), the key of an entry of ``coll``\\, and the value of an entry of
  ``coll``\\.

  If ``coll`` has no elements, ``init`` is returned and ``f`` is not called.

  If ``f`` returns a :lpy:fn:`reduced` value at any point, reduction will terminate and
  the reduced value will be returned immediately.

  ``reduce-kv`` may reduce vectors in addition to maps. Vectors have non-negative
  integer keys."
  [f init coll]
  (if (seq coll)
    (basilisp.core.protocols/kv-reduce coll f init)
    init))

(defn run!
  "Runs the procedure ``(proc elem)`` for each element in ``coll`` (presumably for
  side-effects) as by :lpy:fn:`reduce`\\.

  Returns ``nil`` in all cases."
  [proc coll]
  (reduce (fn [_ v] (proc v)) nil coll)
  nil)

;;;;;;;;;;;;;;;;;;
;; IO Utilities ;;
;;;;;;;;;;;;;;;;;;

;; This is a circular import since namespaces using 'ns will always try to refer all
;; symbols from 'basilisp.core. This should be fine since we won't be using anything
;; from core defined below this section, but still this is a bad pattern and should
;; not be replicated.
(require 'basilisp.io)

(defn slurp
  "Open a :lpy:fn:`basilisp.io/reader` instance on ``f`` and read the contents of ``f``
  into a string.

  Options may be provided as key value pairs and will be passed directly to
  ``basilisp.io/reader``\\. Supported reader options depend on which type of reader is
  selected for ``f``\\. Most readers support the ``:encoding`` option.

  If ``f`` is a string, it first is resolved as a URL (via ``urllib.parse.urlparse``\\).
  If the URL is invalid or refers to a filesystem location (via ``file://`` scheme),
  then it will be resolved as a local filesystem path.

  Return the string contents."
  [f & opts]
  (with-open [reader (apply basilisp.io/reader f opts)]
    (.read reader)))

(defn spit
  "Open a :lpy:fn:`basilisp.io/writer` instance on ``f`` and write ``content`` out to
  ``f`` before closing the writer.

  Options may be provided as key value pairs and will be passed directly to
  ``basilisp.io/writer``\\. Supported writer options depend on which type of writer is
  selected for ``f``\\. Most writers support the ``:encoding`` option.

  If ``f`` is a string, it first is resolved as a URL (via ``urllib.parse.urlparse``\\).
  If the URL is invalid or refers to a filesystem location (via ``file://`` scheme),
  then it will be resolved as a local filesystem path.

  ``spit`` does not support writing to non-file URLs.

  Return ``nil``\\."
  [f content & opts]
  (with-open [writer (apply basilisp.io/writer f opts)]
    (.write writer content)
    nil))

;;;;;;;;;;;;;;;;;
;; Transducers ;;
;;;;;;;;;;;;;;;;;

;; Eduction types return a custom iterator type which continually pulls from the
;; input collection (cast as a `seq`). `xf` is called on each value of that
;; sequence and it stores eligible values in a queue (`buf`). `__next__` adds
;; to `buf` as long as there are eligible values from the input collection and
;; yields from `buf` as long as there are values.

(deftype EductionSeq [buf xf ^:mutable coll]
  (__next__ [self]
    (loop [s (seq coll)]
      (if-not s
        (if (python/bool buf)
          (.popleft buf)
          (throw (python/StopIteration)))
        (let [[f & r] s
              v       (xf nil f)]
          (cond
            (reduced? v)      (do (xf nil) (set! coll nil) (recur nil))
            (python/bool buf) (do (set! coll r) (.popleft buf))
            :else             (recur r)))))))

(deftype Eduction [xform coll]
  (__iter__ [self]
    (let [buf (collections/deque)
          xf  (xform
               (fn
                 ([])
                 ([result] result)
                 ([result input]
                  (.append buf input)
                  result)))]
      (EductionSeq buf xf coll))))

(defn eduction
  "Return an iterable which is the application of the transducers ``xform*`` to the
  input collection ``coll``\\. Transducers will be applied to :lpy:fn:`comp` in the
  given order.

  Unlike with :lpy:fn:`sequence`, ``eduction`` returns an iterable type which does not
  cache its results. As such, any computation will be performed again on each
  iteration.

  Eductions are likely to be more efficient in contexts where you would plan to
  consume the entire input collection and only plan to use that computation once.
  For cases with an infinite input sequence or if you need caching, ``sequence`` is
  preferred."
  [& args]
  (let [[xform* coll] ((juxt butlast last) args)
        xform         (apply comp xform*)]
    (Eduction xform coll)))

(defn completing
  "Given a reducing function of two arguments, ``f``\\, return a function with both 0-,
  1-, and 2-arities appropriate for :lpy:fn:`transduce`. The 0-arity will return a call
  to ``f`` with no arguments. The 1-arity will call ``cf`` on its argument. The 2-arity
  will call ``f`` directly with both of its arguments.

  If ``cf`` is not given, :lpy:fn:`identity` will be used."
  ([f]
   (completing f identity))
  ([f cf]
   (fn
     ([] (f))
     ([result] (cf result))
     ([result input] (f result input)))))

(defn halt-when
  "Return a transducer which ends the tranducing process the first time ``pred``
  returns a truthy value for an input.

  If ``retf`` is given, it will be passed two arguments if a halt occurs. The first
  argument is the current result and the second is the input which triggered the halt.
  The return value of calling ``retf`` will be the return value of the transducer.

  If ``retf`` is not given, the default ``retf`` will return the value which triggered
  the halt."
  ([pred]
   (halt-when pred (fn [_ input] (reduced input))))
  ([pred retf]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (if (pred input)
          (ensure-reduced (retf result input))
          (rf result input)))))))

(defn sequence
  "Coerces ``coll`` to a possibly empty sequence. If ``coll`` is ``nil``\\, return
  ``()``\\.

  When a transducer ``xform`` is supplied, returns a lazy sequence of the transform
  to elements of ``coll``\\. If multiple collections are provided, ``xform`` must
  support as many arguments as there are collections.

  If multiple collections are provided, the resulting sequence will terminate when
  any one of the inputs is exhausted."
  ([coll]
   (if (seq? coll)
     coll
     (or (seq coll) '())))
  ([xform coll]
   (let[xf (xform (fn
                    ([] (queue))
                    ([result] result)
                    ([result input]
                     (conj result input))))

        create-sequence (fn create-sequence
                          [coll]
                          (lazy-seq
                           (let [result (when (seq coll)
                                          (let [elem (xf (xf) (first coll))]
                                            (if (reduced? elem)
                                              @elem
                                              (concat elem (create-sequence (rest coll))))))]
                             (xf (unreduced result)))))]
     (create-sequence coll)))
  ([xform coll & colls]
   (let[xf (xform (fn
                    ([] (queue))
                    ([result] result)
                    ([result input]
                     (conj result input))))

        create-sequence (fn create-sequence
                          [coll & colls]
                          (lazy-seq
                           (let [result (when (and (seq coll) (every? seq colls))
                                          (let [elem (apply xf (xf) (first coll) (map first colls))]
                                            (if (reduced? elem)
                                              @elem
                                              (concat elem (apply create-sequence (rest coll) (map rest colls))))))]
                             (xf (unreduced result)))))]
     (apply create-sequence coll colls))))

(defn transduce
  "Reduce ``coll`` by the transducing function ``xf`` (created as ``(xform f)``\\).

  If ``coll`` is empty, return ``init`` without calling ``f``\\. If ``init`` is not
  given, ``f`` will be called with no arguments to produce it.

  The transducing process will eagerly consume the input collection, calling ``xf`` on
  the result of the previous call (or `init` on the first invocation) and the next
  value from the input collection, until either the collection is exhausted or ``xf``
  returns a ``reduced`` value. In both cases, the ``xf`` 's 1-arity will be called with
  result and that result will be returned."
  ([xform f coll]
   (transduce xform f (f) coll))
  ([xform f init coll]
   (let [xf (xform f)]
     (if (seq coll)
       (loop [result init
              coll   (seq coll)]
         (cond
           (reduced? result) (xf @result)
           (seq coll)        (recur (xf result (first coll)) (rest coll))
           :else             (xf result)))
       init))))

(defn into
  "Return a new collection created by adding all of the elements of ``from`` to the
  existing to collection ``to``, as by ``conj``.

  A transducer may be provided as ``xform`` to transform the elements as they are
  copied.

  ``into`` will attempt to use transient collections whenever possible to improve
  performance."
  ([] [])
  ([to] to)
  ([to from]
   (if (instance? basilisp.lang.interfaces/IEvolveableCollection to)
     (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))
     (reduce conj to from)))
  ([to xform from]
   (if (instance? basilisp.lang.interfaces/IEvolveableCollection to)
     (with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))
     (transduce xform conj to from))))

(defn cat
  "A transducer which concatenates input collections into the reduced result."
  [rf]
  (fn
    ([] (rf))
    ([result] (rf result))
    ([result input]
     (reduce rf result input))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Custom Data Readers ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defmulti ^:private make-custom-data-readers
  (fn [obj ^:no-warn-when-unused metadata]
    (type obj)))

(defmethod make-custom-data-readers :default
  [obj metadata]
  (throw (ex-info "Not a valid data-reader map" (assoc metadata :object obj))))

(defmethod make-custom-data-readers basilisp.lang.interfaces/IPersistentMap
  [mappings metadata]
  (reduce (fn [m [k v]]
            (let [v' (if (qualified-symbol? v)
                       (intern (create-ns (symbol (namespace v)))
                               (symbol (name v)))
                       v)]
              (cond
                (not (qualified-symbol? k))
                (throw
                 (ex-info "Invalid tag in data-readers. Expected qualified symbol."
                          (merge metadata {:form k})))

                (not (ifn? v'))
                (throw (ex-info "Invalid reader function in data-readers"
                                (merge metadata {:form v})))

                :else
                (assoc m (with-meta k metadata) v'))))
          mappings
          mappings))

(defmethod make-custom-data-readers importlib.metadata/EntryPoint
  [entry-point metadata]
  (make-custom-data-readers (.load entry-point)
                            (assoc metadata
                                   :basilisp.entry-point/name (.-name entry-point)
                                   :basilisp.entry-point/group (.-group entry-point))))

(defmethod make-custom-data-readers pathlib/Path
  [file metadata]
  (make-custom-data-readers
   (with-open [rdr (basilisp.io/reader file)]
     (read (if (.endswith (name file) "cljc")
             {:eof nil :read-cond :allow}
             {:eof nil})
           rdr))
   (assoc metadata :file (str file))))

(defn- data-readers-entry-points []
  (when (#{"true" "t" "1" "yes" "y"} (.lower
                                      (os/getenv
                                       "BASILISP_USE_DATA_READERS_ENTRY_POINT"
                                       "true")))
    (#?@(:lpy39-  [get (.entry_points importlib/metadata)]
         :lpy310+ [.entry_points importlib/metadata ** :group])
     "basilisp_data_readers")))

(defn- data-readers-files
  "Return a list of :external:py:class:`pathlib/Path`s pointing to
  `data_readers.lpy` and `data_readers.cljc` found in each top
  directory and up to its immediate subdirectories of
  the :external:py:data:`sys.path` entries. The list is ordered such
  that entries with the filename `data_readers.lpy` appear first."
  []
  (->> sys/path
       (mapcat (fn [dir] (when (os.path/isdir dir)
                           (-> (comp
                                (mapcat (fn [^os/DirEntry entry]
                                          (if (.is-dir entry)
                                            ;; immediate subdirectory
                                            (os/scandir (.-path entry))
                                            ;; top level file
                                            [entry])))
                                (filter #(.is-file %))
                                (map #(pathlib/Path (.-path %)))
                                (filter (comp #{"data_readers.lpy" "data_readers.cljc"} name)))
                               (eduction (os/scandir dir))))))
       (group-by #(.-parent %))
       vals
       ;; Only load one data readers file per directory and prefer
       ;; `data_readers.lpy` to `data_readers.cljc`
       (map #(first (sort-by name > %)))))

(defn- load-data-readers []
  (alter-var-root
   #'*data-readers*
   (fn [mappings additional-mappings]
     (reduce (fn [m [k v]]
               (if (not= (get m k v) v)
                 (throw (ex-info "Conflicting data-reader mapping"
                                 (merge (meta k) {:conflict k, :mappings m})))
                 (assoc m k v)))
             mappings
             additional-mappings))
   ;; Can't use `read` when altering `*data-readers*` so do reads ahead of time
   (->> (concat (data-readers-files)
                (data-readers-entry-points))
        (mapcat #(make-custom-data-readers % nil))
        doall)))

(load-data-readers)

;;;;;;;;;;;;;;;;;;;;;;;;
;; Stateful Iteration ;;
;;;;;;;;;;;;;;;;;;;;;;;;

(defn iteration
  "Return a reducible sequence via repeated calls to ``step``, a function of a
  \"continuation token\", ``k``.

  ``step`` will initially be called with ``initk``. Given a return value of that
  call, ``ret``, if ``(somef ret)`` returns a truthy value, the result of ``(vf ret)``
  will be included in the sequence. Otherwise, the sequence will terminate and
  neither ``kf`` nor ``vf`` will be called. If the iteration continues, ``step``
  will be called again with the result of ``(kf ret)``.

  Only ``step`` is a required argument. ``somef`` defaults to :lpy:fn:`some?`,
  ``vf`` and ``kf`` default to :lpy:fn:`identity`, and ``initk`` defaults to ``nil``.

  For the purposes of this function, ``step`` should be considered an impure
  function and repeated calls to it even with the same token may not necesarily
  return the same values."
  [step & {:keys [somef vf kf initk] :or {somef some? vf identity kf identity initk nil}}]
  (lazy-seq
   (let [ret (step initk)]
     (when (somef ret)
       (cons (vf ret) (iteration step :somef somef :vf vf :kf kf :initk (kf ret)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn replace
  "Replace elements of the vector/seq ``coll`` with matching elements from the
  associative collection ``smap``\\, if they exist.

  Return a transducer if no collection is provided."
  ([smap]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] (rf result))
       ([result input]
        (->> (if-let [newv (get smap input)]
               newv
               input)
             (rf result))))))
  ([smap coll]
   (if (vector? coll)
     (persistent!
      (reduce (fn [res v]
                (->> (if-let [newv (get smap v)]
                       newv
                       v)
                     (conj! res)))
              (transient [])
              coll))
     (map (fn [v]
            (if-let [newv (get smap v)]
              newv
              v))
          coll))))

(defn select-keys
  "Return a map with only the keys of ``m`` which are in ``ks``\\."
  [m ks]
  (persistent!
   (reduce (fn [new-map k]
             (if (contains? m k)
               (assoc! new-map k (get m k))
               new-map))
           (transient {})
           ks)))

(defn update-keys
  "Update the keys in map ``m`` by applying a function of one argument, ``f``\\,
  to every key.

  ``f`` must return a unique key for every input key, otherwise the behavior of
  this function is undefined."
  [m f]
  (with-meta
    (persistent!
     (reduce-kv (fn [m k v]
                  (assoc! m (f k) v))
                (transient {})
                m))
    (meta m)))

(defn update-vals
  "Update the values in map ``m`` by applying a function of one argument, ``f``\\,
  to every value."
  [m f]
  (with-meta
    (persistent!
     (reduce-kv (fn [m k v]
                  (assoc! m k (f v)))
                ;; using the incoming map as a base means we could potentially
                ;; share structure
                (transient
                 (if (instance? basilisp.lang.interfaces/IEvolveableCollection m)
                   m
                   {}))
                m))
    (meta m)))

;;;;;;;;;;
;; Taps ;;
;;;;;;;;;;

(defonce ^:private tap-queue
  (->> (os/getenv "BASILISP_TAP_QUEUE_SIZE" 1024)
       (python/int)
       (py-queue/Queue)))

(defonce ^:private tapset (atom {}))

(defonce ^:private tap-thread
  (delay
   (doto (threading/Thread
          **
          :target (fn []
                    (loop []
                      (let [{:keys [topic val]} (.get tap-queue)
                            topic-tapset        (get @tapset topic #{})]
                        (doseq [tap (seq topic-tapset)]
                          (try
                            (tap val)
                            (catch python/Exception _ nil)))
                        (.task-done tap-queue))
                      (recur)))
          :daemon true)
     (.start))))

(defn add-tap
  "Add ``tf``\\, a function of one argument, to the tap set for the topic ``topic``\\. If
  no topic is given, the default topic is used.

  Tap functions are called only with values from calls to :lpy:fn:`tap>` with the topic
  they are added with.

  Taps may be removed from the tap set for a topic (or with the default topic) by a
  matching call to :lpy:fn:`remove-tap`. Taps are identified only by their identity, so
  hang on to a reference if you do need to remove the tap.

  Returns `nil`."
  ([tf]
   (add-tap :basilisp.core.tap/default tf))
  ([topic tf]
   (force tap-thread)
   (swap! tapset
          (fn [old-state]
            (let [topic-tapset (get old-state topic #{})]
              (->> (conj topic-tapset tf)
                   (assoc old-state topic)))))
   nil))

(defn remove-tap
  "Remove a tap function from the tap set added by :lpy:fn:`add-tap`.

  Tap functions may only be removed from the tap set corresponding to the topic they
  were added with. If no topic is given, the default topic is used.

  Returns ``nil`` in all cases."
  ([tf]
   (remove-tap :basilisp.core.tap/default tf))
  ([topic tf]
   (force tap-thread)
   (swap! tapset
          (fn [old-state]
            (let [topic-tapset (get old-state topic #{})]
              (->> (disj topic-tapset tf)
                   (assoc old-state topic)))))
   nil))

(defn tap>
  "Send the value ``val`` to all tap functions registered for the topic. If no topic
  is given, the default topic is used.

  ``tap>`` will never block, though if the tap queue is full then tap values may be
  dropped.

  Returns true if ``val`` was sent to the queue, ``false`` if ``val`` was dropped."
  ([val]
   (tap> :basilisp.core.tap/default val))
  ([topic val]
   (force tap-thread)
   (try
     (.put-nowait tap-queue {:topic topic :val val})
     true
     (catch queue/Full _ false))))
