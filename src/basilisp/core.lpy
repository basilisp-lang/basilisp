(in-ns 'basilisp.core)

(def ^{:doc      "Create a list from the arguments."
       :arglists '([& args])}
  list
  (fn* list [& args] args))

(def
  ^{:doc      "If o is a Seq, return the first element from o. If o is nil, return
               nil. Otherwise, coerces o to a Seq and returns the first."
    :arglists '([seq])}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc      "If o is a Seq, return the elements after the first in o. If o is nil,
               returns an empty seq. Otherwise, coerces o to a seq and returns the rest."
    :arglists '([seq])}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc      "Calls rest on o. If o returns an empty sequence or nil, returns nil.
               Otherwise, returns the elements after the first in o."
    :arglists '([seq])}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc      "Returns the second element in a Seq."
    :arglists '([seq])}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc      "Returns the first element in the first element of a Seq."
    :arglists '([seq])}
  ffirst
  (fn* ffirst [seq] (first (first seq))))

(def
  ^{:doc      "Creates a new sequence where o is the first element and seq is the rest.
               If seq is nil, return a list containing o. If seq is not a Seq, attempt
               to coerce it to a Seq and then cons o onto the resulting sequence."
    :arglists '([o seq])}
  cons
  (fn* cons [o seq] (basilisp.lang.runtime/cons o seq)))

(def ^{:doc      "Return the metadata from o, or nil if there is no metadata."
       :arglists '([o])}
  meta
  (fn* meta [o]
       (if (python/hasattr o "meta")
         (.-meta o)
         nil)))

(def ^{:doc      "Return an object of the same type and representing the same value as
                  o with meta as its metadata. Of Basilisp's builtin types, only those
                  implementing the interface IWithMeta support `with-meta`."
       :arglists '([o meta])}
  with-meta
  (fn* with-meta [o meta]
       (if meta
         (.with-meta o meta)
         o)))

(def ^:macro ^:redef let
  (fn* let [&env &form & decl]
       (cons 'let* decl)))

(def ^:macro ^:redef loop
  (fn* loop [&env &form & decl]
       (cons 'loop* decl)))

(def ^:macro ^:redef fn
  (fn* fn [&env &form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def ^{:doc      "Returns its argument unmodified."
       :arglists '([v])}
  identity
  (fn identity [v] v))

(def
  ^{:doc      "Return true if obj is an instance of class."
    :arglists '([class obj])}
  instance?
  (fn instance? [class obj]
    (python/isinstance obj class)))

(def
  ^{:doc      "Return true if obj is a boolean."
    :arglists '([o])}
  boolean?
  (fn boolean? [o]
    (instance? python/bool o)))

(def
  ^{:doc      "Return true if obj is a float."
    :arglists '([o])}
  float?
  (fn float? [o]
    (instance? python/float o)))

(def
  ^{:doc      "Return true if obj is an integer."
    :arglists '([o])}
  integer?
  (fn integer? [o]
    (instance? python/int o)))

(def
  ^{:doc      "Return true if obj is a string."
    :arglists '([o])}
  string?
  (fn string? [o]
    (instance? python/str o)))

(def
  ^{:doc      "Return true if obj is a symbol."
    :arglists '([o])}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc      "Return true if obj is a keyword."
    :arglists '([o])}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc      "Return true if o is a list."
    :arglists '([o])}
  list?
  (fn list? [o]
    (instance? basilisp.lang.interfaces/IPersistentList o)))

(def
  ^{:doc      "Return true if o is a map."
    :arglists '([o])}
  map?
  (fn map? [o]
    (instance? basilisp.lang.interfaces/IPersistentMap o)))

(def
  ^{:doc      "Return true if o is a set."
    :arglists '([o])}
  set?
  (fn set? [o]
    (instance? basilisp.lang.interfaces/IPersistentSet o)))

(def
  ^{:doc      "Return true if o is a vector."
    :arglists '([o])}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.interfaces/IPersistentVector o)))

(def
  ^{:doc      "Return true if o implements Seq."
    :arglists '([o])}
  seq?
  (fn seq? [o]
    (instance? basilisp.lang.interfaces/ISeq o)))

(def ^{:doc      "Coerce the argument o to a Seq. If o is nil, return nil."
       :arglists '([o])}
  seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def ^{:doc      "Apply function f to the arguments provided.

                  The last argument must always be coercible to a Seq. Intermediate
                  arguments are not modified."
       :arglists '([f & args])}
  apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def ^{:doc      "Return an object of the same type and representing the same value as o
                  (as by `with-meta`) with the new object's metadata set to the value of
                  `(apply f (meta o) & args)`."
       :arglists '([o f & args])}
  vary-meta
  (fn* vary-meta [o f & args]
       (with-meta o (apply f (meta o) args))))

(def ^{:doc      "Concatenate the sequences given by seqs into a single Seq."
       :arglists '([& seqs])}
  concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def
  ^{:doc      "Create a hash map from pairs of input arguments."
    :arglists '([& kvs])}
  hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def
  ^{:doc      "Create a set from the input arguments."
    :arglists '([& members])}
  hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def
  ^{:doc      "Return a set with the contents of coll."
    :arglists '([coll])}
  set
  (fn set
    [coll]
    (^:allow-builtins basilisp.lang.set/set coll)))

(def
  ^{:doc      "Create a vector from the input arguments."
    :arglists '([& elems])}
  vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def
  ^{:doc      "Return a vector with the contents of coll."
    :arglists '([coll])}
  vec
  (fn vec
    [coll]
    (basilisp.lang.vector/vector coll)))

;;;;;;;;;;;; full support for syntax quote begins here ;;;;;;;;;;;;

(def
  ^{:doc      "Return the length of coll as by Python's len builtin. If the collection
               does not respond to __len__, then count it manually."
    :arglists '([coll])}
  count
  (fn count [coll]
    (basilisp.lang.runtime/count coll)))

(def
  ^{:doc      "Returns a basilisp.lang.exception/ExceptionInfo instance with
               the given message and data."
    :arglists '([msg data])}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:doc      "Associate keys to values in associative data structure m. If m is nil,
               returns a new map with key-values kvs."
    :arglists '([m k v] [m k v & kvs])}
  assoc
  (fn assoc
    ([m k v]
     (basilisp.lang.runtime/assoc m k v))
    ([m k v & kvs]
     (apply basilisp.lang.runtime/assoc m k v kvs))))

(def
  ^{:doc      "Conjoin xs to collection. New elements may be added in different positions
               depending on the type of coll. conj returns the same type as coll. If coll
               is nil, return a list with xs conjoined."
    :arglists '([coll x] [coll x & xs])}
  conj
  (fn conj
    ([coll x]
     (basilisp.lang.runtime/conj coll x))
    ([coll x & xs]
     (apply basilisp.lang.runtime/conj coll x xs))))

(def
  ^{:macro    true
    :doc      "Define a new function with an optional docstring."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defn
  (fn defn [&env &form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (python/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta (if (map? (first body))
                  (first body)
                  nil)
          fname  (if fmeta
                   (vary-meta name conj fmeta)
                   name)
          fname  (if doc
                   (vary-meta fname assoc :doc doc)
                   (vary-meta fname conj fmeta))
          body   (if fmeta
                   (rest body)
                   body)
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       (apply list sigs)))
                   (list (first body)))
          fname  (vary-meta fname assoc :arglists (list 'quote fsigs))
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))]
      `(def ~fname
         (fn ~fname
              ~@body)))))

(defn nth
  "Returns the `i`th element of `coll` (0-indexed), if it exists or `nil`
  otherwise. If `i` is out of bounds, throws an `IndexError` unless `notfound`
  is specified.

  `coll` may be any sequential collection type (such as a list or vector), string,
  or `nil`. If `coll` is not one of the supported types, a `TypeError` will be
  thrown."
  ([coll i]
   (basilisp.lang.runtime/nth coll i))
  ([coll i notfound]
   (basilisp.lang.runtime/nth coll i notfound)))

(defn nthnext
  "Returns the nth next sequence of coll.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn nthrest
  "Returns the nth rest sequence of coll, or coll if i is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn nfirst
  "Return the result of calling (next (first v))."
  [v]
  (next (first v)))

(defn nnext
  "Return the result of calling (next (next v))."
  [v]
  (next (next v)))

(defn last
  "Return the last item in a seq, or nil if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(defn str
  "Create a string representation of o."
  ([] "")
  ([o] (basilisp.lang.runtime/lstr o))
  ([o & args]
   (let [coerce (fn [in out]
                  (if (seq (rest in))
                    (recur (rest in)
                           (conj out (basilisp.lang.runtime/lstr (first in))))
                    (conj out (basilisp.lang.runtime/lstr (first in)))))
         strs   (coerce (conj args o) [])]
     (.join "" strs))))

(defn symbol
  "Create a new symbol with name and optional namespace ns."
  ([name]
   (basilisp.lang.symbol/symbol name))
  ([ns name]
   (basilisp.lang.symbol/symbol name ns)))

(defn keyword
  "Create a new keyword with name and optional namespace ns. Keywords
  will have the colon prefix added automatically, so it should not be
  provided."
  ([name]
   (basilisp.lang.keyword/keyword name))
  ([ns name]
   (basilisp.lang.keyword/keyword name ns)))

(defn name
  "Return the name of a string, symbol, or keyword."
  [v]
  (if (string? v)
    v
    (.-name v)))

(defn namespace
  "Return the namespace of a symbol or keyword, or nil if no namespace."
  [v]
  (.-ns v))

(def
  ^{:macro    true
    :doc      "Define a new macro like defn. Macro functions are available to the
               compiler during macroexpansion."
    :arglists '([name & body] [name doc? & body] [name doc? attr-map? & body])}
  defmacro
  (fn defmacro [&env &form name & body]
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          body   (if doc
                   (rest body)
                   body)
          fmeta  (if (map? (first body))
                   (first body)
                   nil)
          body   (if fmeta
                   (rest body)
                   body)
          fname  (if doc
                   (vary-meta name assoc :doc doc :macro true)
                   (vary-meta name assoc :macro true))
          multi? (list? (first body))
          fsigs  (if multi?
                   (loop [arities body
                          sigs    []]
                     (if (seq arities)
                       (recur (rest arities)
                              (conj sigs (ffirst arities)))
                       `(quote ~(apply list sigs))))
                   `(quote ~(list (first body))))
          fname  (vary-meta fname assoc :arglists fsigs)

          add-implicit-args (fn [body]
                              (cons
                               (if (vector? (first body))
                                 (apply vector
                                        (cons '&env
                                              (cons '&form
                                                    (first body))))
                                 (throw
                                  (ex-info "Expected an argument vector"
                                           {:found (first body)})))
                               (rest body)))

          add-args-for-each (fn [in out]
                              (if (seq (rest in))
                                (recur (rest in)
                                       (conj out (add-implicit-args (first in))))
                                (conj out (add-implicit-args (first in)))))

          body (if multi?
                 (add-args-for-each body [])
                 (add-implicit-args body))]
      `(defn ~fname
         ~@body))))

(defmacro defasync
  "Define a new asynchronous function as by `defn`.

  Asynchronous functions are compiled as Python `async def`s."
  [name & body]
  `(defn ~(vary-meta name assoc :async true)
     ~@body))

(defmacro defn-
  "Define a new private function as by `defn`."
  [name & body]
  `(defn ~(vary-meta name assoc :private true)
     ~@body))

(defn macroexpand-1
  "Macroexpand form one time. Returns the macroexpanded form. The return
  value may still represent a macro. Does not macroexpand child forms."
  [form]
  (basilisp.lang.compiler/macroexpand-1 form))

(defn macroexpand
  "Repeatedly macroexpand form as by macroexpand-1 until form no longer
  represents a macro. Returns the expanded form. Does not macroexpand child
  forms."
  [form]
  (basilisp.lang.compiler/macroexpand form))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Comparisons & Macros ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro if-not
  "Evaluate cond and if it is true, return false-cond. Otherwise return
  true-cond."
  [cond true-cond false-cond]
  `(if ~cond
     ~false-cond
     ~true-cond))

(defmacro if-let
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is true. Otherwise, return the
  false expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if expr#
       (let [~(first binding) expr#]
         ~true-cond)
       ~false-cond)))

(defmacro if-some
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is not nil. Otherwise, return the
  false expression without binding the name."
  [binding true-cond false-cond]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)

  `(let* [expr# ~(second binding)]
     (if (operator/is- expr# nil)
       ~false-cond
       (let [~(first binding) expr#]
         ~true-cond))))

(defmacro when
  "Evaluate cond and if it is true, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     (do ~@body)
     nil))

(defmacro when-let
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is true. Return nil otherwise."
  [binding & body]
  `(if-let ~binding
     (do ~@body)
     nil))

(defmacro when-first
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is not nil. Return nil otherwise."
  [binding & body]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)
  `(let* [expr# (first ~(second binding))]
     (if expr#
       (let [~(first binding) expr#]
         ~@body)
       nil)))

(defmacro when-some
  "Evaluate the binding as with let, binding the given name for use in the
  true expression iff the binding expression is not nil. Return nil otherwise."
  [binding & body]
  `(if-some ~binding
     (do ~@body)
     nil))

(defmacro when-not
  "Evaluate cond and if it is false, execute body in an implicit do block."
  [cond & body]
  `(if ~cond
     nil
     (do ~@body)))

(defmacro and
  "Evaluate the expressions from left to right. If all expressions are true,
  return the result of the final expression. Otherwise, returns the first
  false expression. Calling and with no arguments returns true."
  ([] true)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          (and ~@(rest args))
          expr#))
     (first args))))

(defmacro or
  "Evaluate the expressions from left to right. Returns the first true
  expression. Otherwise, returns the final falsy expression. Calling or
  with no arguments returns nil."
  ([] nil)
  ([& args]
   (if (seq (rest args))
     `(let* [expr# ~(first args)]
        (if expr#
          expr#
          (or ~@(rest args))))
     (first args))))

(defmacro cond
  "Given groups of test/expression pairs, evaluate each test and, if
  true, return the expression. Otherwise, continue through until reaching
  the final expression."
  [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (throw
             (ex-info "cond requires an even number of forms"
                      {:first (first clauses)})))
          (cons 'basilisp.core/cond (nthrest clauses 2)))))

(defmacro dotimes
  "Repeatedly execute body (likely for side effects) while the binding name is
  repeatedly rebound from 0 to the binding value, n, minus 1. Returns nil."
  [binding & body]
  (if (operator/ne 2 (count binding))
    (throw
     (ex-info "bindings take the form [name expr]"
              {:bindings binding}))
    nil)
  (let [nm (first binding)]
    `(loop [~nm 0]
       (when (< ~nm ~(second binding))
         ~@body
         (recur (inc ~nm))))))

(defmacro while
  "Execute body repeatedly (likely for side effects) until cond returns false.
  Return nil."
  [cond & body]
  `(loop []
     (when ~cond
       ~@body
       (recur))))

(defn not
  "Return the logical negation of expr."
  [expr]
  (if expr false true))

(defn apply-kw
  "Apply function f to the arguments provided, passing the keys from
  the final argument (which must be a map) as Python keyword arguments
  to f. Keywords and symbol keys will be converted to strings and munged
  to be legal Python identifiers, to avoid errors.

  The last argument must always be coercible to a Mapping. Intermediate
  arguments are not modified."
  [f & args]
  (basilisp.lang.runtime/apply-kw f args))

(defn hash
  "Return the hash code for its argument."
  [x]
  (python/hash x))

(defn identical?
  "Return true if x and y are the same object, otherwise false."
  [x y]
  (operator/is_ x y))

(defn =
  "Return true if x and y are equal, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (basilisp.lang.runtime/equals x (first args))
       (recur (first args) (rest args))
       false)
     (basilisp.lang.runtime/equals x (first args)))))

(defn not=
  "Return true if x and y are not equal, otherwise false."
  [& args]
  (not (apply = args)))

(defn >
  "Return true if arguments are monotonically decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/gt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/gt x (first args)))))

(defn >=
  "Return true if arguments are decreasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/ge x (first args))
       (recur (first args) (rest args))
       false)
     (operator/ge x (first args)))))

(defn <
  "Return true if arguments are monotonically increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/lt x (first args))
       (recur (first args) (rest args))
       false)
     (operator/lt x (first args)))))

(defn <=
  "Return true if arguments are increasing, otherwise false."
  ([_] true)
  ([x & args]
   (if (seq (rest args))
     (if (operator/le x (first args))
       (recur (first args) (rest args))
       false)
     (operator/le x (first args)))))

(defn distinct?
  "Return true if no two arguments are equal."
  [& args]
  (= (count (vec args))
     (count (set args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Management Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn deref
  "Dereference a delay or atom and returns its contents.

  If o is an object implementing IBlockingDeref and timeout-s and
  timeout-val are supplied, deref will wait at most timeout-s seconds,
  returning timeout-val if timeout-s seconds elapse and o has not
  returned."
  ([o]
   (basilisp.lang.runtime/deref o))
  ([o timeout-s timeout-val]
   (basilisp.lang.runtime/deref o timeout-s timeout-val)))

(defn compare-and-set!
  "Atomically set the value of atom to new-val if and only if old-val
  is the current value of the atom."
  [atom old-val new-val]
  (.compare-and-set atom old-val new-val))

(defn reset!
  "Reset the value of an atom to v without regard to the previous value.
  Return the new value."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      v
      (recur atom v))))

(defn reset-vals!
  "Reset the value of an atom to v without regard to the previous value.
  Return a vector containing the new value and the old value in that order."
  [atom v]
  (let [current (deref atom)]
    (if (compare-and-set! atom current v)
      [v current]
      (recur atom v))))

(defn swap!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return the new value."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      new-val
      (recur atom f args))) )

(defn swap-vals!
  "Atomically swap the value of an atom to the return value of (apply f
  current-value args). The function f may be called multiple times while
  swapping, so should be free of side effects. Return a vector containing
  the new value and the old value in that order."
  [atom f & args]
  (let [current (deref atom)
        new-val (apply f current args)]
    (if (compare-and-set! atom current new-val)
      [new-val current]
      (recur atom f args))))

(defn atom
  "Return an Atom containing v. The value of an Atom at any point in time
  may be returned by deref'ing it. The value of an atom may be reset using
  reset! and may be swapped using swap!. All operations on an atom occur
  atomically."
  [v]
  (basilisp.lang.atom/Atom v))

(defn realized?
  "Return true if the delay, future, lazy sequence, or promise has been
  realized."
  [o]
  (.-is-realized o))

(defmacro delay
  "Takes a body of expressions producing any value. Will not produce a
  value until deref'ed. The result is cached and returned in future
  derefs."
  [& body]
  (list 'basilisp.lang.delay/Delay
        (concat '(fn* []) body)))

(defn delay?
  "Return true if x names a delay."
  [x]
  (instance? basilisp.lang.delay/Delay x))

(defn force
  "If x is a Delay, returned the possibly cached value of x. Otherwise, return
  x."
  [x]
  (if (delay? x)
    @x
    x))

(defn promise
  "Return a promise object which can be set exactly once using `deliver`.
  Readers may block waiting for the value of the promise using `@` or `deref`.
  If the value has already been realized, then reading the value of the
  promise will not block. Readers may check if the promise has been delivered
  using `realized?`."
  []
  (basilisp.lang.promise/Promise))

(defn deliver
  "Deliver the value v to the promise p. If p already has a value, then a
  subsequent call to `deliver` for p will have no effect."
  [p v]
  (.deliver p v))

;;;;;;;;;;;;;
;; Futures ;;
;;;;;;;;;;;;;

(import* atexit)

(def ^:dynamic *executor-pool*
  (basilisp.lang.futures/ThreadPoolExecutor))

(atexit/register (.-shutdown *executor-pool*))

(defn future-call
  "Call the no args function f in another thread. Returns a Future object.
  The value returned by f can be fetched using `deref` or `@`, though
  doing so may block unless the `deref` with a timeout argument is used."
  ([f]
   (future-call f *executor-pool*))
  ([f pool]
   (.submit pool f)))

(defmacro future
  "Execute the expressions of body in another thread. Returns a Future object.
  The value returned by the body can be fetched using `deref` or `@`, though
  doing so may block unless the `deref` with a timeout argument is used."
  [& body]
  `(future-call
    (fn* []
         ~@body)))

(defn future-cancel
  "Attempt to cancel the Future fut. If the future can be cancelled, return
  true. Otherwise, return false."
  [fut]
  (.cancel fut))

(defn future?
  "Return true if x is a future, false otherwise."
  [x]
  (instance? basilisp.lang.futures/Future x))

(defn future-cancelled?
  "Return true if the Future fut has been cancelled, false otherwise."
  [fut]
  (.cancelled fut))

(defn future-done?
  "Return true if the Future fut is done, false otherwise."
  [fut]
  (.done fut))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x y] (operator/add x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/add x y) (first args) (rest args))
     (operator/add x y))))

(defn -
  "Subtract the arguments. If one argument given, returns the negation
  of that argument."
  ([x] (operator/neg x))
  ([x y] (operator/sub x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/sub x y) (first args) (rest args))
     (operator/sub x y))))

(defn *
  "Multiply the arguments. If no arguments given, returns 1."
  ([] 1)
  ([x] x)
  ([x y] (operator/mul x y))
  ([x y & args]
   (if (seq args)
     (recur (operator/mul x y) (first args) (rest args))
     (operator/mul x y))))

(defn /
  "Divide the arguments. If no arguments given, returns the inverse of
  the argument."
  ([x] (basilisp.lang.runtime/divide 1 x))
  ([x y] (basilisp.lang.runtime/divide x y))
  ([x y & args]
   (if (seq args)
     (recur (basilisp.lang.runtime/divide x y) (first args) (rest args))
     (basilisp.lang.runtime/divide x y))))

(defn mod
  "Returns the modulo of num and div."
  [num div]
  (operator/mod num div))

(defn quot
  "Returns the quotient of num and div."
  [num div]
  (basilisp.lang.runtime/quotient num div))

(defn rem
  "Returns the remainder of num and div."
  [num div]
  (- num (* div (quot num div))))

(defn inc
  "Increment the argument by 1."
  [x]
  (+ x 1))

(defn dec
  "Decrement the argument by 1."
  [x]
  (- x 1))

(defn min
  "Return the minimum of the arguments."
  [& args]
  (python/min args))

(defn max
  "Return the maximum of the arguments."
  [& args]
  (python/max args))

(defn numerator
  "Return the numerator of a Fraction."
  [frac]
  (.-numerator frac))

(defn denominator
  "Return the denominator of a Fraction."
  [frac]
  (.-denominator frac))

(defn sort
  "Return a sorted sequence of the elements from coll."
  ([coll]
   (basilisp.lang.runtime/sort coll))
  ([cmp coll]
   (basilisp.lang.runtime/sort coll cmp)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Simple Predicates ;;
;;;;;;;;;;;;;;;;;;;;;;;

(import* decimal fractions uuid)

(defn any?
  "Return true for any x."
  [_]
  true)

(defn associative?
  "Return true if x implements IAssociative."
  [x]
  (instance? basilisp.lang.interfaces/IAssociative x))

(defn bytes?
  "Return true if x is a byte array (the Python `bytearray` type).

  Note that Python supplies byte string and byte array objects in its standard
  library. This function complies with Clojure's standard library in returning
  true iff x is a Python bytearray. To check if an object is a Python `bytes`,
  use `byte-string?`."
  [x]
  (instance? python/bytearray x))

(defn byte-string?
  "Return true if x is a byte string (the Python `bytes` type).

  Note that Python supplies byte string and byte array objects in its standard
  library. To check if an object is a Python `bytearray`, use `bytes?`."
  [x]
  (instance? python/bytes x))

(defn char?
  "Return true if x is a string of length 1."
  [x]
  (and (instance? python/str x)
       (= (python/len x) 1)))

(defn class?
  "Return true if x names a type."
  [x]
  (instance? python/type x))

(defn coll?
  "Return true if x implements IAssociative."
  [x]
  (instance? basilisp.lang.interfaces/IPersistentCollection x))

(defn complex?
  "Return true if x is a complex number."
  [x]
  (instance? python/complex x))

(defn counted?
  "Return true if x can be counted in constant time."
  [x]
  (instance? basilisp.lang.interfaces/ICounted x))

(defn decimal?
  "Return true if x is a Decimal."
  [x]
  (instance? decimal/Decimal x))

(defn empty?
  "Return true if coll is empty (as by '(not (seq coll))).

  Typically, you should prefer the idiom (seq coll) to (not (empty? coll))."
  [coll]
  (not (seq coll)))

(defn even?
  "Return true if x is even."
  [x]
  (if (= 0 (mod x 2)) true false))

(defn false?
  "Return true if x is false, otherwise false."
  [x]
  (operator/is- x false))

(def double? float?)

(defn fn?
  "Return true if x is a function created by `fn` or `fn*`."
  [x]
  (and (python/callable x)
       (python/hasattr x "_basilisp_fn")
       (python/getattr x "_basilisp_fn")))

(defn ident?
  "Return true if x is either a keyword or symbol."
  [x]
  (or (keyword? x) (symbol? x)))

(defn ifn?
  "Return true if x is callable as a function.

  Many Basilisp data structures are callable as functions though
  they are not proper function types."
  [x]
  (python/callable x))

(defn indexed?
  "Return true if elements of x can be accessed by index efficiently."
  [x]
  (instance? basilisp.lang.interfaces/IIndexed x))

(def ^{:doc "Return true if x is an integer.

             Note that unlike Clojure, Basilisp uses Python integers and
             there is no distinction between standard and fixed-precision
             integers."}
  int?
  integer?)

(defn map-entry?
  "Return true if x implements IMapEntry."
  [x]
  (instance? basilisp.lang.interfaces/IMapEntry x))

(defn neg?
  "Return true if x is negative."
  [x]
  (if (operator/lt x 0) true false))

(defn non-neg?
  "Return true if x is not negative."
  [x]
  (if (operator/ge x 0) true false))

(defn nat-int?
  "Return true if x is a non-negative integer"
  [x]
  (and (integer? x) (non-neg? x)))

(defn neg-int?
  "Return true if x is a negative integer."
  [x]
  (and (integer? x) (neg? x)))

(defn nil?
  "Return true if x is nil, otherwise false."
  [x]
  (operator/is- x nil))

(defn some?
  "Return true if x is not nil, otherwise false."
  [x]
  (not (nil? x)))

(defn number?
  "Return true if x is a number."
  [x]
  (or (integer? x) (float? x) (complex? x)))

(defn odd?
  "Return true if x is odd."
  [x]
  (if (= 1 (mod x 2)) true false))

(defn pos?
  "Return true if x is positive."
  [x]
  (if (operator/gt x 0) true false))

(defn pos-int?
  "Return true if x is a positive integer."
  [x]
  (and (integer? x) (pos? x)))

(defn py-dict?
  "Return true if x is a Python `dict`."
  [x]
  (instance? python/dict x))

(defn py-frozenset?
  "Return true if x is a Python `frozenset`."
  [x]
  (instance? python/frozenset x))

(defn py-list?
  "Return true if x is a Python `list`."
  [x]
  (instance? python/list x))

(defn py-set?
  "Return true if x is a Python `set`."
  [x]
  (instance? python/set x))

(defn py-tuple?
  "Return true if x is a Python `tuple`."
  [x]
  (instance? python/tuple x))

(defn qualified-ident?
  "Return true if x is either a keyword or symbol with a namespace."
  [x]
  (and (ident? x) (some? (namespace x))))

(defn qualified-keyword?
  "Return true if x is a keyword with a namespace."
  [x]
  (and (keyword? x) (some? (namespace x))))

(defn qualified-symbol?
  "Return true if x is a symbol with a namespace."
  [x]
  (and (symbol? x) (some? (namespace x))))

(defn ratio?
  "Return true if x is a Fraction."
  [x]
  (instance? fractions/Fraction x))

(defn rational?
  "Return true if x is a rational number."
  [x]
  (or (int? x) (ratio? x) (decimal? x)))

(defn real-number?
  "Return true if x is a real number."
  [x]
  (or (integer? x) (float? x)))

(defn reversible?
  "Return true if x implements IReversible."
  [x]
  (instance? basilisp.lang.interfaces/IReversible x))

(defn seqable?
  "Return true if an ISeq can be produced from x."
  [x]
  (instance? basilisp.lang.interfaces/ISeqable x))

(defn sequential?
  "Return true if x implements ISequential."
  [x]
  (instance? basilisp.lang.interfaces/ISequential x))

(defn simple-keyword?
  "Return true if x is a keyword with no namespace."
  [x]
  (and (keyword? x) (nil? (namespace x))))

(defn special-symbol?
  "Return true if x is a special form symbol."
  [x]
  (basilisp.lang.runtime/is-special-form x))

(defn simple-symbol?
  "Return true if x is a symbol with no namespace."
  [x]
  (and (symbol? x) (nil? (namespace x))))

(defn true?
  "Return true if x is true, otherwise false."
  [x]
  (operator/is- x true))

(defn uuid?
  "Return true if x is a UUID."
  [x]
  (instance? uuid/UUID x))

(defn uuid-like?
  "Return true if x is coercible to a UUID.

  Python's UUID constructor supports byte sequences in big- and little-
  endian byte orders. This function checks only for big-endian bytes."
  [x]
  (try
    (cond
      (uuid? x)         true
      (string? x)       (do (uuid/UUID x) true)
      (int? x)          (do (uuid/UUID ** :int x) true)
      (byte-string? x)  (do (uuid/UUID ** :bytes x) true)
      (or (py-tuple? x)
          (vector? x))  (do (uuid/UUID ** :fields x) true)
      :else             false)
    (catch python/AttributeError _ false)
    (catch python/TypeError _ false)
    (catch python/ValueError _ false)))

(defn var?
  "Return true if x is a Var."
  [x]
  (instance? basilisp.lang.runtime/Var x))

(defn zero?
  "Return true if x is 0."
  [x]
  (= 0 x))

;;;;;;;;;;;;;;;;;;;
;; Type Coercion ;;
;;;;;;;;;;;;;;;;;;;

(defn bigdec
  "Coerce x to a Decimal."
  [x]
  (decimal/Decimal x))

(defn bigint
  "Coerce x to an integer.

  Python's builtin `int` type is arbitrary precision, so there is no difference
  between `bigint`, `biginteger`, and Python's builtin `int`."
  [x]
  (python/int x))

(defn biginteger
  "Coerce x to an integer.

  Python's builtin `int` type is arbitrary precision, so there is no difference
  between `bigint`, `biginteger`, and Python's builtin `int`."
  [x]
  (python/int x))

(defn boolean
  "Coerce x to a boolean."
  [x]
  (python/bool x))

(defn byte
  "Coerce x to a byte."
  [x]
  (let [b (python/bytes [x])]
    (if (= 1 (python/len b))
      b
      (throw
       (python/ValueError (str "cannot coerce " (python/repr x) " to byte"))))))

(defn char
  "Coerce x to a string of length 1.

  Natural integers are treated as ordinals and passed to Python's `chr`.
  Strings of length 1 are returned as such. Other types will result in
  a `ValueError`."
  [x]
  (cond
    (instance? python/int x) (python/chr x)
    (char? x)                x
    :else                    (throw
                              (python/ValueError
                               (str "cannot cast " (python/repr x) " to char")))))

(defn double
  "Coerce x to a float.

  Python does not differentiate between `float` and `double`. Python `float`s are
  double precision."
  [x]
  (python/float x))

(defn float
  "Coerce x to a float."
  [x]
  (python/float x))

(defn int
  "Coerce x to an integer."
  [x]
  (python/int x))

(defn long
  "Coerce x to an integer.

  Python does not support `long` types, so the value is coerced to an integer."
  [x]
  (python/int x))

(defn short
  "Coerce x to an integer.

  Python does not support `short` types, so the value is coerced to an integer."
  [x]
  (python/int x))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unchecked Arithmetic ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro ^:private defcopy
  "Copy the Var `var` into a new Var as `name`.

  Append the given docstring `doc` to the end of the new Var's `doc`."
  ([name var]
   `(defcopy ~name nil ~var))
  ([name doc var]
   (let [orig-var      (basilisp.lang.runtime/resolve-var var *ns*)
         orig-var-meta (meta orig-var)
         var-doc       (:doc orig-var-meta)
         new-doc       (if doc
                         (str var-doc "\n\n" doc)
                         var-doc)
         vname         (vary-meta name
                                  assoc
                                  :doc new-doc
                                  :arglists (list 'quote (:arglists orig-var-meta)))]
     `(def ~vname ~var))))

(defcopy unchecked-add
  "Same as '+. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  +)
(defcopy unchecked-add-int
  "Same as '+. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  +)
(defcopy unchecked-subtract
  "Same as '-. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  -)
(defcopy unchecked-subtract-int
  "Same as '-. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  -)
(defcopy unchecked-multiply
  "Same as '*. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  *)
(defcopy unchecked-multiply-int
  "Same as '*. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  *)
(defcopy unchecked-divide-int
  "Same as '/. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  /)

(defcopy unchecked-inc
  "Same as 'inc. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  inc)
(defcopy unchecked-inc-int
  "Same as 'inc. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  inc)
(defcopy unchecked-dec
  "Same as 'dec. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  dec)
(defcopy unchecked-dec-int
  "Same as 'dec. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  dec)

(defn unchecked-negate
  "Return the negation of x.

  Same as (- x). Python integers are unlimited precision so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  [x]
  (- x))
(defcopy unchecked-negate-int unchecked-negate)

(defn unchecked-byte
  "Coerce x to a byte. Value may be truncated or rounded."
  [x]
  (byte (mod x 256)))

(defn unchecked-char
  "Coerce x to a char. Value may be truncated or rounded."
  [x]
  (cond
    (instance? python/int x) (char (mod x sys/maxunicode))
    :else                    (char x)))

(defcopy unchecked-double
  "Same as 'double. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  double)
(defcopy unchecked-float
  "Same as 'float. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  float)

(defcopy unchecked-int
  "Same as 'int. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  int)
(defcopy unchecked-long
  "Same as 'long. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  long)
(defcopy unchecked-short
  "Same as 'short. Python integers are unlimited precision, so unchecked arithmetic
  is only provided for compatibility with platforms without unlimited precision
  integers."
  short)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arrays (Python List) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn to-array
  "Return a Python list with the contents of coll."
  [coll]
  (python/list coll))

(defn to-array-2d
  "Return a two-dimensional Python list from the contents of coll.

  Python lists do not specify a fixed size, so the resulting two-dimensional
  list may be ragged (in the Java sense of the word) if the inner collections
  of the input are ragged."
  [coll]
  (python/list (python/map python/list coll)))

(defn into-array
  "Returns a Python list with the values from aseq.

  The type argument is ignored and is provided only for Clojure compatibility."
  ([aseq]
   (python/list aseq))
  ([^:no-warn-when-unused type aseq]
   (python/list aseq)))

(defn make-array
  "Create a Python list with initial size. If multiple sizes are provided, produces
  a multi-dimensional list-of-lists. There is no efficient way to allocate such
  multi-dimensional lists in Python, so this function will run in polynomial time.

  Python lists do not support pre-allocation by capacity, so this function pre-
  fills the created list(s) with `nil`.

  The type argument is ignored and is provided only for Clojure compatibility."
  ([size]
   (operator/mul #py [nil] size))
  ([^:no-warn-when-unused type size]
   (operator/mul #py [nil] size))
  ([^:no-warn-when-unused type size & more-sizes]
   (let [final #py []]
     (loop [size size]
       (if (pos? size)
         (do
           (.append final (apply make-array type more-sizes))
           (recur (dec size)))
         final)))))

(defn object-array
  "Create an array of objects.

  If `init-val-or-seq` and is a `seq` yielding fewer than `size` elements, then the
  remaining indices of the resulting array will be filled with `nil` values.

  This function does not coerce its argument and is provided for Clojure compatibility."
  ([size-or-seq]
   (if (int? size-or-seq)
     (make-array size-or-seq)
     (to-array size-or-seq)))
  ([size init-val-or-seq]
   (if (and (seqable? init-val-or-seq) (seq init-val-or-seq))
     (let [final #py []]
       (loop [arr-seq (seq init-val-or-seq)
              idx     0]
         (when (< idx size)
           (.append final (first arr-seq))
           (recur (rest arr-seq) (inc idx))))
       final)
     (operator/mul #py [init-val-or-seq] size))))

(defn aclone
  "Return a clone of the Python list."
  [array]
  (python/list array))

(defn aget
  "Return the value of the Python list at the index (or indices)."
  ([array idx]
   (operator/getitem array idx))
  ([array idx & idxs]
   (if (seq idxs)
     (recur (operator/getitem array idx) (first idxs) (rest idxs))
     (operator/getitem array idx))))

(defn aset
  "Sets the value of the Python list at the index (or indices). Returns val."
  ([array idx val]
   (operator/setitem array idx val)
   val)
  ([array idx idx2 & idxs]
   (loop [target (operator/getitem array idx)
          idx    idx2
          idx2   (first idxs)
          idxs   (rest idxs)]
     (if (seq idxs)
       (recur (operator/getitem target idx) idx2 (first idxs) (rest idxs))
       (do
         (operator/setitem target idx idx2)
         idx2)))))

(defn alength
  "Return the length of the Python list."
  [array]
  (python/len array))

(defmacro amap
  "Map `expr` over the Python list `array`, returning a new Python list with
  the result.

  This macro initially binds the symbol named by `ret` to a clone of `array`.
  On each iteration, the index (named by `idx`) of `ret` is set to the return
  value of `expr`."
  [array idx ret expr]
  `(let [len# (alength ~array)
         ~ret (aclone ~array)]
     (loop [~idx 0]
       (when (< ~idx len#)
         (aset ~ret ~idx ~expr)
         (recur (inc ~idx))))
     ~ret))

(defmacro areduce
  "Reduce the Python list `array` by `expr`, returning the reduced expression.

  This macro initially binds the symbol named by `ret` to `init`. On each
  iteration, `ret` is rebound to the return value of `expr`."
  [array idx ret init expr]
  `(let [len# (alength ~array)]
     (loop [~ret ~init
            ~idx 0]
       (if (< ~idx len#)
         (recur ~expr (inc ~idx))
         ~ret))))

(defn booleans
  "Dummy cast to a Python list of booleans.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn bytes
  "Dummy cast to a Python list of bytes (distinct from Python's `bytarray` and
  `bytes` types).

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn chars
  "Dummy cast to a Python list of chars.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn doubles
  "Dummy cast to a Python list of doubles.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn floats
  "Dummy cast to a Python list of floats.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn ints
  "Dummy cast to a Python list of integers.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn longs
  "Dummy cast to a Python list of longs.

  This function is provided for Clojure compatibility."
  [x]
  x)

(defn shorts
  "Dummy cast to a Python list of shorts.

  This function is provided for Clojure compatibility."
  [x]
  x)

;;;;;;;;;;;;;;;;
;; Exceptions ;;
;;;;;;;;;;;;;;;;

(def ^{:doc     "During a REPL session, bound to the most recent value evaluated."
       :dynamic true}
  *1
  nil)
(def ^{:doc     "During a REPL session, bound to the second most recent value evaluated."
       :dynamic true}
  *2
  nil)
(def ^{:doc     "During a REPL session, bound to the third most recent value evaluated."
       :dynamic true}
  *3
  nil)
(def ^{:doc     "During a REPL session, bound to the most recently thrown exception."
       :dynamic true}
  *e
  nil)

(defn ex-cause
  "Return the cause (another Exception) of ex if it derives from Exception,
  otherwise it returns nil."
  [ex]
  (when (instance? python/Exception ex)
    (or (.- ex __cause__) (.- ex __context__))))

(defn ex-data
  "Return the data map of ex if is an instance of IExceptionInfo, otherwise
  it returns nil."
  [ex]
  (when (instance? basilisp.lang.interfaces/IExceptionInfo ex)
    (.-data ex)))

(defn ex-message
  "Return the message of ex if is an Exception, otherwise
  it returns nil."
  [ex]
  (when (instance? python/Exception ex)
    (python/getattr ex "message" (python/str ex))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Bit Manipulation Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn bit-and
  "Return the bitwise and of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (first args)) rest-arg)
    (operator/and- x (first args))))

(defn bit-or
  "Return the bitwise or of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/or- x (first args)) rest-arg)
    (operator/or- x (first args))))

(defn bit-not
  "Invert the bits of x."
  [x]
  (operator/invert x))

(defn bit-shift-left
  "Return x shifted left n bits."
  [x n]
  (operator/lshift x n))

(defn bit-shift-right
  "Return x shifted right n bits."
  [x n]
  (operator/rshift x n))

(defn bit-xor
  "Return the bitwise xor of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/xor x (first args)) rest-arg)
    (operator/xor x (first args))))

(defn bit-and-not
  "Return the bitwise and complement of x and args."
  [x & args]
  (if-let [rest-arg (seq (rest args))]
    (recur (operator/and- x (operator/not- (first args))) rest-arg)
    (operator/and- x (operator/not- (first args)))))

(defn bit-clear
  "Clear the bit of x at index n."
  [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip
  "Flip the bit of x at index n."
  [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-set
  "Set the bit of x at index n."
  [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-test
  "Test the bit of x at index n."
  [x n]
  (bit-and (bit-shift-right x n) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn bounded-count
  [n coll]
  (if (counted? coll)
    (count coll)
    (let [counter (fn counter
                    [coll cur]
                    (cond
                      (>= cur n)       n
                      (not (seq coll)) cur
                      :else            (recur (rest coll) (inc cur))))]
      (counter coll 0))))

(defn empty
  "Return an empty collection of the same interface type as coll, or nil."
  [coll]
  (when (coll? coll)
    (.empty coll)))

(defn not-empty
  "Return coll when coll is not empty, otherwise return nil."
  [coll]
  (when (seq coll)
    coll))

(defn peek
  "For a list or a queue, return the first element.

  For a vector, return the last element (more efficiently than by last).

  For empty collections, returns nil."
  [coll]
  (.peek coll))

(defn pop
  "For a list or a queue, return a new list without the first element.

  For a vector, return a new vector without the last element.

  If coll is empty, throw an exception."
  [coll]
  (.pop coll))

(defn reverse
  "Return a seq containing the elements in coll in reverse order. The
  returned sequence is not lazy."
  [coll]
  (let [do-reverse (fn do-reverse
                     [in out]
                     (if (seq in)
                       (recur (rest in) (cons (first in) out))
                       out))]
    (do-reverse coll '())))

(defn rseq
  "Return a sequence of the elements of coll in reverse order in constant
  time. Only Vectors support this operation."
  [coll]
  (.rseq coll))

(defn sequence
  "Coerces coll to a possibly empty sequence."
  [coll]
  (if (seq? coll)
    coll
    (or (seq coll) '())))

(defn subvec
  "Return a vector of elements consisting of the elements of v from the index 'start'
  (inclusive) to index 'end' exclusive, or the end of the vector if no 'end' is
  supplied."
  ([v start]
   (subvec v start nil))
  ([v start end]
   (when (> start (count v))
     (throw (python/IndexError "Start index out of range")))
   (when-not (nil? end)
     (when (> end (count v))
       (throw (python/IndexError "End index out of range")))
     (when (> start end)
       (throw (python/IndexError "Start index must be less than or equal to end index"))))
   (operator/getitem v (python/slice start end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn contains?
  "Return true if coll contains k. For vectors, k is an index. For maps, k is
  a key. For sets, k is a value in the set."
  [coll k]
  (basilisp.lang.runtime/contains coll k))

(defn disj
  "Return a new version of the set s without the given elements. If the elements
  don't exist in s, they are ignored."
  ([s] s)
  ([s & elems]
   (apply (.-disj s) elems)))

(defn dissoc
  "Return a new version of m without the given keys. If the keys
  don't exist in m, they are ignored."
  [m & ks]
  (apply (.-dissoc m) ks))

(defn get
  "Return the entry of `m` corresponding to `k` if it exists or `nil`/`default`
  otherwise.

  `m` may be any associative type (such as a vector or map), set type, or string.
  If `m` is not one of the supported types, `get` always returns `nil`/`default`."
  ([m k]
   (basilisp.lang.runtime/get m k))
  ([m k default]
   (basilisp.lang.runtime/get m k default)))

(defn assoc-in
  "Associate value in a nested associative structure, with ks as a sequence of
  keys and v as the new value. If no map exists for any key in ks, a new empty
  map will be created."
  [m ks v]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m fk (assoc-in (get m fk) rks v))
      (basilisp.lang.runtime/assoc m fk v))))

(defn get-in
  "Return the entry of an associative data structure addressed by the sequence of
  keys ks or default (default: nil) if the value is not found."
  ([m ks]
   (get-in m ks nil))
  ([m ks default]
   (let [fk  (first ks)
         rks (rest ks)]
     (if (seq rks)
       (if-let [child-map (basilisp.lang.runtime/get m fk)]
         (get-in child-map rks default)
         default)
       (basilisp.lang.runtime/get m fk default)))))

(defn update
  "Updates the value for key k in associative data structure m with the return value
  from calling (f old-v & args). If m is nil, use an empty map. If k is not in m,
  old-v will be nil."
  [m k f & args]
  (apply basilisp.lang.runtime/update m k f args))

(defn update-in
  "Updates the value for key k in associative data structure m with the return value
  from calling (f old-v & args). If m is nil, use an empty map. If k is not in m,
  old-v will be nil."
  [m ks f & args]
  (let [fk  (first ks)
        rks (rest ks)]
    (if (seq rks)
      (basilisp.lang.runtime/assoc m
                                   fk
                                   (apply update-in
                                          (or (basilisp.lang.runtime/get m fk) {})
                                          rks
                                          f
                                          args))
      (apply basilisp.lang.runtime/update m fk f args))))

(defn map-entry
  "With one argument, coerce the input to a map entry. With two arguments, return a
  map entry containing key and value."
  ([coll]
   (if (= 2 (count coll))
     (basilisp.lang.map.MapEntry/from-vec coll)
     (throw
      (ex-info "Cannot coerce object to basilisp.lang.map.MapEntry"
               {:coll coll
                :type (type coll)}))))
  ([k v]
   (basilisp.lang.map.MapEntry/of k v)))

(defn find
  "Find the map entry of k in m, if it exists. Return nil otherwise."
  [m k]
  (when-let [v (get m k)]
    (map-entry k v)))

(defn key
  "Return the key from a map entry."
  [entry]
  (.-key entry))

(defn val
  "Return the val from a map entry."
  [entry]
  (.-value entry))

(defn keys
  "Return a seq of the keys from a map."
  [m]
  (seq (.keys m)))

(defn vals
  "Return a seq of the values from a map."
  [m]
  (seq (.values m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transient Collections ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn transient
  "Return a transient copy of persistent collection `coll`.

  Transients can be created from maps, sets, and vectors. Transients allow faster
  mutations than their persistent counterparts and are useful for performance
  sensitive code which makes many modifications to these data structures.

  Transient collections can be edited with the transient versions of the familiar
  collection functions (depending on the type of `coll`): `assoc!`, `conj!`,
  `disj!`, `dissoc!`, and `pop!`. Transient collections are designed to be used
  in the same style as the builtin persistent collections, so callers should be
  sure to use the returned value from prior calls to these collection functions
  rather than repeatedly modifying the collection in place.

  Once you have completed all of your modifications to the local transient
  collection, you can call `persistent!` to return a persistent version of that
  data structure."
  [coll]
  (if (instance? basilisp.lang.interfaces/IEvolveableCollection coll)
    (.to-transient coll)
    (throw
     (ex-info (str "Object of type " (type coll) " does not implement "
                   "IEvolveableCollection interface")
              {:coll coll
               :type (type coll)}))))

(defn persistent!
  "Return a persistent copy of the transient collection `coll` which was created
  by calling `transient`."
  [coll]
  (if (instance? basilisp.lang.interfaces/ITransientCollection coll)
    (.to-persistent coll)
    (throw
     (ex-info (str "Object of type " (type coll) " does not implement "
                   "ITransientCollection interface")
              {:coll coll
               :type (type coll)}))))

(defn assoc!
  "Associate keys to values in the transient associative data structure `m`."
  ([m k v]
   (.assoc-transient m k v))
  ([m k v & kvs]
   (apply (.-assoc-transient m) k v kvs)))

(defn conj!
  "Conjoin xs to the transient collection `coll`. New elements may be added in
  different positions depending on the type of `coll`. conj returns the same type
  as `coll`."
  ([] (transient []))
  ([coll] coll)
  ([coll & xs]
   (apply (.-cons-transient coll) xs)))

(defn disj!
  "Return a new version of the transient set `s` without the given elements. If the
  elements don't exist in `s`, they are ignored."
  ([s] s)
  ([s elem]
   (.disj-transient s elem))
  ([s elem & elems]
   (apply (.-disj-transient s) elem elems)))

(defn dissoc!
  "Return a new version of the transient associative collection `m`` without the
  given keys. If the keys don't exist in `m`, they are ignored."
  ([m k] (.dissoc-transient m k))
  ([m k & ks]
   (apply (.-dissoc-transient m) k ks)))

(defn pop!
  "Return a new transient vector without the last element of `coll`. If `coll` is
  empty, throw an exception."
  [coll]
  (.pop-transient coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher Order and Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro lazy-seq
  "Takes a body of expressions which will produce a seq or nil. When
  seq is first called on the resulting lazy-seq, the sequence will be
  realized."
  [& body]
  (list 'basilisp.lang.seq/LazySeq
        (concat '(fn* []) body)))

(defn dorun
  "Force a lazy sequence be fully realized. Returns nil.

  This is often useful when you have a lazy sequence whose function also
  performs side effects.

  Realizing an entire lazy sequence will force that sequence to exist
  fully in memory."
  ([coll]
   (loop [ptr coll]
     (when (seq ptr)
       (recur (rest ptr)))))
  ([n coll]
   (loop [ptr coll
          i   n]
     (when (and (seq ptr) (> i 0))
       (recur (rest ptr) (dec i))))))

(defn doall
  "Force a lazy sequence be fully realized. Returns the head of the sequence.

  This is often useful when you have a lazy sequence whose function also
  performs side effects.

  Realizing an entire lazy sequence will force that sequence to exist
  fully in memory."
  ([coll]
   (dorun coll)
   coll)
  ([n coll]
   (dorun n coll)
   coll))

(defn iterate
  "Returns a lazy sequence of (f x), (f (f x)) and so on."
  [f x]
  (lazy-seq
   (let [v (f x)]
     (when v
       (cons v (iterate f v))))))

(defn range
  "Return a range of integers from start. If end is specified, the
  sequence will terminate at end."
  ([]
   (iterate inc -1))
  ([end]
   (lazy-seq (cons 0 (range 1 end))))
  ([start end]
   (lazy-seq (cons start (when (< start (dec end))
                           (range (inc start) end)))))
  ([start end step]
   (lazy-seq (let [next-int (+ start step)]
               (cons start (when (< next-int (dec end))
                             (range next-int end step)))))))

(defn complement
  "Return a function which returns the logical complement of the return
  value of (apply f args)."
  [f]
  (fn [& args]
    (not (apply f args))))

(defn constantly
  "Returns a function that accepts any number of arguments and returns x."
  [x]
  (fn [& ^:no-warn-when-unused args] x))

(defn reduce
  "Reduce `coll` by `f`.

  If `val` is not supplied and `coll` has no elements, `f` will be called
  with no arguments and the result will be returned.

  If `val` is not supplied and `coll` has one element, the result of
  `(f (first val))` is returned.

  If `val` is not supplied and `coll` has elements, repeatedly reduce `coll`
  by calling `f` on successive elements in `coll`.

  If `val` is supplied and `coll` has no elements, return `val` and `f` will
  not be called.

  If `val` is supplied and `coll` has elements, repeatedly reduce coll
  by calling `f` on successive elements in `coll`, starting with `val`."
  ([f coll]
   (if (seq coll)
     (if (seq (rest coll))
       (reduce f (first coll) (rest coll))
       (first coll))
     (f)))
  ([f val coll]
   (let [reduce-coll (fn [out in]
                       (if (seq in)
                         (recur (f out (first in)) (rest in))
                         out))]
     (if (seq coll)
       (reduce-coll val coll)
       val))))

(defn reduce-kv
  "Reduce an associative coll by f. f must be a function of 3
  arguments: the initially supplied value (in later invocations, the
  the return from previous invocations), the key of an entry of
  coll, and the value of an entry of coll.

  If coll has no elements, init is returned and f is not called.

  reduce-kv may reduce vectors in addition to maps. Vectors have
  non-negative integer keys."
  [f init coll]
  (if (seq coll)
    (loop [in-coll    coll
           assoc-coll init]
      (let [entry (first in-coll)
            k     (key entry)
            v     (val entry)
            rem   (rest in-coll)]
        (if (seq rem)
          (recur rem (f assoc-coll k v))
          (f assoc-coll k v))))
    init))

(defn into
  "Return a new collection created by adding all of the elements of from
  to the existing to collection, as by conj."
  ([] [])
  ([to] to)
  ([to from]
   (reduce conj to from)))

(defn comp
  "Return a function which is the composition of all the functions
  given as arguments. Note that, as in mathematical function composition,
  the argument functions are called from right to left."
  ([] identity)
  ([f] f)
  ([f & args]
   (let [composed (reduce (fn [f g]
                            (fn [& args]
                              (f (apply g args))))
                          f
                          args)]
     (fn [& inner-args]
       (apply composed inner-args)))))

(defn juxt
  "Return a function which takes any number of arguments and applies each of
  the argument functions to this function in order, returning a vector of the
  return values from each function."
  [& args]
  (fn [& inner-args]
    (reduce (fn [v f]
              (conj v (apply f inner-args)))
            []
            args)))

(defn partial
  "Return a function which is the partial application of f with args."
  ([f] f)
  ([f & args]
   (apply basilisp.lang.runtime/partial f args)))

(defn partial-kw
  "Return a function which is the partial application of f with keyword arguments.

  If a single argument is provided, it will be interpreted as a map of keyword arguments.

  If multiple arguments are given, they are interpreted as key/value pairs and will
  be converted into a hash-map before being partially applied to the function.

  This function applies keyword arguments via `apply-kw`. As a consequence, Lisp keywords
  will be converted to munged Python strings (via `name`), meaning namespaces will be lost
  and identifiers which are not valid Python syntax will be converted to safe Python
  identifiers."
  ([f] f)
  ([f m]
   (apply-kw basilisp.lang.runtime/partial f m))
  ([f arg & args]
   (let [m (apply hash-map (cons arg args))]
     (partial-kw f m))))

(defn every?
  "Return true if every element in coll satisfies pred."
  [pred coll]
  (cond
    (nil? (seq coll))   true
    (pred (first coll)) (recur pred (rest coll))
    :else               false))

(defn every-pred
  "Return a predicate composed of all of the input predicates, which returns
  true if all input predicates return true for a value, otherwise returns false.
  The returned predicate returns false on the first failing predicate and will
  not execute any remaining predicates."
  ([pred]
   (fn [& args]
     (every? pred args)))
  ([pred & preds]
   (let [comp-pred (reduce (fn [f g]
                             (fn [v]
                               (if (and (f v) (g v))
                                 true
                                 false)))
                           pred
                           preds)]
     (fn [& args]
       (every? comp-pred args)))))

(def
  ^{:doc "Return true if not every element in coll satisfies pred."}
  not-every?
  (comp not every?))

(defn some
  "Return true if at least one element in coll satisfies pred."
  [pred coll]
  (when (seq coll)
    (or (pred (first coll))
        (recur pred (rest coll)))))

(defn some-fn
  "Return a predicate composed of all of the input functions, which returns
  the first truthy return value from one of the inputs, otherwise returns nil.
  The returned predicate returns the first truthy value it encounters and will
  not execute any remaining functions."
  ([f]
   (fn [& args]
     (some f args)))
  ([f & fs]
   (let [comp-f (reduce (fn [f g]
                          (fn [v]
                            (or (f v) (g v))))
                        f
                        fs)]
     (fn [& args]
       (some comp-f args)))))

(def
  ^{:doc "Return true if no element in coll satisfies pred."}
  not-any?
  (comp not some))

(defn map
  "Return a lazy sequence of (f elem) for elements in coll. More than one
  collection may be supplied. If more than one collection is supplied, the
  function f will be passed sequential elements from each collection on each
  invocation and must be able to accept as many arguments as there are
  collections. The sequence will terminate when at least one input collection
  is exhausted."
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (cons (f (first coll)) (map f (rest coll))))))
  ([f coll & colls]
   (lazy-seq
    (when (and (seq coll) (every? seq colls))
      (cons (apply f (first coll) (map first colls))
            (apply map f (rest coll) (map rest colls)))))))

(def ^{:doc "Return a vector of (f elem) for elements in coll. More than one
             collection may be supplied. If more than one collection is supplied, the
             function f will be passed sequential elements from each collection on each
             invocation and must be able to accept as many arguments as there are
             collections. The sequence will terminate when at least one input collection
             is exhausted."}
  mapv (comp vec map))

(defn map-indexed
  "Return a lazy sequence of (f idx elem) for elements in coll. The
  index starts at 0."
  [f coll]
  (map f (range) coll))

(defn mapcat
  "Return a lazy sequence of the concatenated results of mapping f over
  colls."
  [f & colls]
  (apply concat (apply map f colls)))

(defn filter
  "Return a lazy sequence of elements from coll where (pred elem) returns true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (cons (first coll) (filter pred (rest coll)))
       (filter pred (rest coll))))))

(def ^{:doc "Return a lazy sequence of elements from coll where (pred elem)
             returns true."}
  filterv (comp vec filter))

(defn remove
  "Return elements from coll where (pred elem) returns false."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (not (pred (first coll)))
       (cons (first coll) (remove pred (rest coll)))
       (remove pred (rest coll))))))

(defn keep
  "Return a lazy sequence of non-nil results of (f elem) for elements in coll."
  [f coll]
  (lazy-seq
   (when (seq coll)
     (let [elem (first coll)]
       (if-not (nil? (f elem))
         (cons elem (keep f (rest coll)))
         (keep f (rest coll)))))))

(defn keep-indexed
  "Return a lazy-sequence of non-nil results of (f index elem) for elements
  in coll."
  [f coll]
  (let [keep-idx (fn keep-idx
                   [rng coll]
                   (lazy-seq
                    (when (seq coll)
                      (let [idx  (first rng)
                            elem (first coll)]
                        (if-not (nil? (f idx elem))
                          (cons elem (keep-idx (rest rng) (rest coll)))
                          (keep-idx (rest rng) (rest coll)))))))]
    (keep-idx (range) coll)))

(defn take
  "Return the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (when (> n 0)
       (cons (first coll) (take (dec n) (rest coll)))))))

(defn take-while
  "Return elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (when (pred (first coll))
       (cons (first coll) (take-while pred (rest coll)))))))

(defn drop
  "Drop the first n elements of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (> n 0)
       (drop (dec n) (rest coll))
       (seq coll)))))

(defn drop-while
  "Drop elements of coll while (pred elem) is true."
  [pred coll]
  (lazy-seq
   (when (seq coll)
     (if (pred (first coll))
       (drop-while pred (rest coll))
       (seq coll)))))

(defn drop-last
  "Drop all but the last n items of coll."
  ([coll]
   (drop-last 1 coll))
  ([n coll]
   (map (comp first vector) coll (drop n coll))))

(defn butlast
  "Return all but the last element in a sequence in linear time."
  [coll]
  (drop-last coll))

(defn split-at
  "Split a collection at the nth item. Returns a vector of
  [(take n coll) (drop n coll)]."
  [n coll]
  [(take n coll) (drop n coll)])

(defn split-with
  "Split a collection at the inflection point of pred. Returns a
  vector of [(take-while pred coll) (drop-while pred coll)]."
  [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

(defn frequencies
  "Return a map whose keys are the elements of coll and whose values are
  the counts for the number of times the key appears in coll."
  [coll]
  (reduce (fn [m v]
            (if (contains? m v)
              (update m v inc)
              (assoc m v 1)))
          {}
          coll))

(defn group-by
  "Return a map whose keys are the result of calling f on each element
  in coll and whose values are vectors of the values which produced the
  corresponding key, in the order they were added."
  [f coll]
  (reduce (fn [m v]
            (let [group (f v)]
              (if (contains? m group)
                (update m group conj v)
                (assoc m group [v]))))
          {}
          coll))

(defn interpose
  "Return a lazy sequence of elements of coll separated by sep. If
  coll is empty, return an empty sequence."
  [sep coll]
  (lazy-seq
   (when (seq coll)
     (if (seq (rest coll))
       (cons (first coll)
             (cons sep (interpose sep (rest coll))))
       (cons (first coll) nil)))))

(defn interleave
  "Return a lazy sequence consisting of the first element of coll, then the
  first element of the following coll, etc. until the shortest input collection
  is exhausted."
  ([] '())
  ([coll] (seq coll))
  ([coll & colls]
   (let [coll-firsts (fn coll-firsts
                       [& colls]
                       (lazy-seq
                        (when (seq colls)
                          (cons (ffirst colls) (apply coll-firsts (rest colls))))))]
     (lazy-seq
      (when (and (seq coll) (every? seq colls))
        (concat (apply coll-firsts coll colls)
                (apply interleave (rest coll) (map rest colls))))))))

(defn cycle
  "Cycle the items in coll infinitely."
  [coll]
  (let [coll-cycle (fn coll-cycle
                     [curr]
                     (lazy-seq
                      (if (seq curr)
                        (cons (first curr) (coll-cycle (rest curr)))
                        (coll-cycle coll))))]
    (coll-cycle coll)))

(defn repeat
  "Repeat x infinitely or n many times if n is specified. Returns a lazy
  sequence of the x."
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (lazy-seq
    (when (> n 0)
      (cons x (repeat (dec n) x))))))

(defn repeatedly
  "Call f infinitely or n many times if n is specified. Returns a lazy
  sequence of the return values."
  ([f]
   (lazy-seq (cons (f) (repeatedly f))))
  ([n f]
   (lazy-seq
    (when (> n 0)
      (cons (f) (repeatedly (dec n) f))))))

(defn take-nth
  "Return a lazy sequence of every nth element of coll."
  [n coll]
  (lazy-seq
   (when (seq coll)
     (if (<= n 0)
       (repeat (first coll))
       (cons (first coll)
             (take-nth n (drop (dec n) (rest coll))))))))

(defn partition
  "Return a lazy sequence of partitions of coll of size n at offsets
  of step elements. If step is not given, steps of size n will be used
  and there will be no overlap between partitions. If pad is given,
  partition will pull elements from pad until the final sequence is
  equal to size n. If there are fewer than n leftover elements in coll,
  they will not be returned as a partial partition."
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (let [s (take n coll)]
        (when (= n (count s))
          (cons s (partition n step (drop step coll))))))))
  ([n step pad coll]
   (lazy-seq
    (when (seq coll)
      (let [s  (take n coll)
            ns (count s)
            s  (if (< ns n)
                 (concat s (take (- n ns) pad))
                 s)]
        (cons s (partition n step pad (drop step coll))))))))

(defn partition-all
  "Return a lazy sequence of partitions of coll of size n at offsets
  of step elements. If step is not given, steps of size n will be used
  and there will be no overlap between partitions. If there are leftover
  elements from coll which do not fill a full partition, then a partial
  partition will be returned, unlike partition."
  ([n coll]
   (partition-all n n coll))
  ([n step coll]
   (lazy-seq
    (when (seq coll)
      (cons (take n coll) (partition-all n step (drop step coll)))))))

(defn partition-by
  "Return a lazy sequence of partitions, splitting coll each time f
  returns a different value."
  [f coll]
  (lazy-seq
   (when (seq coll)
     (let [elem  (first coll)
           felem (f elem)
           run   (cons elem (take-while #(= felem (f %)) (next coll)))]
       (cons run (partition-by f (seq (drop (count run) coll))))))))

(defn distinct
  "Return a lazy sequence of the elements of coll, removing duplicates."
  [coll]
  (let [coll-distinct (fn coll-distinct
                        [coll found]
                        (lazy-seq
                         (when (seq coll)
                           (let [e (first coll)]
                             (if-not (contains? found e)
                               (cons e (coll-distinct (rest coll) (conj found e)))
                               (coll-distinct (rest coll) found))))))]
    (coll-distinct coll #{})))

(defn dedupe
  "Return a lazy sequence of the elements of coll, removing consecutive duplicates."
  [coll]
  (let [coll-dedupe (fn coll-dedupe
                      [coll prev]
                      (lazy-seq
                       (when (seq coll)
                         (let [e (first coll)]
                           (if-not (= e prev)
                             (cons e (coll-dedupe (rest coll) e))
                             (coll-dedupe (rest coll) prev))))))]
    (lazy-seq
     (when-let [e (first coll)]
       (cons e (coll-dedupe (rest coll) e))))))

(defn flatten
  "Flatten any combination of nested sequences (such as lists or vectors)
  into a single lazy sequence. Calling flattening on non-sequential values
  returns an empty sequence."
  [v]
  (lazy-seq
   (when (and (or (seq? v) (seqable? v)) (seq v))
     (let [e (first v)
           r (rest v)]
       (if (or (seq? e) (seqable? e))
         (concat (flatten e) (flatten r))
         (cons e (flatten r)))))))

(defn min-key
  "Return the arg for which (k arg) is the smallest number.
  If multiple values return the same number, return the last."
  [k & args]
  (reduce (fn [cur nxt]
            (if (<= (k nxt) (k cur))
              nxt
              cur))
          (first args)
          (rest args)))

(defn max-key
  "Return the arg for which (k arg) is the largest number.
  If multiple values return the same number, return the last."
  [k & args]
  (reduce (fn [cur nxt]
            (if (>= (k nxt) (k cur))
              nxt
              cur))
          (first args)
          (rest args)))

(defn sort-by
  "Return a sorted sequence of the elements from coll."
  ([keyfn coll]
   (basilisp.lang.runtime/sort-by keyfn coll))
  ([keyfn cmp coll]
   (basilisp.lang.runtime/sort-by keyfn coll cmp)))

(defn zipmap
  "Return a map with the keys mapped to their corresponding indexed value
  in vals."
  [keys vals]
  (apply hash-map (interleave keys vals)))

(defn merge
  "Merge maps together from left to right as by conj. If a duplicate key
  appears in a map, the rightmost map's value for that key will be taken."
  [& maps]
  (when (some identity maps)
    (persistent!
     (reduce #(conj! %1 %2)
             (transient {})
             maps))))

(defn trampoline
  "Trampoline f with starting arguments. If f returns an fn, call its return
  value with no arguments, repeating that process until the return value is not
  a fn."
  [f & args]
  (loop [ret (apply f args)]
    (if (fn? ret)
      (recur (ret))
      ret)))

(import* multiprocessing)

(def ^:dynamic *pmap-cpu-count*
  (* 2 (multiprocessing/cpu-count)))

(defn pmap
  "Apply f as by map, but in parallel using futures.

  This may only be useful for functions which are mainly blocked on IO, since
  Python threads do not allow parallel computation using threads.

  This function is not fully lazy. Chunks of elements from the input collection
  are grabbed eagerly to spawn Futures of `f`. Elements after the chunk size in
  the input collection are grabbed lazily. The chunk size is set by
  `*pmap-cpu-count*` and defaults to 2 times the number of CPU cores on the
  machine; the value of `*pmap-cpu-count*` is captured when `pmap` is first
  called, so it should be safe to bind in the initial calling thread. The
  sequence of futures is fed into a final (fully lazy) sequence to deref the
  Future and return its final value."
  ([f coll]
   (lazy-seq
    (when (seq coll)
      (let [chunk-size *pmap-cpu-count*
            futs       (mapv #(future (f %)) (take chunk-size coll))]
        (concat (map deref futs)
                (pmap f (drop chunk-size coll)))))))
  ([f coll & colls]
   (lazy-seq
    (when (seq coll)
      (let [chunk-size *pmap-cpu-count*
            futs       (apply mapv (fn [& args]
                                     (future (apply f args)))
                              (take chunk-size coll)
                              (map #(take chunk-size %) colls))]
        (concat (map deref futs)
                (apply pmap f (drop chunk-size coll) (map #(drop chunk-size %) colls))))))))

(defn pcalls
  "Return a lazy seq of the result of executing the no arg functions fns,
  which will be evaluated in parallel."
  [& fns]
  (pmap (fn [f] (f)) fns))

(defmacro pvalues
  "Returns a lazy seq of the result of exprs, which will be evaluated in
  parallel."
  [& exprs]
  `(pcalls
    ~@(map (fn [expr]
             (concat '(fn* []) [expr]))
           exprs)))

;;;;;;;;;;;;;;;;;;;;;;
;; Random Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(import* random)

(defn rand
  "Return a random real number between lower (default: 0) and upper (default: 1) inclusive."
  ([] (random/uniform 0 1))
  ([upper] (random/uniform 0 upper))
  ([lower upper] (random/uniform lower upper)))

(defn rand-int
  "Return a random integer between lower (default: 0) and upper inclusive."
  ([upper]
   (random/randrange 0 upper))
  ([lower upper]
   (random/randrange lower upper)))

(defn rand-nth
  "Return a random element from coll."
  [coll]
  (nth coll (rand-int (count coll))))

(defn random-sample
  "Return elements from coll with the random probability of prob."
  [prob coll]
  (filter (fn [_] (< (rand) prob)) coll))

(defn shuffle
  "Return a random permutation of coll."
  [coll]
  (vec (random/sample (python/list coll) (count coll))))

;;;;;;;;;;;;;;;;;;;;
;; Utility Macros ;;
;;;;;;;;;;;;;;;;;;;;

(defn gensym
  "Generate a unique symbol name of the form prefix_#. If no prefix is
  given, then v_ will be used."
  ([]
   (gensym "v_"))
  ([prefix]
   (symbol (basilisp.lang.util/genname prefix))))

(def ^:dynamic *assert* true)

(defmacro assert
  "Evaluate expr and if it returns logical false, throw an AssertionError.

  This macro does not emit an assertion if the dynamic Var *assert* is set
  to a logical false value."
  ([expr]
   `(assert ~expr (str "Assert failed: " ~(str expr))))
  ([expr message]
   (when *assert*
     `(when-not ~expr
        (throw (python/AssertionError ~message))))))

(defmacro apply-method
  "Apply arguments to a method call. Equivalent to (apply (.-method o) args)."
  [o method & args]
  `(apply (. ~o ~(symbol (str "-" method))) ~@args))

(defmacro comment
  "Ignore all the forms passed, returning nil."
  [& ^:no-warn-when-unused forms]
  nil)

(defmacro case
  "Switch on expr to return a matching clause from the set of input clauses.

  The input expression may be any valid Basilisp expression.

  The clauses are pairs of a matching value and a return value. The matching
  values are not evaluated and must be compile-time constants. Symbols will not
  be resolved. Lists may be passed to match multiple compile time values to a
  single return value."
  [expr & clauses]
  (when (< (count clauses) 2)
    (throw (ex-info "case expression must have at least one clause"
                    {:clauses clauses})))
  (let [default (if (odd? (count clauses))
                  (last clauses)
                  :basilisp.core.case/no-default)
        pairs   (mapcat identity
                        (mapcat (fn [pair]
                                  (let [binding (first pair)
                                        expr    (second pair)]
                                    (if (list? binding)
                                      (map #(vector (list 'quote %) expr) binding)
                                      [[(list 'quote binding) expr]])))
                                (partition 2
                                           (if (= default :basilisp.core.case/no-default)
                                             clauses
                                             (drop-last clauses)))))
        expr-gs (gensym "expr")]
    `(let [~expr-gs ~expr
           m#       ~(apply hash-map pairs)]
       (if-not (contains? m# ~expr-gs)
         ~(if (= default :basilisp.core.case/no-default)
            `(throw (python/ValueError (str "No case clause matches " ~expr-gs)))
            `~default)
         (get m# ~expr-gs)))))

(defmacro condp
  "Take a predicate and an expression and a series of clauses, call
  (pred test expr) on the first expression for each clause. The result
  expression from first the set of clauses for which this expression
  returns a truthy value will be returned from the condp expression.

  Clauses can take two forms:

  - test-expr result-expr
  - test-expr :>> result-fn, where :>> is a keyword literal

  For the ternary expression clause, the unary result-fn will be called
  with the result of the predicate."
  [pred expr & clauses]
  (when (seq clauses)
    (let [test-expr (first clauses)
          remaining (rest clauses)]
      (if (seq remaining)
        (let [result    (first remaining)
              remaining (rest remaining)]
          (cond
            (= result :>>) `(let [res# ~(list pred test-expr expr)]
                              (if res#
                                (~(first remaining) res#)
                                (condp ~pred ~expr ~@(rest remaining))))
            result         `(if ~(list pred test-expr expr)
                              ~result
                              (condp ~pred ~expr ~@remaining))
            :else          (throw
                            (ex-info "expected result expression"
                                     {:test test-expr}))))
        test-expr))))

(defmacro declare
  "Declare the given names as Vars with no bindings, as a forward declaration."
  [& names]
  `(do
     ~@(map (fn [nm]
              `(def ~(vary-meta nm assoc :redef true)))
            names)))

(defmacro defonce
  "Define the Var named by `name` with root binding set to `expr` if and only if
  a `name` is not already defined as a Var in this namespace. `expr` will not be
  evaluated if the Var already exists."
  [name expr]
  `(let [v# (def ~name)]
     (when-not (.-is-bound v#)
       (def ~name ~expr))))

(defmacro for
  "Produce a list comprehension from 1 or more input sequences, subject to
  optional modifiers.

  For comprehensions consist of a vector of bindings, with optional modifiers,
  and a user specified body in an implicit do.

  Symbol bindings look like standard let bindings without destructuring.
  Values bound to symbols should be sequences or otherwise seqable. The body
  of the for comprehension will be executed with the given symbol bound to
  successive values of the sequence. If multiple sequences are bound to symbols,
  iteration will proceed in a nested fashion with latest sequences iterated
  first and earlier sequences iterated later (as nested for loops in procedural
  languages).

  For example, a simple non-nested for comprehension will yield:

    (for [x [1 2 3 4]] x) ;;=> [1 2 3 4]

  However, a nested comprehension will yield a longer sequence:

    (for [x (range 3)
          y [:a :b :c]]
      [x y])
    ;;=> ([0 :a] [0 :b] [0 :c]
          [1 :a] [1 :b] [1 :c]
          [2 :a] [2 :b] [2 :c])

  Each set of symbol bindings may be modified by applying trailing bindings
  denoted with keywords. The keyword modifiers are:

    :let [sym val] - :let bindings work like any standard let bindings;
                     destructuring is permitted; may refer to any previous
                     bindings in other :let modifiers or normal symbol
                     bindings. Multiple pairs of bindings may appear in
                     :let bindings.
    :when expr - :when bindings are applied to the sequence roughly like in
                 the core filter function; the expression is evaluated and
                 if it is not falsey, yield the next value. As with :let
                 bindings, the expression may refer to any previously
                 bound names.
    :while expr - :while bindings terminate the current sequence at the
                  first point when expr returns a falsey value. :while
                  bindings may refer to any previous bound names.

  Multiple keyword modifiers may be applied to the previous binding. Their
  effects will be applied at the point they appear in the bindings vector."
  [bindings & body]
  (cond
    (< (count bindings) 2)
    (throw (ex-info "for expression must have at least one pair of bindings"
                    {:bindings bindings}))

    (not (even? (count bindings)))
    (throw (ex-info "for expression must have an even number of bindings"
                    {:bindings bindings}))

    (not (symbol? (first bindings)))
    (throw (ex-info "for expression bindings must start with symbol binding"
                    {:bindings bindings})))

  (let [;; Generate the body of a for binding iterator, applying any relevant
        ;; modifier clauses.
        ;;
        ;;   pairs      - pairs of modifiers/modifier binding values
        ;;   for-iter   - the gensym'ed name for the current lazy-seq function
        ;;   seq-arg    - the gensym'ed name of the seq arg input to the
        ;;                lazy-seq function
        ;;   inner-body - either: the body of the for comprehension specified
        ;;                by the user, or another nested lazy-seq function
        ;;   inner-body-is-seq? - if true, inner-body is nested lazy-seq function
        gen-iter-body (fn gen-iter-body
                        [pairs for-iter seq-arg inner-body inner-body-is-seq?]
                        (if (seq pairs)
                          (let [pair     (first pairs)
                                binding  (first pair)
                                val      (second pair)
                                mod-body (gen-iter-body (rest pairs) for-iter seq-arg inner-body inner-body-is-seq?)]
                            (cond
                              (= :when binding)
                              `(if ~val
                                 ~mod-body
                                 (recur (rest ~seq-arg)))

                              (= :while binding)
                              `(when ~val
                                 ~mod-body)

                              (= :let binding)
                              `(let [~@val]
                                 ~mod-body)

                              :else
                              (throw
                               (ex-info "invalid for modifier; use one of :let, :when, or :while"
                                        {:modifier binding}))))
                          ;; If the inner body is another sequence (presumably
                          ;; generated by gen-iter), concatenate it rather than
                          ;; cons, to ensure the output is flattened in the
                          ;; final output sequence.
                          (if inner-body-is-seq?
                            `(concat ~inner-body (~for-iter (rest ~seq-arg)))
                            `(cons ~inner-body (~for-iter (rest ~seq-arg))))))

        ;; Generate the outer function body of a for loop symbol binding lazy seq.
        ;;
        ;; Each symbol binding generates an anonymous lazy sequence function which
        ;; contains blocks for any modifier bindings which follow the initial
        ;; symbol binding.
        ;;
        ;; Additional symbol bindings are generated as inner bodies (which contain)
        ;; the ultimate inner body given by the user. Modifiers are handled by
        ;; gen-iter-body and applied to the body of the current lazy seq.
        ;;
        ;;  pairs - pairs of bindings; either symbol/seq pairs or modifier pairs
        gen-iter (fn gen-iter [pairs]
                   (if (seq pairs)
                     (let [for-iter (gensym "for")
                           seq-arg  (gensym "seq")
                           pair     (first pairs)
                           binding  (first pair)
                           val      (second pair)

                           ;; Split the remaining binding pairs into modifiers
                           ;; (which will be applied to this iterator) and additional
                           ;; bindings (which will be generated as new, inner iterators).
                           groups        (split-with (fn [pair]
                                                       (not (symbol? (first pair))))
                                                     (rest pairs))
                           mods          (first groups)
                           rest-bindings (second groups)

                           seq-body (gen-iter-body mods for-iter seq-arg (gen-iter rest-bindings) (seq rest-bindings))]
                       `(let [iter# (fn ~for-iter [seq#]
                                      (lazy-seq
                                       (loop [~seq-arg seq#]
                                         (when (seq ~seq-arg)
                                           (let [~binding (first ~seq-arg)]
                                             ~seq-body)))))]
                          (iter# ~val)))
                     `(do ~@body)))]
    (gen-iter (partition 2 bindings))))

(defmacro doseq
  "Repeatedly run the body (likely for side effects) with bindings as described
  in the for macro. Returns nil."
  [bindings & body]
  `(dorun (for ~bindings ~@body)))

(defmacro ..
  "Expand into nested method calls on the returned objects from previous
  method calls.

  Successive method invocations are represented as successive lists:

    (.. \"abc\" (lower))              ;=> (. \"abc\" lower)
    (.. \"abc\" lower (split \",\"))  ;=> (. (. \"abc\" lower) split \",\")

  Methods invoked without arguments may be supplied as bare symbols."
  [x & method-calls]
  (if (seq method-calls)
    (let [joining (first method-calls)]
      `(..
        ~(if (seq? joining)
           (apply list '. x joining)
           (list '. x joining))
        ~@(rest method-calls)))
    x))

(defmacro memfn
  "Expands into a function that calls the method `name` on the first argument
  of the resulting function. If `args` are provided, the resulting function will
  have arguments of these names.

  This is a convenient way of producing a first-class function for a Python
  method."
  [name & args]
  `(fn [t# ~@args]
     (. t# ~name ~@args)))

(defmacro new
  "Create a new instance of class with args.

  New objects may be created as any of:
    (new python/str *args)
    (new python.str *args)
    (new python.str. *args)

  This is compatibility syntax for Clojure, since Python (and therefore
  Basilisp) do not require the new keyword for object instantiation."
  [class & args]
  (cond
    (not (symbol? class))
    (throw
     (ex-info "Expected a class name as a symbol"
              {:class-name class}))

    (namespace class)
    (let [n  (name class)
          ns (namespace class)
          s  (symbol (str ns "."
                          (if (.endswith n ".")
                            n
                            (str n "."))))]
      `(~s ~@args))

    :else
    (let [n (name class)
          s (symbol (if (.endswith n ".")
                      n
                      (str n ".")))]
      `(~s ~@args))))

(defmacro with
  "Evaluate body within a try/except expression, binding the named expressions
  as per Python's context manager protocol spec (Python's with blocks)."
  [bindings & body]
  (let [binding (first bindings)
        expr    (second bindings)]
    `(let [obj#     ~expr
           ~binding (. obj# ~'__enter__)]
       (try
         (do
           ~@(if (nthnext bindings 2)
               [(concat
                 (list 'with (vec (nthrest bindings 2)))
                 body)]
               body)
           (. ~binding (~'__exit__ nil nil nil))
           nil)
         (catch python/Exception e#
           (if (. ~binding (~'__exit__ (python/type e#) e# (. e# ~'__traceback__)))
             nil
             (throw e#)))))))

(def ^{:doc   "Evaluate body within a try/except expression, binding the named expressions
               as per Python's context manager protocol spec (Python's with blocks)."
       :macro true}
  with-open with)

(defn push-thread-bindings
  "Takes a map of Var/value pairs and applies the given value to the Var in the
  current thread.

  This call should be accompanied with a pop-thread-bindings call in a
  try/finally block.

  This function is a very low level function and its use is discouraged in favor
  of a higher level construct like the binding macros."
  [bindings]
  (basilisp.lang.runtime/push-thread-bindings bindings))

(defn pop-thread-bindings
  "Pop thread bindings set by a corresponding call to push-thread-bindings. This
  should not be called without a prior call to push-thread-bindings."
  []
  (basilisp.lang.runtime/pop-thread-bindings))

(defmacro binding
  "Establish thread-local bindings for the vars given. The bindings are guaranteed
  to clear once execution passes outside the scope of this block."
  [bindings & body]
  (when-not (and (vector? bindings)
                 (even? (count bindings))
                 (pos? (count bindings)))
    (throw
     (ex-info "Expected an even number of bindings"
              {:bindings bindings})))
  (let [var-bindings (reduce (fn [v pair]
                               (let [vvar (first pair)
                                     vval (second pair)]
                                 (conj v `(var ~vvar) vval)))
                             []
                             (partition 2 bindings))]
    `(try
       (do
         (push-thread-bindings (hash-map ~@var-bindings))
         ~@body)
       (finally
         (pop-thread-bindings)))))

(import* [time :as py-time])

(defn ^:private perf-counter
  []
  (py-time/perf-counter))

(defmacro time
  "Time the execution of expr. Return the result of expr and print the
  time execution took in milliseconds."
  [expr]
  `(let [start (perf-counter)]
     (try
       ~expr
       (finally
         (println (* 1000 (- (perf-counter) start)) "msecs")))))

;;;;;;;;;;;;;;;;;;;;;;
;; Threading Macros ;;
;;;;;;;;;;;;;;;;;;;;;;

(defmacro ->
  "Thread x through the forms. Places x in the second position of
  the first form, and then the resulting expression into the second
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->
        ~(if (seq? joining)
           (apply list (first joining) x (rest joining))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro ->>
  "Thread x through the forms. Places x in the last position of
  the first form, and then the resulting expression into the last
  position of the second form, etc. Forms which are not lists will
  be made into lists."
  [x & forms]
  (if (seq forms)
    (let [joining (first forms)]
      `(->>
        ~(if (seq? joining)
           (concat joining (list x))
           (list joining x))
        ~@(rest forms)))
    x))

(defmacro some->
  "Thread x through the forms (as by ->) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (-> ~x ~(first forms))]
       (when-not (nil? result#)
         (some-> result# ~@(next forms))))
    x))

(defmacro some->>
  "Thread x through the forms (as by ->>) until the resulting expression
  is nil or there are no more forms."
  [x & forms]
  (if (seq forms)
    `(let [result# (->> ~x ~(first forms))]
       (when-not (nil? result#)
         (some->> result# ~@(next forms))))
    x))

(defmacro cond->
  "Takes a test and form pair, threading x (as by ->) through each form for
  which the corresponding test evaluates as true. cond-> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (-> ~x ~(second clauses))
                ~x)]
       (cond-> e#
           ~@(nthnext clauses 2)))
    x))

(defmacro cond->>
  "Takes a test and form pair, threading x (as by ->>) through each form for
  which the corresponding test evaluates as true. cond->> does not short
  circuit evaluation in any case."
  [x & clauses]
  (if (seq clauses)
    `(let [e# (if ~(first clauses)
                (->> ~x ~(second clauses))
                ~x)]
       (cond->> e#
         ~@(nthnext clauses 2)))
    x))

(defmacro as->
  "Bind x to name and thread it through the forms, replacing instances of name
  in forms with the threaded expression."
  [x name & forms]
  (if (seq forms)
    `(as->
         (let [~name ~x]
           ~(first forms))
         ~name
       ~@(next forms))
    x))

(defmacro doto
  "Bind x to name and thread it through the forms, replacing instances of name
  in forms with the threaded expression."
  [x & forms]
  (let [obj-gs (gensym "obj")]
    `(let [~obj-gs ~x]
       ~@(map (fn [form]
                (apply list (first form) obj-gs (rest form)))
              forms)
       ~obj-gs)))

;;;;;;;;;;;;;;;;;;;;;;
;; String Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(import* os)

(defn format
  "Format a string as by Python's `%` operator."
  [fmt & args]
  (if (= 1 (count args))
    (let [arg (first args)]
      (if (or (map? arg) (py-dict? arg))
        (operator/mod fmt (python/dict arg))
        (operator/mod fmt arg)))
    (operator/mod fmt (python/tuple args))))

(defn subs
  "Return a substring of s from the index 'start' (inclusive) to index 'end'
  exclusive, or the end of the string if no 'end' is supplied."
  ([s start]
   (subs s start nil))
  ([s start end]
   (when (> start (count s))
     (throw (python/IndexError "Start index out of range")))
   (when-not (nil? end)
     (when (> end (count s))
       (throw (python/IndexError "End index out of range")))
     (when (> start end)
       (throw (python/IndexError "Start index must be less than or equal to end index"))))
   (operator/getitem s (python/slice start end))))

;;;;;;;;;;;;;;;;;;;;;;
;; Output Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;

(def ^:dynamic *in* sys/stdin)
(def ^:dynamic *out* sys/stdout)
(def ^:dynamic *err* sys/stderr)

(def ^:dynamic *print-sep* " ")

(defn repr
  "Return the reader representation of an object."
  [x]
  (basilisp.lang.runtime/lrepr x))

(defn flush
  "Flush the buffer currently bound to *out*."
  []
  (.flush *out*))

(defn newline
  "Write a platform specific newline to *out*."
  []
  (.write *out* os/linesep)
  nil)

(defmacro with-in-str
  "Evaluate body with *in* bound to a io.StringIO instance containing the
  string s."
  [s & body]
  `(binding [*in* (io/StringIO ~s)]
     ~@body))

(defmacro with-out-str
  "Capture the contents of text sent to *out* and return the contents as a
  string."
  [& body]
  `(binding [*out* (io/StringIO)]
     ~@body
     (. *out* ~'getvalue)))

(defn pr
  "Print the arguments to the stream bound to *out* in a format which
  is readable by the reader. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space).

  Note that some dynamically created Basilisp forms (such keywords and
  symbols) and Python objects may not be readable again."
  ([] nil)
  ([x]
   (.write *out* (repr x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn prn
  "Same as pr, but appending a newline afterwards."
  ([]
   (.write *out* \newline)
   nil)
  ([x]
   (let [stdout *out*]
     (.write stdout (repr x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map repr args))]
     (.write stdout (repr x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn pr-str
  "Return the contents of calling pr on the args as a string."
  [& args]
  (with-out-str
    (apply pr args)))

(defn prn-str
  "Return the contents of calling prn on the args as a string."
  [& args]
  (with-out-str
    (apply prn args)))

(defn print
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (print ""))
  ([x]
   (.write *out* (str x))
   nil)
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     nil)))

(defn println
  "Print the arguments to the stream bound to *out* in a format which
  is readable by humans. Multiple arguments will be separated by
  the string value bound to *print-sep* (default is an ASCII space)."
  ([] (println ""))
  ([x]
   (let [stdout *out*]
     (.write stdout (str x))
     (.write stdout \newline)
     nil))
  ([x & args]
   (let [stdout    *out*
         sep       *print-sep*
         repr-args (interpose sep (map str args))]
     (.write stdout (str x))
     (.write stdout sep)
     (.write stdout (apply str repr-args))
     (.write stdout \newline)
     nil)))

(defn print-str
  "Return the contents of calling print on the args as a string."
  [& args]
  (with-out-str
    (apply print args)))

(defn println-str
  "Return the contents of calling println on the args as a string."
  [& args]
  (with-out-str
    (apply println args)))

(defn printf
  "Prints formatted output as per format.

  Does not append a newline."
  [fmt & args]
  (print (apply format fmt args)))

;;;;;;;;;;;;;;;;;;;;
;; REPL Utilities ;;
;;;;;;;;;;;;;;;;;;;;

(def
  ^{:doc "The default data readers used in reader macros. Overriding or
          attempting to change the root binding of this var will not
          change the default data readers."}
  default-data-readers
  basilisp.lang.reader.ReaderContext/_DATA_READERS)

(def
  ^{:doc     "Data readers map which will be merged in to the default data
              reader map used by the reader. Mappings should be qualified
              symbols to functions taking one argument. The function will
              receive an unevaluated data structure and must return some
              value to the reader."
    :dynamic true}
  *data-readers*
  {})

(def
  ^{:doc     "Resolver used for resolving namespace aliases when reading
              forms using read, read-string, etc."
    :dynamic true}
  *resolver*
  basilisp.lang.runtime/resolve-alias)

(defn read-string
  "Read a string of Basilisp code.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  Note that read-string should not be used to read string input from
  untrusted sources."
  ([s]
   (read-string {:eof :eofthrow} s))
  ([opts s]
   (first (basilisp.lang.reader/read-str s
                                         *resolver*
                                         *data-readers*
                                         (:eof opts)
                                         (if (= (:eof opts) :eofthrow)
                                           true
                                           false)
                                         (:features opts)
                                         (if (= :preserve (:read-cond opts))
                                           false
                                           true)))))

(defn read
  "Read the next form from the stream. If no stream is specified, uses
  the value currently bound to *in*.

  Callers may bind a map of readers to *data-readers* to customize the
  data readers used reading this string.

  The stream must satisfy the interface of io.TextIOBase, but does not require
  any pushback capabilities. The default basilisp.lang.reader.StreamReader can
  wrap any object implementing TextIOBase and provide pushback capabilities."
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([opts stream]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     (:eof opts)
                                     (if (= (:eof opts) :eofthrow)
                                       true
                                       false)
                                     (:features opts)
                                     (if (= :preserve (:read-cond opts))
                                       false
                                       true))))
  ([stream eof-error? eof-value]
   (first (basilisp.lang.reader/read stream
                                     *resolver*
                                     *data-readers*
                                     eof-value
                                     eof-error?))))

(defn eval
  "Evaluate a form (not a string) and return its result."
  ([form]
   (eval form *ns*))
  ([form namespace]
   (let [ctx (basilisp.lang.compiler.CompilerContext. "<Eval Input>")]
     (basilisp.lang.compiler/compile-and-exec-form form
                                                   ctx
                                                   namespace))))

;;;;;;;;;;;;;;;;;;;
;; Ref Utilities ;;
;;;;;;;;;;;;;;;;;;;

(defn alter-meta!
  "Atomically swap the metadata on reference o to the result of (apply f m args) where
  m is the current metadata of o. f should be free of side effects. References include
  atoms, namespaces, and vars."
  [o f & args]
  (apply-method o alter-meta f args))

(defn reset-meta!
  "Atomically swap the metadata on reference o to meta. References include
  atoms, namespaces, and vars."
  [o meta]
  (.reset-meta o meta))

;;;;;;;;;;;;;;;;;;;
;; Var Utilities ;;
;;;;;;;;;;;;;;;;;;;

(defn alter-var-root
  "Atomically alter the Var root by calling (apply f root args) and setting
  the root as the result."
  [v f & args]
  (apply-method v alter-root f args))

(defn find-var
  "Return the Var named by namespace-qualified sym if it exists, or nil otherwise."
  [sym]
  (basilisp.lang.runtime.Var/find sym))

(defn thread-bound?
  "Return true if vars are thread-bound, which implies that a set! will succeed.
  Returns true if no vars are given."
  [& vars]
  (loop [v (first vars)
         r (rest vars)]
    (if-not v
      true
      (if (.-is-thread-bound v)
        (recur (first r) (rest r))
        false))))

(defn var-get
  "Return the value inside the Var. Return thread local bindings if they exist,
  otherwise, return the root binding."
  [v]
  @v)

(defn var-set
  "Set the binding of the Var. Must be thread-local."
  [v val]
  (if (thread-bound? v)
    (set! (.-value v) val)
    (throw
     (ex-info "Cannot set non-thread-bound Var binding" {:var v}))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(defn all-ns
  "Return a sequence of all namespaces."
  []
  (vals @basilisp.lang.runtime.Namespace/-NAMESPACES))

(defn find-ns
  "Return the namespace named by sym if it exists, or nil otherwise."
  [sym]
  (basilisp.lang.runtime.Namespace/get sym))

(defn the-ns
  "If v is a symbol, return the Namespace named by that symbol if it
  exists. If v is a Namespace, return it. Otherwise, throw an exception."
  [v]
  (cond
    (symbol? v)
    (.get basilisp.lang.runtime/Namespace v)

    (instance? basilisp.lang.runtime/Namespace v)
    v

    :else
    (throw
     (ex-info "Expected a Symbol or a Namespace"
              {:value v
               :type  (python/type v)}))))

(defn intern
  "Finds or creates a Var in ns (which is either a namespace or symbol),
  setting the root binding to val, if provided. The namespace must exist.
  Return the Var."
  ([ns name]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name)]
     (.intern ns v)))
  ([ns name val]
   (let [ns (the-ns ns)
         v  (basilisp.lang.runtime/Var ns name)]
     (set! (.-root v) val)
     (.intern ns v))))

(defn create-ns
  "Create a Namespace with the name ns-sym or return the existing one
  if it already exists."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/get-or-create ns-sym))

(defn remove-ns
  "Remove the namespace named by the symbol."
  [ns-sym]
  (basilisp.lang.runtime.Namespace/remove ns-sym))

(defn ns-name
  "Return the name of the namespace, a symbol."
  [ns]
  (.-name ns))

(defn ns-aliases
  "Return a map of Basilisp namespaces which are aliased in the current
  namespace."
  [ns]
  (reduce (fn [m entry]
            (let [alias     (key entry)
                  namespace (symbol (name (val entry)))]
              (if (= alias namespace)
                m
                (assoc m alias namespace))))
          {}
          (.-aliases (the-ns ns))))

(defn ns-imports
  "Return a set of Python modules which are imported in the current
  namespace."
  [ns]
  (.-imports (the-ns ns)))

(defn ns-interns
  "Return a map of symbols to Vars which are interned in the current
  namespace."
  [ns]
  (.-interns (the-ns ns)))

(defn ns-unalias
  "Remove the alias for the symbol sym from ns. Return nil."
  [ns sym]
  (.remove-alias (the-ns ns) sym))

(defn ns-unmap
  "Remove the mapping for the symbol sym from ns. Return nil."
  [ns sym]
  (.unmap (the-ns ns) sym))

(defn ns-publics
  "Return a map of symbols to public Vars which are interned in the
  current namespace.

  Public vars are Vars which are declared without :private metadata."
  [ns]
  (reduce (fn [m entry]
            (if (:private (meta (val entry)))
              m
              (assoc m (key entry) (val entry))))
          {}
          (ns-interns (the-ns ns))))

(defn ns-refers
  "Return a map of symbols to Vars which are referred in the current
  namespace."
  [ns]
  (.-refers (the-ns ns)))

(defn ns-map
  "Return a map of all the mapped symbols in the namespace.

  Includes the return values of ns-interns and ns-refers in one map."
  ([] (ns-map *ns*))
  ([ns]
   (let [resolved-ns (the-ns ns)]
     (merge
      (ns-interns resolved-ns)
      (ns-refers resolved-ns)))))

(defn ns-resolve
  "Return the Var which will be resolved by the symbol in the given namespace."
  [ns sym]
  (basilisp.lang.runtime/resolve-var sym (the-ns ns)))

(defn resolve
  "Return the Var which will be resolved by the symbol in the namespace currently
  bound to *ns*."
  [sym]
  (ns-resolve *ns* sym))

(defmacro import
  "Import Python modules by name.

  Modules may be specified either as symbols naming the full module path or as a
  vector taking the form `[full.module.path :as alias]`.

  Note that unlike in Python, `import`ed Python module names are always hoisted to
  the current Namespace, so imported names will be available within a Namespace even
  if the `import` itself occurs within a function or method.

  Use of `import` directly is discouraged in favor of the `:import` directive in
  the `ns` macro."
  [& modules]
  `(import* ~@modules))

(import importlib)

(defn ^:private require-libspec
  "Convert a user-specified require libspec into a map with well-defined keys.

  Required keys:
  - :namespace ns-sym, a symbol naming the Namespace being required

  Optional keys:
  - :as ns-alias, a symbol which will alias the Namespace when required (if given)
  - :refer [sym1, sym2], a sequence of symbols naming Vars to refer
  - :refer :all, if every Var should be referred
  - :only [sym1, sym2], a sequence of symbols naming Vars to refer
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name"
  [req]
  (cond
    (vector? req) (merge {:namespace (first req)}
                         (apply hash-map (rest req)))
    (symbol? req) {:namespace req}
    :else         (throw
                   (ex-info "Invalid libspec for require"
                            {:value req}))))

(defn ^:private require-lib
  "Require the library described by `libspec` into the Namespace `requiring-ns`."
  [requiring-ns libspec]
  (let [required-ns-sym  (:namespace libspec)]
    ;; In order to enable direct linking of Vars as Python variables, required
    ;; namespaces must be `require*`ed into the namespace. That's not possible
    ;; to do without a macro, so we're using this hacky approach to eval the
    ;; code directly (which will effectively add it to the root namespace module).
    (eval (list 'require*
                (if-let [ns-alias (:as libspec)]
                  [required-ns-sym :as ns-alias]
                  required-ns-sym))
          requiring-ns)
    ;; Reset the namespace to the requiring namespace, since it was likely changed
    ;; during the require process
    (set! *ns* requiring-ns)))

(defn ^:private refer-filtered-interns
  "Return a map of symbols to interned Vars in the Namespace `referred-ns` subject
  to the filters described in `libspec`."
  [referred-ns libspec]
  (when (= :all (:refer libspec))
    (throw
     (ex-info "cannot specify :refer :all for refer; use (refer 'ns-sym) instead"
              {:libspec libspec})))
  (let [only    (set (or (:refer libspec) (:only libspec)))
        exclude (set (:exclude libspec))
        rename  (get libspec :rename {})]
    (cond->> (ns-interns referred-ns)
      (seq only)    (filter (fn [entry]
                              (contains? only (key entry))))
      (seq exclude) (remove (fn [entry]
                              (contains? exclude (key entry))))
      (seq rename)  (reduce (fn [m entry]
                              (if (rename (key entry))
                                (assoc m (rename (key entry)) (val entry))
                                m))
                            {}))))

(defn ^:private refer-lib
  "Refer Vars into `requiring-ns` as described by `libspec`.

  This function assumes the referred-to Namespace has already been loaded by
  `require-lib`."
  [requiring-ns libspec]
  (let [referred-ns (the-ns (:namespace libspec))]
    (if-not (some #(contains? libspec %) [:refer :only :exclude :rename])
      (.refer-all requiring-ns referred-ns)
      (doseq [intern-entry (refer-filtered-interns referred-ns libspec)]
        (let [sym (key intern-entry)
              var (val intern-entry)]
          (.add-refer requiring-ns sym var))))))

(defn require
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:
  - symbols, which name fully qualified namespaces
  - vectors, which take the form [namespace-symbol & opts]

  Vector libspec arguments must be one of:
  - :as name, which will alias the imported namespace to the symbol name
  - :refer [& syms], which will refer syms in the local namespace directly
  - :refer :all, which will refer all symbols from the namespace directly

  Use of `require` directly is discouraged in favor of the `:require` directive in
  the `ns` macro."
  [& args]
  (let [current-ns *ns*]
    (doseq [libspec (map require-libspec args)]
      (require-lib current-ns libspec)

      ;; Add refers
      (let [new-ns    (the-ns (:namespace libspec))
            refer-opt (:refer libspec)]
        (cond
          (= :all refer-opt)
          (.refer-all current-ns new-ns)

          (seq refer-opt)
          (let [new-ns-interns (ns-interns new-ns)]
            (doseq [var-sym refer-opt]
              (let [var (get new-ns-interns var-sym)]
                (.add-refer current-ns var-sym var))))

          :else nil)))
    nil))

(defn refer
  "Refer Vars from the namespace named by ns-sym, subject to the filters specified.

  Supported filters:
  - :only [sym1 sym2], to only refer the specified symbols
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name

  Use of `refer` directly is discouraged in favor of the `:refer` modifier in the
  `:require` directive of the `ns` macro or the `:use` directive of the `ns` macro."
  [ns-sym & filters]
  (let [current-ns *ns*]
    ;; It is necessary to first require the Namespace directly, otherwise
    ;; when refer attempts to load the Namespace later, it will fail.
    (->> (require-libspec ns-sym)
         (require-lib current-ns))
    (->> (apply vector ns-sym filters)
         (require-libspec)
         (refer-lib current-ns))))

(def refer-basilisp
  "Refer Vars from basilisp.core using the same filter syntax as refer."
  (partial refer 'basilisp.core))

(def refer-clojure
  "Compatibility layer with JVM Clojure, which points to refer-basilisp."
  refer-basilisp)

(defn use
  "Load Basilisp libraries and make them accessible in the current namespace.

  Arguments should be libspecs, which take the following forms:
  - symbols, which name fully qualified namespaces
  - vectors, which take the form [namespace-symbol & opts]

  `use` is like `require` which also refers all Vars from the requiring Namespace
  afterwards. Libspecs passed to `use` may include filters as defined in `refer` to
  narrow down the referred Vars.

  Supported filters:
  - :only [sym1 sym2], to only refer the specified symbols
  - :exclude [sym1, sym2], to refer all except the specified symbols
  - :rename {sym1 new-sym1}, to rename all the specified symbols to the given new name

  Use of `use` directly is discouraged in favor of the `:use` directive in the `ns`
  macro."
  [& args]
  (let [current-ns *ns*]
    (doseq [libspec (map require-libspec args)]
      ;; Remove the :refer key to avoid having require-lib
      ;; perform a full :refer, instead we'll use refer-lib
      (->> (dissoc libspec :refer)
           (require-lib current-ns))
      (refer-lib current-ns libspec))
    nil))

(defmacro ns
  "Use this namespace pre-amble at the top of every namespace to declare
  the namespace name and import necessary Python modules and require
  Basilisp namespaces.

  You may include an optional docstring for the namespace to describe its
  purpose.

  Example:
    (ns my.namespace
       \"My namespace with code\"
       (:refer-basilisp :exclude [get])
       (:require
         [basilisp.string :as str])
       (:use
         [basilisp.set :only [intersection]])
       (:import inspect))"
  [name & opts]
  (when-not (and (symbol? name) (nil? (namespace name)))
    (throw (ex-info "Namespace name must be a non-namespaced symbol"
                    {:name name})))
  (let [doc  (when (string? (first opts))
               (first opts))
        opts (if doc (rest opts) opts)
        opts (reduce (fn [m opt]
                       (let [opt-name (first opt)
                             options  (rest opt)]
                         (when-not (keyword? opt-name)
                           (throw (ex-info "Namespace option must be a keyword"
                                           {:option opt-name})))
                         (assoc m opt-name (vec options))))
                     {}
                     opts)

        refer-filters (when-let [filters (or (:refer-basilisp opts)
                                             (:refer-clojure opts))]
                        (map #(list 'quote %) filters))
        requires      (when (:require opts)
                        `(require ~@(map #(list 'quote %) (:require opts))))
        uses          (when (:use opts)
                        `(use ~@(map #(list 'quote %) (:use opts))))
        imports       (when (:import opts)
                        (map (fn [v]
                               `(import ~v))
                             (:import opts)))]
    `(do
       (in-ns (quote ~name))
       ~(when doc
          `(alter-meta! (the-ns (quote ~name)) assoc :doc ~doc))
       (refer-basilisp ~@refer-filters)
       ~requires
       ~uses
       ~@imports)))

;;;;;;;;;;;;;;;;;;;;;
;; Regex Functions ;;
;;;;;;;;;;;;;;;;;;;;;

(import re)

(defn re-pattern
  "Return a new re.Pattern instance."
  [s]
  (re/compile s))

(defn re-find
  "Returns the first match of a string to a pattern using re.search.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/search pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn re-matches
  "Returns a match of a string to a pattern using re.fullmatch.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (let [match (re/fullmatch pattern s)]
    (when match
      (let [groups (.groups match)]
        (if (zero? (count groups))
          (.group match 0)
          (vec (cons (.group match 0) groups)))))))

(defn ^:private lazy-re-seq
  "Return a lazy sequence of the matches in a match iterator."
  [iter]
  (lazy-seq
   (when (first iter)
     (let [match (.group (first iter) 0)]
       (cons match (when (seq (rest iter))
                     (lazy-re-seq (rest iter))))))))

(defn re-seq
  "Returns a lazy sequence of matches of a string to a pattern using re.finditer.

  If the string matches the pattern exactly and there are no match
  groups, return the string. Otherwise, return a vector with the string
  in the first position and the match groups in the following positions."
  [pattern s]
  (lazy-re-seq (seq (re/finditer pattern s))))

;;;;;;;;;;;;;;;;;;
;; Multimethods ;;
;;;;;;;;;;;;;;;;;;

(import basilisp.lang.multifn)

(defmacro defmulti
  "Define a new multimethod with the dispatch function."
  [name & body]
  (let [doc         (when (string? (first body))
                      (first body))
        name        (if doc
                      (vary-meta name assoc :doc doc)
                      name)
        body        (if doc
                      (rest body)
                      body)
        dispatch-fn (first body)
        opts        (apply hash-map (rest body))]
    `(def ~name (basilisp.lang.multifn/MultiFunction ~(quote name)
                                                     ~dispatch-fn
                                                     ~(or (:default opts) :default)))))

(defmacro defmethod
  "Add a new method to the multi-function which responds to dispatch-val."
  [multifn dispatch-val & fn-tail]
  `(. ~multifn (~'add-method ~dispatch-val (fn ~@fn-tail))))

(defn methods
  "Return a map of dispatch values to methods for the given multi function."
  [multifn]
  (.-methods multifn))

(defn get-method
  "Return the method which would respond to dispatch-val or nil if no method
  exists for dispatch-val."
  [multifn dispatch-val]
  (.get-method multifn dispatch-val))

(defn remove-method
  "Remove the method which responds to dispatch-val, if it exists. Return the
  multi function."
  [multifn dispatch-val]
  (.remove-method multifn dispatch-val)
  multifn)

(defn remove-all-methods
  "Remove all method for this multi-function. Return the multi function."
  [multifn]
  (.remove-all-methods multifn)
  multifn)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn replace
  "Replace elements of the vector/seq coll with matching elements from the
  associative collection smap, if they exist."
  [smap coll]
  (if (vector? coll)
    (persistent!
     (reduce (fn [res v]
               (if-let [newv (get smap v)]
                 (conj! res newv)
                 res))
             (transient [])
             coll))
    (map (fn [v]
           (if-let [newv (get smap v)]
             newv
             v))
         coll)))

(defn select-keys
  "Return a map with only the keys of m which are in ks."
  [m ks]
  (persistent!
   (reduce (fn [new-map k]
             (if (contains? m k)
               (assoc! new-map k (get m k))
               new-map))
           (transient {})
           ks)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Destructuring Support ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmulti ^:private destructure-def
  (fn [arg]
    (cond
      (symbol? arg) :symbol
      (vector? arg) :vector
      (map? arg)    :map
      :else         :default)))

(defmethod destructure-def :map
  [arg]
  (let [alias (or (:as arg) (gensym "map_arg_"))

        ;; :or bindings allow users to specify default values for certain
        ;; associative keys.
        or-bindings (:or arg)

        ;; Namespaced keywords can destructure into non-namespaced
        ;; local names by specifying the namespace and with the name
        ;; "keys", just as the non-namespaced name "keys" will access
        ;; non-namespaced keywords.
        ;;
        ;; (let [{:movie/keys [title actors]} {:movie/title  "Die Hard"
        ;;                                     :movie/actors ["Bruce Willis"]}]
        ;;   ...)
        ;;
        kw-keys (->> (keys arg)
                     (filter keyword?)
                     (filter #(= "keys" (name %))))

        ;; Keyword, string, and symbol keys may all be destructured from
        ;; associative types.
        kws  (mapcat (fn [kw]
                       (let [kw-ns (namespace kw)
                             syms  (get arg kw)]
                         (cond->> syms
                           kw-ns (map #(symbol kw-ns (name %))))))
                     kw-keys)
        strs (:strs arg)
        syms (:syms arg)

        ;; Fetch all the remaining keys in the map which do not
        ;; correspond to special functionality.
        remaining (->> [:as :or :strs :syms]
                       (concat kw-keys)
                       (apply dissoc arg))

        ;; Destructuring forms may be nested arbitrarily, so generate the
        ;; definitions for any nested destructured forms as well.
        children (map #(vector % (destructure-def %)) (keys remaining))]
    {:name alias
     :type :map
     :keys kws
     :strs strs
     :syms syms

     :or-bindings or-bindings
     :remaining   (->> children
                       (filter #(not= :symbol (:type (second %))))
                       (map first)
                       (apply dissoc remaining))

     :children (map second children)}))

(defmethod destructure-def :symbol
  [arg]
  {:name arg
   :type :symbol})

(defmethod destructure-def :vector
  [arg]
  (let [;; Fetch the name bound to this argument with any trailing
        ;; :as key.
        alias-args (drop-while (partial not= :as) arg)
        alias      (->> alias-args (apply hash-map) :as)

        ;; Split the remaining arguments into sequential arguments
        ;; and the rest arg (if one at all).
        args (->> arg
                  (drop-last (count alias-args))
                  (split-with (partial not= '&)))

        sequential-args (first args)
        rest-arg        (second args)]
    {:name       (or alias (gensym "vec_arg_"))
     :type       :vector
     :rest       (when (seq rest-arg)
                   {:starts (count sequential-args)
                    :name   (second rest-arg)})
     :children   (map destructure-def sequential-args)}))

(defmethod destructure-def :default
  [arg]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (python/type arg)
             :arg  arg})))

(defmulti ^:private destructure-binding
  (fn [ddef]
    (:type ddef)))

(defmethod destructure-binding :vector
  [ddef]
  (let [fn-arg          (:name ddef)
        sequential-args (->> (:children ddef)
                             (map-indexed (fn [idx child]
                                            (let [alias (:name child)]
                                              (concat
                                               [alias `(nth ~fn-arg ~idx nil)]
                                               (when-not (= :symbol (:type child))
                                                 (destructure-binding child))))))
                             (apply concat))
        rest-def        (:rest ddef)
        rest-arg        (when rest-def
                          [(:name rest-def) `(nthnext ~fn-arg ~(:starts rest-def))])]
    (concat
     sequential-args
     rest-arg
     (->> (:children ddef)
          (filter #(not= :symbol (:type %)))
          (mapcat destructure-binding)))))

(defmethod destructure-binding :map
  [ddef]
  (let [fn-arg (:name ddef)
        ors    (:or-bindings ddef)

        kw-binding (fn [arg]
                     (let [kw-ns      (namespace arg)
                           kw-name    (name arg)
                           sym        (symbol kw-name)
                           kw         (if kw-ns
                                        (keyword kw-ns kw-name)
                                        (keyword kw-name))
                           or-binding (get ors sym)]
                       (if or-binding
                         [sym `(or (get ~fn-arg ~kw) ~or-binding)]
                         [sym `(get ~fn-arg ~kw)])))

        map-binding (fn [f arg]
                      (let [k          (f arg)
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg ~k) ~or-binding)]
                          [arg `(get ~fn-arg ~k)])))

        sym-binding (fn [arg]
                      (let [k          (symbol (name arg))
                            or-binding (get ors arg)]
                        (if or-binding
                          [arg `(or (get ~fn-arg (quote ~k)) ~or-binding)]
                          [arg `(get ~fn-arg (quote ~k))])))

        rem-binding (fn [arg]
                      (let [binding    (key arg)
                            key        (val arg)
                            or-binding (get ors binding)]
                        (if or-binding
                          [binding `(or (get ~fn-arg (quote ~key)) ~or-binding)]
                          [binding `(get ~fn-arg ~key)])))

        child-binding (fn [child]
                        (let [alias (name (:name child))
                              arg   (symbol alias)
                              k     (keyword alias)]
                          [arg `(get ~fn-arg ~k)]))

        non-sym-children (filter #(not= :symbol (:type %)) (:children ddef))]
    (concat
     (mapcat kw-binding (:keys ddef))
     (mapcat (partial map-binding name) (:strs ddef))
     (mapcat sym-binding (:syms ddef))
     (mapcat rem-binding (:remaining ddef))
     (mapcat child-binding non-sym-children)
     (mapcat destructure-binding non-sym-children))))

(defmethod destructure-binding :default
  [ddef]
  (throw
   (ex-info "Invalid destructuring argument type"
            {:type (:type ddef)})))

(defn ^:private fn-arity-with-destructuring
  "Take a function arity definition (an argument vector and 0 or more body
  expressions) whose argument vector may or may not require destructuring
  and return a function arity definition which uses only bare symbols and
  wraps the original definition in a let binding which performs the
  destructuring steps.

  As an example, for sequential destructuring like:

    (fn [[f & r]]
      {:first f
       :rest  r})

  This function would emit a list of:

    [vec_arg_3432]
    (let* [f (get vec_arg_3432 0)
           r (nthnext vec_arg_3432 1)]
      {:first f
       :rest  r})"
  [body]
  (let [args (first body)
        body (rest body)

        arg-groups (split-with (partial not= '&) args)
        args       (first arg-groups)
        rest-args  (second arg-groups)
        rest-defs  (map destructure-def rest-args)

        rest-binding (concat
                      (let [rest-arg (second rest-defs)]
                        (when (= :map (:type rest-arg))
                          `[~(:name rest-arg) (apply hash-map ~(:name rest-arg))]))
                      (->> rest-defs
                           (filter #(not= :symbol (:type %)))
                           (mapcat destructure-binding)))

        defs     (map destructure-def args)
        arg-vec  (vec (concat
                       (map :name defs)
                       (map :name rest-defs)))
        bindings (->> defs
                      (filter #(not= :symbol (:type %)))
                      (mapcat destructure-binding)
                      (concat rest-binding))
        new-body (if (seq bindings)
                   [`(let* [~@bindings]
                       ~@body)]
                   body)]
    (apply list arg-vec new-body)))

(defmacro ^:no-warn-on-redef fn
  "Return an anonymous (but possibly named) function.

  Function argument vectors support sequential and associative destructuring."
  [& body]
  (let [name    (when (symbol? (first body))
                  (first body))
        body    (cond-> body name rest)
        arities (cond
                  (vector? (first body))
                  (fn-arity-with-destructuring body)

                  (seq? (first body))
                  (apply list (map fn-arity-with-destructuring body))

                  :else
                  body)]
    (as-> arities $
      (cond->> $ name (cons name))
      (cons 'fn* $)
      (cond-> $
        (meta &form) (with-meta (meta &form))))))

(defn destructure
  "Take a [binding expr] pair (as from a let block) and produce all of the
  replacement bindings for the binding which perform destructuring on the
  initial expression.

  As an example, for sequential destructuring like:

    [f & r :as v] [1 2 3 4]

  This function would emit a list of bindings which can be inserted directly
  into a let* binding to perform destructuring:

     (v [1 2 3 4]
      f (nth v 0)
      r (nthnext v 1))"
  [[binding expr]]
  (let [ddef      (destructure-def binding)
        orig-name (:name ddef)
        bindings  (if (= :symbol (:type ddef))
                    []
                    (destructure-binding ddef))]
    (apply list orig-name expr bindings)))

(defmacro ^:no-warn-on-redef let
  "Let bindings with destructuring support."
  [bindings & body]
  `(let* [~@(->> (partition 2 bindings)
                 (mapcat destructure))]
     ~@body))

(defmacro letfn
  "Let form specifically for function definitions.

  Functions are defined as bindings:

    [(plus-two [x] (+ (plus-one x) 1))
     (plus-one [x] (+ x 1))]

  Functions defined in `letfn` bindings may refer to each other regardless
  of their order of definition."
  [bindings & body]
  `(letfn* [~@(mapcat (fn [fn-body]
                        [(first fn-body) (cons `fn fn-body)])
                      bindings)]
           ~@body))

(defn ^:private loop-with-destructuring
  "Take a loop definition (an binding vector and 0 or more body
  expressions) whose binding vector may or may not require destructuring
  and return a loop binding vector and loop body."
  [bindings body]
  (let [defs           (->> (take-nth 2 bindings)
                            (map destructure-def))
        binding-vec    (vec (mapcat (fn [ddef binding]
                                      [(:name ddef) binding])
                                    defs
                                    (take-nth 2 (drop 1 bindings))))
        inner-bindings (->> defs
                            (filter #(not= :symbol (:type %)))
                            (mapcat destructure-binding))
        new-body       (if (seq inner-bindings)
                         [`(let* [~@inner-bindings]
                             ~@body)]
                         body)]
    [binding-vec new-body]))

(defmacro ^:no-warn-on-redef loop
  "Loop bindings with destructuring support."
  [bindings & body]
  (let [[bindings body] (loop-with-destructuring bindings body)]
    `(loop* ~bindings
        ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;
;; Interop Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

(defn lisp->py
  "Recursively convert Basilisp data structures into Python data structures.

  Callers can specify a keyword argument :keyword-fn, which names a function
  which is called for each keyword value in the input structure to return a
  new value. By default :keyword-fn is the function `name`."
  ([o]
   (basilisp.lang.runtime/to-py o))
  ([o & {:keys [keyword-fn] :or {keyword-fn name}}]
   (basilisp.lang.runtime/to-py o keyword-fn)))

(defn py->lisp
  "Recursively convert Python data structures into Basilisp data structures.

  Callers can specify a keyword argument :keywordize-keys, which defaults to
  true. If :keywordize-keys is true, then all string keys in Python dicts will
  be converted into keywords in the final return value."
  ([o]
   (basilisp.lang.runtime/to-lisp o))
  ([o & {:keys [keywordize-keys] :or {keywordize-keys true}}]
   (basilisp.lang.runtime/to-lisp o keywordize-keys)))

;;;;;;;;;;;;;;;;
;; Interfaces ;;
;;;;;;;;;;;;;;;;

(import* abc)

(defmulti munge
  "Munge the input value into a Python-safe string. Converts keywords and
  symbols into strings as by `name` prior to munging. Returns a string."
  python/type)

(defmethod munge basilisp.lang.keyword/Keyword
  [kw]
  (basilisp.lang.util/munge (name kw)))

(defmethod munge basilisp.lang.symbol/Symbol
  [s]
  (basilisp.lang.util/munge (name s)))

(defmethod munge python/str
  [s]
  (basilisp.lang.util/munge s))

(def namespace-munge
  "Convert a Basilisp namespace name to a valid Python name."
  munge)

(defn gen-interface
  "Generate and return a new Python interface (abstract base clase).

  Options may be specified as key-value pairs. The following options are supported:
  - :name    - the name of the interface as a string; required
  - :extends - a vector of interfaces the new interface should extend; optional
  - :methods - an optional vector of method signatures without `self` or `this`, like:
               [ (method-name [args ...] docstring) ... ]

  Callers should use `definterface` to generate new interfaces."
  [& opts]
  (let [opt-map        (apply hash-map opts)
        interface-name (:name opt-map)
        extends        (as-> (:extends opt-map []) $
                         (remove #(identical? abc/ABC %) $)
                         (concat $ [abc/ABC])
                         (python/tuple $))]
    (->> (:methods opt-map)
         (map (fn [[method-name args docstring]]
                (let [includes-self? (contains? #{'self 'this} (first args))
                      total-arity    (cond-> (count args) includes-self? (dec))
                      is-variadic?   (let [[_ [amp rest-arg]] (split-with #(not= '& %) args)]
                                       (and (= '& amp) (not (nil? rest-arg))))
                      fixed-arity    (cond-> total-arity is-variadic? (- 2))]
                  {:method-name  method-name
                   :args         args
                   :fixed-arity  fixed-arity
                   :is-variadic? is-variadic?
                   :docstring    docstring
                   :python-name  (->> (if is-variadic? "_rest" fixed-arity)
                                      (str "_" (munge method-name) "_arity"))})))
         (group-by :method-name)
         (mapcat (fn [[method-name arities]]
                   (if (> (count arities) 1)
                     (let [fixed-arities            (->> arities
                                                         (remove :is-variadic?)
                                                         (map :fixed-arity))
                           variadic-arities         (filter :is-variadic? arities)
                           fixed-arity-for-variadic (some-> variadic-arities first :fixed-arity)
                           num-variadic             (count variadic-arities)]
                       (when (not= (count (set fixed-arities))
                                   (count fixed-arities))
                         (throw
                          (ex-info (str "Interface methods may not have multiple methods "
                                        "with the same fixed arity")
                                   {:arities       arities
                                    :fixed-arities (vec fixed-arities)})))
                       (when (> num-variadic 1)
                         (throw
                          (ex-info "Interface methods may have at most one variadic arity"
                                   {:arities      arities
                                    :num-variadic num-variadic})))
                       (when (and fixed-arity-for-variadic
                                  (some #(< fixed-arity-for-variadic %) fixed-arities))
                         (throw
                          (ex-info (str "Interface methods may not have a fixed arity "
                                        "greater than the arity of a variadic method")
                                   {:arities                  arities
                                    :fixed-arity-for-variadic fixed-arity-for-variadic
                                    :fixed-arities            fixed-arities})))
                       ;; multi-arity methods need to include an outer dispatch method,
                       ;; which will not be defined by the user and must be defined here
                       (conj arities
                             {:method-name method-name
                              :python-name (munge method-name)
                              :args        '[& args]
                              :docstring   (-> arities first :docstring)}))
                     ;; single arity methods should not have a private Python name
                     ;; since they do not have an outer dispatch method
                     (map (fn [{:keys [method-name] :as arity}]
                            (assoc arity :python-name (munge method-name)))
                          arities))))
         (reduce (fn [m {:keys [method-name python-name args docstring]}]
                   (let [method (->>  args
                                      (map #(vary-meta % assoc :no-warn-when-unused true))
                                      (apply vector)
                                      (list 'fn* method-name)
                                      (eval)
                                      (abc/abstractmethod))]
                     (when docstring
                       (set! (.- method __doc__) docstring))
                     (assoc m python-name method)))
                 {})
         (lisp->py)
         (python/type interface-name extends))))

(defmacro definterface
  "Define a new Python interface (abstract base clase) with the given name
  and method signatures.

  Method signatures are in the form (method-name [arg1 arg2 ...]). `self` or
  `this` arguments must be omitted from all interfaces.

  Interface objects cannot be directly instantiated. Instead, you must create
  a concrete implementation of an interface (perhaps via deftype) and supply
  implementations for all of the abstract methods.

  The generated interface derives from Python's `abc.ABC` and all method
  definitions are declared as `abc.abstractmethod`s and thus must be implemented
  by a concrete type.

  Interfaces created by `definterface` cannot be declared as properties, class
  methods, or static methods, as with `deftype`."
  [interface-name & methods]
  (let [name-str    (name interface-name)
        method-sigs (->> methods
                         (map (fn [[method-name args docstring]]
                                [method-name (conj args 'self) docstring]))
                         (map #(list 'quote %)))]
    `(def ~interface-name
       (gen-interface :name ~name-str
                      :methods [~@method-sigs]))))

;;;;;;;;;;;;;;;
;; Protocols ;;
;;;;;;;;;;;;;;;

(import* functools)

(defn ^:private gen-protocol-dispatch
  "Return the dispatch function for a single protocol method."
  [protocol-name interface-name [method-name & args+docstring :as method-def]]
  (let [[arglists [docstring]] (split-with (complement string?) args+docstring)]
    [`(def ~(vary-meta method-name
                       assoc
                       :doc docstring
                       :arglists (list 'quote arglists))
        (functools/singledispatch
         (fn ~method-name
           ~@(map (fn [[obj-sym & args]]
                    (list `[~obj-sym ~@(map #(vary-meta % assoc :no-warn-when-unused true) args)]
                          `(let [obj-type# (python/type ~obj-sym)]
                             (throw
                              (ex-info (str
                                        ~(str "No implementation of method " method-name " found for type ")
                                        obj-type#)
                                       {:protocol    (var ~protocol-name)
                                        :method      ~method-name
                                        :object-type obj-type#})))))
                  arglists))))
     (let [dotted-method-name (symbol (str "." (name method-name)))]
       `(.register ~method-name
                   ~interface-name
                   (fn ~method-name
                     ~@(map (fn [[obj-sym & args]]
                              (let [has-varargs (some #(= '& %) args)
                                    clean-args  (filter #(not= '& %) args)]
                                (list `[~obj-sym ~@args]
                                      (if has-varargs
                                        `(apply-method ~obj-sym ~method-name ~@clean-args)
                                        `(~dotted-method-name ~obj-sym ~@clean-args)))))
                            arglists))))]))

;; For each protocol, the following keys are defined:
;;
;; - :impls     - a set of types which dynamically extend the Protocol
;;                (e.g. by `extend`)
;; - :interface - the Python interface type which backs the Protocol
;; - :methods   - a mapping of method names (as Basilisp keywords) to the dispatch
;;                method backing the Protocol method
;; - :var       - a reference to the Var the Protocol is stored in

(defmacro defprotocol
  "Define a new protocol.

  Protocols are similar to classical programming interfaces. Rather than defining an
  interface and implementing that interface on different objects, protocols generate
  a set of functions which dispatch to the correct implementation on the type of their
  first argument (which is similar to the Python `self` argument).

  Also like interfaces, Protocols do not include implementations for any of their member
  methods. Instead, implementations can be provided using `deftype`, `defrecord`,
  `reify`, or `extend` (or any of the `extend-*` macros).

  Despite their differences from interfaces, Protocols do also generate a standard
  Python interface type (deriving from `abc.ABC`) which is used for efficient dispatch
  for implementing types.

  Method signatures are in the form:

    (method-name [self arg1] [self arg1 arg2] \"This method foos the bars.\")

  Callers must provide the `self` or `this` arguments for each method."
  [protocol-name & methods]
  (let [doc           (when (string? (first methods))
                        (first methods))
        methods       (if doc (rest methods) methods)
        protocol-name (vary-meta
                       (cond-> protocol-name
                         doc (vary-meta assoc :doc doc))
                       assoc
                       :protocol true
                       :redef true)
        interface-sym (gensym "interface-name")]
    `(do
       (defonce ~protocol-name {})
       (alter-meta! (var ~protocol-name)
                    assoc
                    :doc ~doc
                    :basilisp.core/protocol true)
       (let [~interface-sym (gen-interface :name ~(name protocol-name)
                                           :methods [~@(mapcat
                                                        (fn [[method-name & args+docstring]]
                                                          (let [[arglists [docstring]] (split-with
                                                                                        (complement string?)
                                                                                        args+docstring)]
                                                            (map (fn [args]
                                                                   (list 'quote
                                                                         `(~method-name
                                                                           ~args
                                                                           ~@(when docstring [docstring]))))
                                                                 arglists)))
                                                        methods)])]
         ~@(mapcat #(gen-protocol-dispatch protocol-name interface-sym %) methods)
         (->> {:impls     #{}
               :interface ~interface-sym
               :methods   ~(apply hash-map
                                  (mapcat #(let [v (first %)]
                                             [(keyword (name v)) v])
                                          methods))
               :var       (var ~protocol-name)}
              (alter-var-root (var ~protocol-name) merge ~protocol-name)))
       ~protocol-name)))

(defn ^:private protocol?
  "Return true if x is a Protocol."
  [x]
  (boolean (and (map? x) (:interface x))))

(defn extend
  "Extend a type dynamically with one or Protocol implementations. This is useful
  for types which were defined outside your control or which were not otherwise
  defined as direct implementors of the named Protocol(s). With `extend`, such
  types may be extended without modifying the types directly.

  `target-type` should name a type which is to be extended. Virtually any type
  is permitted, so long as that that type is not also a Protocol. If `target-type`
  is an interface, objects of types implementing that interface will be extended
  by the given implementation unless a more concrete implementation is available
  (by the Python method resolution order of the object's type). If `target-type`
  is `nil`, it will be interpreted as `(python/type nil)`.

  `proto+methods` are interleaved Protocol names and maps of Protocol method
  implementations intended for `target-type`. The keys of each map are keywords
  corresponding to the names of the Protocol methods (as defined in the
  `defprotocol`). Each value should be either an existing function (referenced
  by its Var or name binding) or a new function definition.

  `extend` may be called multiple times for a single `target-type`, so not all
  implementations need to be known a priori. Successive calls to `extend` on
  `target-type` with the same Protocol implementations will overwrite previous
  implementations.

  If you are extending types with explicit function definitions, the
  `extend-protocol` and `extend-type` macros offer some additional conveniences.

  Returns `nil`.

  Example:

    (extend SomeType
      FirstProto
      {:spam spam-fn
       :eggs (fn [...] ...)}
      OtherProto
      {:ham  (fn [...] ...)})"
  [target-type & proto+methods]
  (let [target-type (cond-> target-type (nil? target-type) (python/type))]
    (cond
      (protocol? target-type)
      (throw (ex-info "Protocols may not be extended with other Protocols"
                      {:target-type target-type}))

      (not (instance? python/type target-type))
      (throw (ex-info "extend target-type must be a type"
                      {:target-type target-type})))

    (doseq [proto-pair (apply hash-map proto+methods)
            :let       [[proto method-map] proto-pair]]
      (when-not (protocol? proto)
        (throw (ex-info "extend protocol must be protocol as defined by defprotocol"
                        {:target-type target-type
                         :proto       proto})))
      (when (identical? target-type proto)
        (throw (ex-info "Protocol may not extend itself"
                        {:target-type target-type
                         :proto       proto})))

      (->> (fn [old-root]
             (let [proto-methods (:methods proto)]
               (let [proto-method-names (set (keys proto-methods))
                     impl-method-names  (set (keys method-map))]
                 (when-not (= proto-method-names impl-method-names)
                   (throw (ex-info "target-type must implement all protocol methods"
                                   {:missing-methods (->> proto-method-names
                                                          (remove impl-method-names)
                                                          (set))}))))
               (let [proto-method-arity-map (reduce-kv (fn [m k v]
                                                         (assoc m k (.-arities v)))
                                                       {}
                                                       proto-methods)
                     impl-method-arity-map  (reduce-kv (fn [m k v]
                                                         (assoc m k (.-arities v)))
                                                       {}
                                                       method-map)]
                 (doseq [proto-method proto-method-arity-map
                         :let         [[proto-method-name proto-method-arities] proto-method]]
                   (let [impl-method-arities (get impl-method-arity-map proto-method-name)]
                     (when (not= impl-method-arities proto-method-arities)
                       (throw (ex-info "target-type must implement all protocol method arities"
                                       {:proto-method    proto-method-name
                                        :proto-method-arities proto-method-arity-map
                                        :impl-method-arities impl-method-arity-map
                                        :missing-arities (->> proto-method-arities
                                                              (remove impl-method-arities)
                                                              (set))}))))))
               (doseq [method-def method-map
                       :let       [[method-name fn] method-def]]
                 (let [dispatch-method (get proto-methods method-name)]
                   (.register dispatch-method target-type fn))))
             (update old-root :impls conj target-type))
           (alter-var-root (:var proto)))))

  nil)

(defn ^:private sym-and-method-groups
  "Group methods for `extend-protocol` and `extend-type` into a map of interface
  names to a vector of method bodies."
  [specs]
  (loop [iface   (first specs)
         specs   (rest specs)
         methods []
         groups  {}]
    (cond
      (not (seq specs))
      (assoc groups iface methods)

      (list? (first specs))
      (recur iface
             (rest specs)
             (conj methods (first specs))
             groups)

      (or (symbol? (first specs)) (nil? (first specs)))
      (recur (first specs)
             (rest specs)
             []
             (assoc groups iface methods)))))

(defn ^:private extend-map
  "Convert a vector of method definitions (as expected by `extend-protocol` and
  `extend-type`) into a map of method definitions which can be passed to `extend`. "
  [methods]
  (->> (group-by first methods)
       (reduce (fn [m [method-name arities]]
                 (->> (map rest arities)
                      (apply list `fn)
                      (assoc! m (keyword (name method-name)))))
               (transient {}))
       (persistent!)))

(defmacro extend-protocol
  "Extend a Protocol with implementations for multiple types.

  This convenience macro is useful for extending multiple different types with
  a single Protocol definition in one call. Note that this macro only supports
  new function declarations. If you intend to reference an existing function,
  call `extend` directly.

  For example, this call:

    (extend-protocol SomeProto
      FirstType
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...)
      OtherType
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...))

  Would be turned into the following `extend` calls:

    (do
      (extend FirstType
        SomeProto
        {:spam (fn spam
                 ([this] ...)
                 ([this arg] ...))
         :eggs (fn [this arg1 arg2] ...)})
      (extend OtherType
        SomeProto
        {:spam (fn spam
                 ([this] ...)
                 ([this arg] ...))
         :eggs (fn [this arg1 arg2] ...)}))"
  [proto & specs]
  `(do ~@(map (fn [[target-type methods]]
                `(extend ~target-type
                   ~proto
                   ~(extend-map methods)))
              (sym-and-method-groups specs))))

(defmacro extend-type
  "Extend a type with multiple Protocol implementations.

  This convenience macro is useful for extending a single type with multiple
  different Protocol definitions in one call. Note that this macro only supports
  new function declarations. If you intend to reference an existing function,
  call `extend` directly.

  For example, this call:

    (extend-type SomeType
      FirstProto
      (spam
        ([this] ...)
        ([this arg] ...))
      (eggs [this arg1 arg2] ...)
      SecondProto
      (ham [this & args] ...))

  Would be turned into the following `extend` call:

    (extend SomeType
      FirstProto
      {:spam (fn spam
               ([this] ...)
               ([this arg] ...))
       :eggs (fn eggs [this arg1 arg2] ...)}
      SecondProto
      {:ham (fn ham [this & args] ...)})"
  [target-type & specs]
  `(extend ~target-type
     ~@(mapcat (fn [[proto methods]]
                 [proto (extend-map methods)])
               (sym-and-method-groups specs))))

(defn extenders
  "Return a collection of types explicitly extending proto.

  The returned collection will not include types which extend proto via
  inheritance (as by `deftype` and `defrecord`). Only types extending
  proto via `extend` (or `extend-protocol` or `extend-type`) will appear."
  [{:keys [impls] :as proto}]
  (apply list impls))

(defn extends?
  "Return true if type extends protocol proto."
  [{:keys [interface impls] :as proto} type]
  (or (python/issubclass type interface)
      (contains? impls type)))

(defn satisfies?
  "Return true if x satisfies protocol proto."
  [{:keys [interface impls] :as proto} x]
  (or (instance? interface x)
      (python/isinstance x (python/tuple impls))))

;;;;;;;;;;;;;;;;
;; Data Types ;;
;;;;;;;;;;;;;;;;

(defn ^:private collect-methods
  "Collect method and interface declarations for `deftype`, `defrecord`, and `reify`
  into a map containing `:interfaces` and `:methods` keys."
  [method-impls]
  (group-by (fn [v]
              (cond
                (symbol? v) :interfaces
                (seq v)     :methods
                :else       (throw
                             (ex-info "Expected method definition or interface name"
                                      {:value v :type (type v)}))))
            method-impls))

(defmacro deftype
  "Define a new Python concrete type which can implement 0 or more Python
  interfaces or Basilisp protocols.

  The new type will have fields matching the names in `fields`. Fields may
  be referred to unqualified in the bodies of implemented methods. By default
  the fields of this type are immutable. Attempting to set non-mutable fields
  from a method body will result in a compiler error.

  Fields may be made mutable by annotating their definition with `:mutable`
  metadata. Mutable fields may be set within method bodies using the `set!`
  special form. It is not advised to use mutable fields unless you are sure
  you know what you are doing. As a consequence of Python's lax policy towards
  immutability, types with even one mutable field may be mutated by outside
  callers using `set!`, so bear that in mind when choosing mutability.

  Interface or protocol implementations are declared as the name of the
  interface or protocol as a symbol, followed by 1 or more method
  definitions for that interface. Types are not required to declare any
  interface implementations. Types which do declare interface implementations
  are required to implement all interface methods. Failing to implement all
  interface methods is a compile time error. Types implementing `object` are
  not required to implement all `object` methods.

  Method declarations should appear as:

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Unlike in Clojure, interface and protocol methods are permitted to include
  variadic arguments. Single-arity methods may also declare support for
  keyword arguments using either the `:apply` or `:collect` strategy on the
  `:kwargs` metadata on the method name. Methods may be declared as static
  (using the `:staticmethod`) or class methods (using the `:classmethod`)
  metadata on the the name. Both static methods and class methods can be
  declared with multiple arities or may be defined with a single arity and
  keyword arguments. Finally, single-arity methods may be declared as Python
  properties using the `:property` metadata on the method name. These facilities
  are provided as a means to interoperate with Python code and their use is
  discouraged in pure Basilisp code.

  Type objects are created with sensible `object` defaults as by `attrs`.
  New types may override `object` defaults. An `__init__` function is
  automatically created which takes positional arguments matching the
  order of definition in `fields`. Additionally, given a name `NewType`,
  a factory function will be created `->NewType` which can be used to
  generate new instances of the type.

  Methods must supply a `this` or `self` parameter. `recur` special forms
  used in the body of a method should not include that parameter, as it
  will be supplied automatically."
  [type-name fields & method-impls]
  (let [ctor-name (with-meta
                    (symbol (str "->" (name type-name)))
                    (meta type-name))

        {:keys [interfaces methods]} (collect-methods method-impls)]
    `(do
       (deftype* ~type-name ~fields
         :implements [~@interfaces
                      ~'basilisp.lang.interfaces/IType
                      ~'python/object]
         ~@methods)
       (def ~ctor-name ~type-name)
       ~type-name)))

(defmacro reify
  "Create a new Python object of an anonymous type which implements 0 or more
  Python interfaces or Basilisp protocols.

  Unlike types created via `deftype`, `reify` returns an object which implements
  the named interfaces using the implementations provided. You may not provide
  fields as such to `reify`, though `reify` closes over any local names defined
  in the same lexical context. These fields may serve as private fields of the
  created object.

  Interface or protocol implementations are declared as the name of the
  interface or protocol as a symbol, followed by 1 or more method
  definitions for that interface. Types are not required to declare any
  interface implementations. Types which do declare interface implementations
  are required to implement all interface methods. Failing to implement all
  interface methods is a compile time error. Types implementing `object` are
  not required to implement all `object` methods.

  Method declarations should appear as:

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Unlike in Clojure, interface and protocol methods are permitted to
  include variadic arguments. Single-arity methods may also declare support for
  keyword arguments using either the `:apply` or `:collect` strategy on the
  `:kwargs` metadata on the method name. Finally, single-arity methods may be
  declared as Python properties using the `:property` metadata on the method
  name. These facilities are provided as a means to interoperate with Python
  code and their use is discouraged in pure Basilisp code.

  `reify` does not support class method or static method members and attempting
  to declare `reify` members as class or static members will result in a
  compile time error.

  Type objects are created with sensible `object` defaults as by `attrs`.
  New types may override `object` defaults.

  Reified objects always implement `basilisp.lang.interfaces/IWithMeta` and
  transfer the metadata from the form to the created object.

  Methods must supply a `this` or `self` parameter. `recur` special forms
  used in the body of a method should not include that parameter, as it
  will be supplied automatically."
  [& method-impls]
  (let [{:keys [interfaces methods]} (collect-methods method-impls)]
    (with-meta
      `(reify* :implements [~@interfaces python/object]
               ~@methods)
      (meta &form))))

;;;;;;;;;;;;;
;; Records ;;
;;;;;;;;;;;;;

(import* attr)

(defn record?
  "Return true if v is a record type."
  [v]
  (instance? basilisp.lang.interfaces/IRecord v))

(defmulti ^:private evolve
  (fn [v & _]
    (cond
      (record? v) :record
      (map? v)    :map)))

(defmethod evolve :map
  [m & kwargs]
  (apply assoc m kwargs))

(defmethod evolve :record
  [rec & kwargs]
  (->> (apply hash-map kwargs)
       (apply-kw attr/evolve rec)))

(defn ^:private validate-record-fields
  "Validate that record fields do not contain any reserved entries,
  are not declared as mutable, and do not declare any default values."
  [fields field-kws]
  (when (some #(#{:meta :_recmap} %) field-kws)
    (throw
     (ex-info "Reserved fields cannot be used for Record field names"
              {:fields (.intersection #{:meta :_recmap} (set field-kws))})))

  (when (some #(:mutable (meta %)) fields)
    (throw
     (ex-info "Mutable fields not permitted in Record types"
              {:fields (filter #(:mutable (meta %)) fields)})))

  (when (some #(contains? (meta %) :default) fields)
    (throw
     (ex-info "Record fields may not specify defaults"
              {:fields (filter #(contains? (meta %) :default) fields)}))))

(defn ^:private validate-record-methods
  "Validate that record methods are not declared as class methods,
  properties, or static methods."
  [methods]
  (when (->> methods
             (mapcat (fn [method]
                       [(meta method) (meta (first method))]))
             (some #(or (:classmethod %) (:property %) (:staticmethod %))))
    (throw
     (ex-info "Record methods may not be class methods, properties, or static methods"
              {:methods methods}))))

(defmacro defrecord
  "Define a new Basilisp record.

  The new record will have fields matching the names in `fields`. Fields may
  be referred to unqualified in the bodies of implemented methods.

  Interface or protocol implementations are declared as the name of the
  interface or protocol as a symbol, followed by 1 or more method
  definitions for that interface. Types are not required to declare any
  interface implementations. Types which do declare interface implementations
  are required to implement all interface methods. Failing to implement all
  interface methods is a compile time error. Types implementing `object` are
  not required to implement all `object` methods.

  Method declarations should appear as:

    (method-name [arg1] & body)
    (method-name [arg1 arg2 ...] & body)

  Records objects are created with sensible `object` defaults as by `attrs`.
  New records may override `object` defaults. An `__init__` function is
  automatically created which takes positional arguments matching the
  order of definition in `fields`. Additionally, given a name `NewRecord`,
  a factory function will be created `->NewRecord` which can be used to
  generate new instances of the record.

  Methods must supply a `this` or `self` parameter. `recur` special forms
  used in the body of a method should not include that parameter, as it
  will be supplied automatically."
  [type-name fields & method-impls]
  (let [ctor-name     (with-meta
                        (symbol (str "->" (name type-name)))
                        (meta type-name))
        map-ctor      (with-meta
                        (symbol (str "map->" (name type-name)))
                        (meta type-name))

        record-fields (vec (concat fields
                                   ['^{:default nil} meta
                                    '^{:default {}} _recmap]))
        field-kws     (->> fields (map (comp keyword name)))
        field-kw-set  (set field-kws)

        {:keys [interfaces methods]} (collect-methods method-impls)

        interfaces (concat interfaces
                           '[basilisp.lang.interfaces/IPersistentMap
                             basilisp.lang.interfaces/IWithMeta
                             basilisp.lang.interfaces/IRecord
                             python/object])

        ;; We can use these gensyms repeatedly and interpolate them in
        ;; multiple layers of syntax quoting, unlike gensyms using # syntax.
        this-gs  (gensym "this")
        other-gs (gensym "other")
        map-gs   (gensym "m")
        key-gs   (gensym "k")]

    (validate-record-fields fields field-kws)
    (validate-record-methods methods)

    `(do
       (deftype* ~type-name ~record-fields
         :implements [~@interfaces]

         ;; IPersistentMap
         (~'assoc [~this-gs ~'& args#]
          (let [{fields# :fields map# :map} (->> (partition 2 args#)
                                                 (group-by (fn [[k#]]
                                                             (if (contains? ~field-kw-set k#)
                                                               :fields
                                                               :map))))

                new-recmap# (when (seq map#)
                              ;; Python attrs does not allow the underscore prefixed
                              ;; field name in the constructor
                              ["recmap" (->> (mapcat identity map#)
                                             (apply assoc ~'_recmap))])]
            (->> fields#
                 (map (fn [[k# v#]] [(name k#) v#]))
                 (mapcat identity)
                 (concat new-recmap#)
                 (apply evolve ~this-gs))))
         (~'cons [~this-gs ~'& elems#]
          (loop [[f# ~'& r#] elems#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (map? f#)
              (recur r#
                     (->> (seq f#)
                          (mapcat identity)
                          (apply assoc new-rec#)))

              (map-entry? f#)
              (recur r# (assoc new-rec# (key f#) (val f#)))

              (vector? f#)
              (recur r# (apply assoc new-rec# f#))

              (py-dict? f#)
              (recur r#
                     (->> (seq (.items f#))
                          (map (fn [[k v]] (map-entry k v)))
                          (apply conj new-rec#)))

              :else
              (throw
               (ex-info "Argument to record conj must be another Map or castable to MapEntry"
                        {:value f#
                         :type  (python/type f#)})))))
         (~'empty [~this-gs]
          (throw
           (python/TypeError
            ~(str "Cannot create empty " type-name))))
         (~'seq [~this-gs]
          (concat
           [~@(map (fn [field]
                     (map-entry (keyword (name field)) field))
                   fields)]
           (seq ~'_recmap)))
         (~'dissoc [~this-gs ~'& ks#]
          (loop [[f# ~'& r#] ks#
                 new-rec#    ~this-gs]
            (cond
              (nil? f#)
              new-rec#

              (contains? ~field-kw-set f#)
              (recur r#
                     (->> (seq new-rec#)
                          (filter (fn [[k#]]
                                    (not= k# f#)))
                          (mapcat identity)
                          (apply hash-map)))

              (contains? (.- new-rec#  ~'_recmap) f#)
              (recur r#
                     (->> (dissoc (.- new-rec# ~'_recmap) f#)
                          (evolve new-rec# "recmap")))

              :else
              (recur r# new-rec#))))
         (~'contains [~this-gs ~key-gs]
          (or (~field-kw-set ~key-gs)
              (contains? ~'_recmap ~key-gs)))
         (~'entry [~this-gs ~key-gs]
          (cond
            (contains? ~field-kw-set ~key-gs)
            (map-entry ~key-gs (python/getattr ~this-gs (munge ~key-gs)))

            (contains? ~'_recmap ~key-gs)
            (map-entry ~key-gs (get ~'_recmap ~key-gs))))
         (~'val-at [~this-gs ~key-gs ~'& args#]
          (let [[default#] args#]
            (cond
              (contains? ~field-kw-set ~key-gs)
              (python/getattr ~this-gs (munge ~key-gs))

              (contains? ~'_recmap ~key-gs)
              (get ~'_recmap ~key-gs default#))))
         (~'__getitem__ [~this-gs ~key-gs]
          (. ~this-gs ~'entry ~key-gs))
         (~'__iter__ [~this-gs]
          (seq ~this-gs))
         (~'__len__ [~this-gs]
          (+ ~(count field-kw-set)
             (count ~'_recmap)))

         ;; IWithMeta
         (~'with-meta [~this-gs new-meta#]
          (evolve ~this-gs "meta" new-meta#))

         ;; IRecord
         (~' ^:classmethod create [cls# ~map-gs]
          (cls#
           ~@(map (fn [field-kw]
                    `(get ~map-gs ~field-kw))
                  field-kws)
           nil
           (dissoc ~map-gs ~@field-kws)))
         (~'_record_lrepr [~this-gs py-kwargs#]
          (let [{print-meta :print_meta} (py->lisp py-kwargs#)

                ns-name   (name *ns*)
                qual-name (.- ~type-name ~'__qualname__)]
            (cond->> (->> (mapcat identity ~this-gs)
                          (apply hash-map)
                          (repr)
                          (str "#" ns-name "." qual-name))
              print-meta (str "^" (repr (meta ~this-gs)) " "))))

         ;; object
         (~'__eq__ [~this-gs ~other-gs]
          (or (identical? ~this-gs ~other-gs)
              (and (instance? (python/type ~this-gs) ~other-gs)
                   (= [~@fields
                       ~'_recmap]
                      [~@(map (fn [field]
                                `(.- ~other-gs ~field))
                              fields)
                       (.- ~other-gs ~'_recmap)]))))
         (~'__hash__ [~this-gs]
          (hash [~@fields ~'_recmap]))

         ~@methods)

       (defn ~ctor-name
         ~(str
           "Create a new instance of the record " type-name ".")
         ~fields
         (~type-name ~@fields nil {}))

       (defn ~map-ctor
         ~(str
           "Create a new instance of the record " type-name " from a "
           "map whose keys correspond to the fields of " type-name ".")
         [m#]
         ((.- ~type-name ~'create) m#))

       ~type-name)))

;;;;;;;;;;;;;;;
;; Volatiles ;;
;;;;;;;;;;;;;;;

(defprotocol IVolatile
  "Protocol for a volatile reference container. Volatile references do not provide
  atomic semantics, but they may be useful as a mutable reference container in a
  single-threaded context."

  (vreset! [this new-val]
    "Reset the value of a volatile non-atomically. Returns the new value.")
  (vswap! [this f & args]
    "Swap the value of a volatile non-atomically to the return of
     (apply f old-val args). Returns the new value of that function
     call."))

(deftype Volatile [^:mutable val]
  basilisp.lang.interfaces/IDeref
  (deref [this] val)

  IVolatile
  (vreset! [this new-val]
    (set! val new-val))
  (vswap! [this f & args]
    (let [new-val (apply f val args)]
      (set! val new-val))))

(defn volatile!
  "Return a Volatile reference container with the initial value v."
  [v]
  (Volatile v))

(defn volatile?
  "Return true if implements IVolatile."
  [x]
  (satisfies? IVolatile x))
