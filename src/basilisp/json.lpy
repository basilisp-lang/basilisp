(ns basilisp.json
  (:refer-basilisp :exclude [read])
  (:import
   datetime
   decimal
   fractions
   json
   uuid))

;;;;;;;;;;;;;;
;; Encoders ;;
;;;;;;;;;;;;;;

(defprotocol JSONEncodeable
  (to-json-encodeable* [this opts]
    "Return an object which can be JSON encoded by Python's default JSONEncoder.

     `opts` is a map of options:

       `:key-fn`   - is a function which will be called for each key in a map.
       `:value-fn` - is a function of two arguments called for each value in a
                     map; the first argument is the key before being transformed
                     by `:key-fn` and the second is the value from the object"))

(extend-protocol JSONEncodeable
  python/object
  (to-json-encodeable* [this _]
    (throw
     (python/TypeError
      (str "Cannot JSON encode objects of type " (python/type this))))))

(defn ^:private encodeable-scalar
  [o _]
  o)

(defn ^:private stringify-scalar
  [o _]
  (python/str o))

(defn ^:private kw-or-sym-to-encodeable
  [o _]
  (if-let [ns-str (namespace o)]
    (str ns-str "/" (name o))
    (name o)))

(defn ^:private map-key-to-encodeable
  [k]
  (if (keyword? k)
    (name k)
    (str k)))

(defn ^:private map-to-encodeable
  [o {:keys [key-fn value-fn] :as opts}]
  (let [encode-value (or value-fn
                         (fn [_ v]
                           (to-json-encodeable* v opts)))]
    (->> o
         (map (fn [[k v]]
                [(key-fn k) (encode-value k v)]))
         (python/dict))))

(defn ^:private seq-to-encodeable
  [o opts]
  (->> o
       (map #(to-json-encodeable* % opts))
       (python/list)))

(extend python/str   JSONEncodeable {:to-json-encodeable* encodeable-scalar})
(extend python/int   JSONEncodeable {:to-json-encodeable* encodeable-scalar})
(extend python/float JSONEncodeable {:to-json-encodeable* encodeable-scalar})
(extend python/bool  JSONEncodeable {:to-json-encodeable* encodeable-scalar})
(extend nil          JSONEncodeable {:to-json-encodeable* encodeable-scalar})

(extend basilisp.lang.keyword/Keyword JSONEncodeable {:to-json-encodeable* kw-or-sym-to-encodeable})
(extend basilisp.lang.symbol/Symbol   JSONEncodeable {:to-json-encodeable* kw-or-sym-to-encodeable})

(extend basilisp.lang.interfaces/IPersistentMap JSONEncodeable {:to-json-encodeable* map-to-encodeable})

(extend basilisp.lang.interfaces/IPersistentList   JSONEncodeable {:to-json-encodeable* seq-to-encodeable})
(extend basilisp.lang.interfaces/IPersistentSet    JSONEncodeable {:to-json-encodeable* seq-to-encodeable})
(extend basilisp.lang.interfaces/IPersistentVector JSONEncodeable {:to-json-encodeable* seq-to-encodeable})

;; Support extended reader types.
(extend datetime/datetime  JSONEncodeable {:to-json-encodeable* (fn [o _] (.isoformat o))})
(extend decimal/Decimal    JSONEncodeable {:to-json-encodeable* stringify-scalar})
(extend fractions/Fraction JSONEncodeable {:to-json-encodeable* stringify-scalar})
(extend uuid/UUID          JSONEncodeable {:to-json-encodeable* stringify-scalar})

;; Support Python types in case they are embedded in other Basilisp collections.
(extend python/dict      JSONEncodeable {:to-json-encodeable* (fn [d opts] (map-to-encodeable (.items d) opts))})
(extend python/list      JSONEncodeable {:to-json-encodeable* seq-to-encodeable})
(extend python/tuple     JSONEncodeable {:to-json-encodeable* seq-to-encodeable})
(extend python/set       JSONEncodeable {:to-json-encodeable* seq-to-encodeable})
(extend python/frozenset JSONEncodeable {:to-json-encodeable* seq-to-encodeable})

(defn ^:private write-opts
  [{:keys [key-fn value-fn]}]
  {:key-fn   (or key-fn map-key-to-encodeable)
   :value-fn value-fn})

(defn write
  "Serialize the object `o` as JSON to the writer object `writer` (which must be
  any file-like object supporting `.write()` method).

  Several options may be specified as key/value pairs as `opts`:

   :key-fn   -
   :value-fn - "
  [o writer & {:as opts}]
  (let [opts (write-opts opts)]
    (json/dump o writer ** :default #(to-json-encodeable* % opts))))

(defn write-str
  "Serialize the object `o` as JSON and return the serialized object as a string.

  The options for `write-str` are the same as for those of `write`."
  [o & {:as opts}]
  (let [opts (write-opts opts)]
    (json/dumps o ** :default #(to-json-encodeable* % opts))))

;;;;;;;;;;;;;;
;; Decoders ;;
;;;;;;;;;;;;;;

(defprotocol JSONDecodeable
  (from-decoded-json* [this opts]
    "Return a Basilisp object in place of a Python object returned by Python's
     default JSONDecoder.

     `opts` is a map of options:

       `:key-fn`   - is a function which will be called for each key in a map;
                     default is `identity`"))

(extend-protocol JSONDecodeable
  python/dict
  (from-decoded-json* [this {:keys [key-fn value-fn] :as opts}]
    (->> (.items this)
         (mapcat (fn [[k v]] [(key-fn k) v]))
         (apply hash-map)))

  python/list
  (from-decoded-json* [this opts]
    (->> this (map #(from-decoded-json* % opts)) (vec))))

(defn ^:private decode-scalar
  [o _]
  o)

(extend python/int   JSONDecodeable {:from-decoded-json* decode-scalar})
(extend python/float JSONDecodeable {:from-decoded-json* decode-scalar})
(extend python/str   JSONDecodeable {:from-decoded-json* decode-scalar})
(extend python/bool  JSONDecodeable {:from-decoded-json* decode-scalar})
(extend nil          JSONDecodeable {:from-decoded-json* decode-scalar})

(defn ^:private read-opts
  [{:keys [key-fn value-fn strict?]}]
  {:key-fn   (or key-fn identity)
   :strict   (if (boolean? strict?) strict? true)})

;; Python's builtin `json.load` currently only includes an Object hook; it has
;; no hook for Array types. Due to this limitation, we have to iteratively
;; transform the entire parsed object into Basilisp data structures rather than
;; building the final object iteratively. There is an open bug report with
;; Python, but it has gotten no traction: https://bugs.python.org/issue36738

(defn read
  "Decode the JSON-encoded stream from `reader` (which can be any Python file-like
  object) into Basilisp data structures.

  JSON Objects will be decoded as Basilisp maps. JSON Arrays will be decoded as
  as Basilisp vectors. All other JSON data types will be decoded as the
  corresponding Python types (strings, booleans, integers, floats, and `nil`).

  The decoder supports a few options which may be specified as key/value pairs:

   `:key-fn`   - is a function which will be called for each key in a map;
                 default is `identity`
   `:strict?`  - boolean value; if `true`, control characters (characters in
                 ASCII 0-31 range) will be prohibited inside JSON strings;
                 default is `true`"
  [reader & {:as opts}]
  (let [{:keys [strict?] :as opts} (read-opts opts)]
    (-> (json/load reader ** :strict strict?)
        (from-decoded-json* opts))))

(defn read-str
  "Decode the JSON-encoded string `s` into Basilisp data structures.

  JSON Objects will be decoded as Basilisp maps. JSON Arrays will be decoded as
  as Basilisp vectors. All other JSON data types will be decoded as the
  corresponding Python types (strings, booleans, integers, floats, and `nil`).

  The decoder supports a few options which may be specified as key/value pairs:

   `:key-fn`   - is a function which will be called for each key in a map;
                 default is `identity`
   `:strict?`  - boolean value; if `true`, control characters (characters in
                 ASCII 0-31 range) will be prohibited inside JSON strings;
                 default is `true`"
  [s & {:as opts}]
  (let [{:keys [strict?] :as opts} (read-opts opts)]
    (-> (json/loads s ** :strict strict?)
        (from-decoded-json* opts))))
