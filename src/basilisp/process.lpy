(ns basilisp.process
  (:import os
           pathlib
           subprocess))

(defn start
  "Start an external command as ``args``.

  If ``opts`` are specified, they should be provided as a map in the first argument
  position.

  The following options are available:

   :keyword ``:in``: an existing file object or file handle, ``:pipe`` to generate a
       new stream, or ``:inherit`` to use the current process stdin; if not specified
       ``:pipe`` will be used
   :keyword ``:out``: an existing file object or file handle, ``:pipe`` to generate a
       new stream, ``:discard`` to ignore stdout, or ``:inherit`` to use the current
       process stdout; if not specified, ``:pipe`` will be used
   :keyword ``:err``: an existing file object or file handle, ``:pipe`` to generate a
       new stream, ``:discard`` to ignore stderr, ``:stdout`` to merge stdout and
       stderr, or ``:inherit`` to use the current process stderr; if not specified,
       ``:pipe`` will be used
   :keyword ``:dir``: current directory when the process runs; on POSIX systems, if
       executable is a relative path, it will be resolved relative to this value;
       if not specified, the current directory will be used
   :keyword ``:clear-env``: boolean which if ``true`` will prevent inheriting the
       environment variables from the current process
   :keyword ``:env``: a mapping of string values to string values which are added to
       the subprocess environment; if ``:clear-env``, these are the only environment
       variables provided to the subprocess
   :keyword ``:encoding``: the string name of an encoding to use for input and output
       streams; if not specified, streams are treated as bytes

  Returns :external:py:class:`subprocess.Popen` instance."
  [& opts+args]
  (let [[opts command] (if (map? (first opts+args))
                         [(first opts+args) (rest opts+args)]
                         [nil opts+args])

        {:keys [in out err dir encoding]
         :or   {in :pipe out :pipe err :pipe dir "."}} opts

        stdin  (condp = in
                 :pipe    subprocess/PIPE
                 :inherit nil
                 in)
        stdout (condp = out
                 :pipe    subprocess/PIPE
                 :inherit nil
                 :discard subprocess/DEVNULL
                 out)
        stderr (condp = err
                 :pipe    subprocess/PIPE
                 :discard subprocess/DEVNULL
                 :stdout  subprocess/STDOUT
                 :inherit nil
                 err)
        env    (if (:clear-env opts)
                 (:env opts)
                 (into (py->lisp os/environ) (:env opts)))]
    (subprocess/Popen (python/list command)
                      **
                      :encoding encoding
                      :stdin    stdin
                      :stdout   stdout
                      :stderr   stderr
                      :cwd      (-> (pathlib/Path dir) (.resolve))
                      :env      (lisp->py env))))

(defn exec
  "Execute a command as by :lpy:fn:`start` and, upon successful return, return the
  captured value of the process ``stdout`` (which may be a string or bytes depending
  on whether the process was opened in text or binary mode).

  If ``opts`` are specified, they should be provided as a map in the first argument
  position. ``opts`` are exactly the same as those in :lpy:fn:`start`.

  If the return code is non-zero, throw
  :external:py:exc:`subprocess.CalledProcessError`."
  [& opts+args]
  (let [process (apply start opts+args)
        retcode (.wait process)]
    (if (zero? retcode)
      (slurp (.-stdout process))
      (throw
       (subprocess/CalledProcessError retcode
                                      (.-args process)
                                      (.-stdout process)
                                      (.-stderr process))))))

(defn stderr
  "Return the ``stderr`` stream from the external process.

  .. warning::

     Communication directly with the process streams introduces the possibility of
     deadlocks. Users may use :lpy:fn:`communicate` as a safe alternative."
  [process]
  (.-stderr process))

(defn stdin
  "Return the ``stdin`` stream from the external process.

  .. warning::

     Communication directly with the process streams introduces the possibility of
     deadlocks. Users may use :lpy:fn:`communicate` as a safe alternative."
  [process]
  (.-stdin process))

(defn stdout
  "Return the ``stdout`` stream from the external process.

  .. warning::

     Communication directly with the process streams introduces the possibility of
     deadlocks. Users may use :lpy:fn:`communicate` as a safe alternative."
  [process]
  (.-stdout process))

(defn communicate
  "Communicate with a subprocess, optionally sending data to the process stdin stream
  and reading any data in the process stderr and stdout streams, returning them as
  a string or bytes object (depending on whether the process was opened in text or
  binary mode).

  This function is preferred over the use of :lpy:fn:`stderr`, :lpy:fn:`stdin`, and
  :lpy:fn:`stdout` to avoid potential deadlocks.

  The following keyword/value arguments are optional:

   :keyword ``:input``: a string or bytes object (depending on whether the process
       was opened in text or bniary mode); if omitted, do not send anything
   :keyword ``timeout``: an optional timeout"
  [process & kwargs]
  (let [kwargs (apply hash-map kwargs)]
    (vec
     (.communicate process ** :input (:input kwargs) :timeout (:timeout kwargs)))))
