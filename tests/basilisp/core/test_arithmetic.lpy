(ns tests.basilisp.core.test-arithmetic
  (:import decimal
           fractions
           math)
  (:require
   [basilisp.test :refer [deftest is are testing]]))

(deftest plus-test
  (are [expected tp args] (= [expected tp] (let [v (apply + args)]
                                             [v (type v)]))
    0  python/int []
    1  python/int [1]
    -1 python/int [-1]

    0.0 python/float [-1.0 1]
    0.0 python/float [-1 1.0]

    ;; adding floats and decimals yields a float
    0.0 python/float [-1.0 1.0M]
    0.0 python/float [-1.0M 1.0]

    0.0M decimal/Decimal [-1.0M 1.0M]
    0.0M decimal/Decimal [-1 1.0M]
    0.0M decimal/Decimal [-1.0M 1]
    0.0M decimal/Decimal [-2/2 1.0M]
    0.0M decimal/Decimal [-1.0M 2/2]

    1    python/int         [1/3 2/3]
    4/3  fractions/Fraction [1/3 1]
    4/3  fractions/Fraction [1 1/3]
    -1/3 fractions/Fraction [1/3 -2/3])

  (are [expected args] (let [v (apply + args)]
                         (and (math/isclose expected v)
                              (float? v)))
    1.3333333333333333 [1/3 1.0]
    1.3333333333333333 [1.0 1/3]))

(deftest minus-test
  (are [expected tp args] (= [expected tp] (let [v (apply - args)]
                                             [v (type v)]))
    -1    python/int         [1]
    1     python/int         [-1]
    -1.0  python/float       [1.0]
    1.0   python/float       [-1.0]
    -1.0M decimal/Decimal    [1.0M]
    1.0M  decimal/Decimal    [-1.0M]
    -2/3  fractions/Fraction [2/3]
    2/3   fractions/Fraction [-2/3]

    2.0  python/float [1 -1.0]
    2.0  python/float [1.0 -1]
    -2.0 python/float [-1.0 1]
    -2.0 python/float [-1 1.0]

    ;; subtraction floats and decimals yields a float
    2.0  python/float [1.0 -1.0M]
    2.0  python/float [1.0M -1.0]
    -2.0 python/float [-1.0 1.0M]
    -2.0 python/float [-1.0M 1.0]

    -2.0M decimal/Decimal [-1.0M 1.0M]
    -2.0M decimal/Decimal [-1 1.0M]
    -2.0M decimal/Decimal [-1.0M 1]
    -2.0M decimal/Decimal [-2/2 1.0M]
    -2.0M decimal/Decimal [-1.0M 2/2]

    -1   python/int         [1/3 4/3]
    -1/3 fractions/Fraction [1/3 2/3]
    -2/3 fractions/Fraction [1/3 1]
    2/3  fractions/Fraction [1 1/3]
    1    python/int         [1/3 -2/3])

  (are [expected args] (let [v (apply - args)]
                         (and (math/isclose expected v)
                              (float? v)))
    -0.6666666666666667 [1/3 1.0]
    0.6666666666666667  [1.0 1/3]))
