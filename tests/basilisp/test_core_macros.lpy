(ns tests.basilisp.test-core-macros
  (:import inspect os tempfile)
  (:require
   [basilisp.test :refer [deftest is testing]]))

(deftest defn-test
  (testing "single arity defn"
    (testing "simple"
      (let [fvar  (defn f1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'f1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn f2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'f2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn f3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'f3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn f4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'f4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defn"
    (testing "simple"
      (let [fvar  (defn f5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'f5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn f6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn f7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn f8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta)))))))

(deftest defasync-test
  (testing "single arity defasync"
    (testing "simple"
      (let [fvar  (defasync af1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'af1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af1))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defasync af2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'af2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af2))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defasync af3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'af3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af3))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defasync af4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'af4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af4))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defasync"
    (testing "simple"
      (let [fvar  (defasync af5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'af5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af5))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defasync af6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af6))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defasync af7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af7))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defasync af8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af8))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta)))))))

(deftest defn-private-test
  (testing "single arity defn-"
    (testing "simple"
      (let [fvar  (defn- pf1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn- pf2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn- pf3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn- pf4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'pf4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defn"
    (testing "simple"
      (let [fvar  (defn- pf5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn- pf6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn- pf7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn- pf8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta)))))))

(deftest defonce-test
  (testing "defonce will not rebind bound Var"
    (defonce defonce-value :defonce-value-1)
    (is (= :defonce-value-1 defonce-value))
    (defonce defonce-value :defonce-value-2)
    (is (= :defonce-value-1 defonce-value)))

  (testing "defonce can bind an unbound Var"
    (def defonce-unbound)
    (is (not (.-is-bound (var defonce-unbound))))
    (defonce defonce-unbound :defonce-bound-now)
    (is (= :defonce-bound-now defonce-unbound)))

  (testing "defonce will not rebind bound Var by regular def"
    (def defonce-bound :defonce-bound-first)
    (is (= :defonce-bound-first defonce-bound))
    (defonce defonce-bound :defounce-rebinding)
    (is (= :defonce-bound-first defonce-bound))))

(deftest fn-meta-test
  (testing "fn has no meta to start"
    (is (nil? (meta (fn* []))))
    (is (nil? (meta (fn []))))
    (is (nil? (meta (fn* ([]) ([a] a)))))
    (is (nil? (meta (fn ([]) ([a] a))))))

  (testing "single arity fn retains meta after macro"
    (is (= {:meta-kw true} (meta ^:meta-kw (fn* []))))
    (is (= {:meta-kw true} (meta ^:meta-kw (fn []))))
    (is (= {:meta-kw true :other-kw true}
           (meta ^:meta-kw ^:other-kw (fn [])))))

  (testing "multi arity fn retains meta after macro"
    (is (= {:meta-kw true}
           (meta ^:meta-kw (fn* ([]) ([a] a)))))
    (is (= {:meta-kw true}
           (meta ^:meta-kw (fn ([]) ([a] a)))))
    (is (= {:meta-kw true :other-kw true}
           (meta ^:meta-kw ^:other-kw (fn ([]) ([a] a)))))))

(deftest amap-test
  (let [l #py []]
    (is (= #py [] (amap l idx ret (+ idx (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= #py [1 3 5] (amap l idx ret (+ idx (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= #py [6 11 20] (amap l idx ret (apply + ret))))))

(deftest areduce-test
  (let [l #py []]
    (is (= 0 (areduce l idx ret 0 (+ ret (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= 6 (areduce l idx ret 0 (+ ret (aget l idx)))))))

(deftest case-test
  (is (= "yes" (case :a :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "nope" (case :b :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "mega nope" (case :c :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "nerp" (case "da" :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "duh" (case "yes" :a "no" b "also no" "duh")))
  (is (= "also no" (case 'b :a "no" b "also no" "duh")))
  (is (= "also no" (case 'b :a "no" (b c d) "also no" "duh")))
  (is (= "also no" (case 'c :a "no" (b c d) "also no" "duh")))
  (is (= "also no" (case 'd :a "no" (b c d) "also no" "duh")))
  (is (= "duh" (case 'e :a "no" (b c d) "also no" "duh")))
  (is (thrown? python/ValueError
               (case "da" :b "nope" :c "mega nope" :a "yes"))))

(deftest condp-test
  (testing "condp result value"
    (is (= :a (condp = "a" :a)))
    (is (= :a (condp = "a"
                "b" :b
                :a)))
    (is (= :a (condp = "a"
                "b" :b
                "c" :c
                :a))))

  (testing "condp result function"
    (is (= :a (condp some [1 8 10 12]
                #{2 4 6} :>> inc
                :a)))
    (is (= 0 (condp some [1 8 10 12]
               #{2 4 6} :>> inc
               #{1 3 5} :>> dec
               :a)))))

(deftest lazy-cat-test
  (is (= '(1 2 3 4 5 6) (lazy-cat [1 2 3] [4 5 6])))

  (testing "laziness"
    (let [a (atom nil)]
      (is (= '(1 2 3 4 5)
             (take 5
                   (lazy-cat [1 2 3 4 5 6]
                             (map #(reset! a %) [7 8 9 0])))))
      (is (nil? @a))
      (is (= [1 2 3 4 5 6 7 8 9 0]
             (lazy-cat [1 2 3 4 5]
                       (map #(reset! a %) [6 7 8 9 0]))))
      (is (zero? @a)))))

(deftest for-test
  (testing "no recursion error"
    (is (= 10000 (count (for [x (range 100), y (range 100)] [x y])))))

  (testing "basic for comprehensions"
    (is (= [1 2 3 4] (for [x [1 2 3 4]] x)))

    (testing "for comprehension with :let modifier"
      (is (= [[0 1] [1 2] [2 3] [3 4] [4 5]]
             (for [x    (range 5)
                   :let [y (inc x)]]
               [x y]))))

    (testing "for comprehension with :when modifier"
      (is (= [1 3 5]
             (for [x     (range 6)
                   :when (odd? x)]
               x))))

    (testing "for comprehension with :while modifier"
      (is (= [1 3 5]
             (for [x      [1 3 5 6 8 10]
                   :while (odd? x)]
               x)))))

  (testing "nested for comprehension"
    (is (= [[0 :a] [0 :b] [0 :c]
            [1 :a] [1 :b] [1 :c]
            [2 :a] [2 :b] [2 :c]]
           (for [x (range 3)
                 y [:a :b :c]]
             [x y])))

    (testing "for comprehension with :let modifier"
      (is (= [[0 :a 0] [0 :b 0] [0 :c 0]
              [1 :a 2] [1 :b 2] [1 :c 2]
              [2 :a 4] [2 :b 4] [2 :c 4]]
             (for [x    (range 3)
                   :let [z (* 2 x)]
                   y    [:a :b :c]]
               [x y z]))))

    (testing "for comprehension with :when modifier"
      (is (= [[0 :a] [0 :b] [0 :c]
              [2 :a] [2 :b] [2 :c]]
             (for [x     (range 3)
                   y     [:a :b :c]
                   :when (even? x)]
               [x y])))
      (is (= [[0 :b] [1 :b] [2 :b]]
             (for [x     (range 3)
                   y     [:a :b :c]
                   :when (= y :b)]
               [x y]))))

    (testing "for comprehension with :while modifier"
      (is (= [[0 :a] [0 :b] [0 :c]
              [2 :a] [2 :b] [2 :c]]
             (for [x      (range 3)
                   y      [:a :b :c]
                   :while (even? x)]
               [x y])))
      (is (= []
             (for [x      (range 3)
                   y      [:a :b :c]
                   :while (= y :b)]
               [x y]))))))

(deftest comment-test
  (is (= nil (comment 1)))
  (is (= nil (comment [1 2 3]))))

(deftest double-dot-test
  (is (= "abc" (.. "abc")))
  (is (= "ABC" (.. "abc" (upper))))
  (is (not (.. "abc" (upper) (islower))))
  (is (= #py ["A" "B" "C"] (.. "a,b,c" upper (split ",")))))

(deftest with-test
  (let [[_ filename] (tempfile/mkstemp)]
    (try
      (do
        (with-open [file (python/open filename "w")]
          (.write file "Testing text"))
        (with-open [file (python/open filename)]
          (is (= "Testing text" (.read file)))))
      (finally
        (os/unlink filename)))))

(deftest if-let-test
  (is (= :a (if-let [a :a] a :b)))
  (is (= 2 (if-let [a 1] (inc a) :b)))
  (is (= :b (if-let [a nil] a :b)))
  (is (= :b (if-let [a false] a :b)))
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-let [a nil] a a))))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macro expansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-let [a nil b :something] a :b)))))

(deftest if-some-test
  (is (= :a (if-some [a :a] a :b)))
  (is (= 2 (if-some [a 1] (inc a) :b)))
  (is (= :b (if-some [a nil] a :b)))
  (is (= false (if-some [a false] a :b)))
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-some [a nil] a a))))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-some [a nil b :something] a :b)))))

(deftest when-let-test
  (is (= :a (when-let [a :a] a)))
  (is (= 2 (when-let [a 1] (inc a))))
  (is (nil? (when-let [a nil] a)))
  (is (nil? (when-let [a false] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-let [a nil b :something] a)))))

(deftest when-first-test
  (is (= :a (when-first [a [:a false nil]] a)))
  (is (= 2 (when-first [a [1 false nil]] (inc a))))
  (is (nil? (when-first [a []] a)))
  (is (nil? (when-first [a (map odd? [2 3 5])] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-first [a [:a :b :c]
                                   b (map odd? [1 2 3])]
                        a)))))

(deftest when-some-test
  (is (= :a (when-some [a :a] a)))
  (is (= 2 (when-some [a 1] (inc a))))
  (is (nil? (when-some [a nil] a)))
  (is (= false (when-some [a false] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-some [a nil b :something] a)))))

(deftest dotimes-test
  (let [a (atom [])]
    (is (nil? (dotimes [n 5]
                (swap! a conj n))))
    (is (= [0 1 2 3 4] @a))))

(deftest while-test
  (let [a (atom 0)]
    (is (nil? (while (<= @a 10)
                (swap! a inc))))
    (is (= 11 @a))))

(def non-dynamic-var :b)
(def ^:dynamic *dynamic-var* :a)

(deftest binding-test
  (is (= *dynamic-var* :a))
  (is (= (binding [*dynamic-var* :b]
           *dynamic-var*)
         :b))
  (is (= (binding [*dynamic-var* :b]
           [*dynamic-var*
            (binding [*dynamic-var* :c]
              *dynamic-var*)])
         [:b :c]))
  (is (thrown? basilisp.lang.runtime/RuntimeException
               (push-thread-bindings {#'non-dynamic-var :c}))))

(deftest ->-test
  (is (= :a (-> :a)))
  (is (= 2 (-> 1 inc)))
  (is (= 1 (-> 1 inc dec)))
  (is (= 4 (-> 10 inc (- 7))))
  (is (= "HI" (-> "hi" .upper)))
  (is (= "Hi" (-> "HI" .lower .capitalize))))

(deftest ->>-test
  (is (= :a (->> :a)))
  (is (= 2 (->> 1 inc)))
  (is (= 1 (->> 1 inc dec)))
  (is (= 14 (->> [1 2 3 4]
                 (map inc)
                 (reduce +)))))

(deftest some->-test
  (is (= :a (some-> :a)))
  (is (= 2 (some-> 1 inc)))
  (is (= 1 (some-> 1 inc dec)))
  (is (= 4 (some-> 10 inc (- 7))))

  (is (= nil (some-> {:a 3} :b inc)))
  (is (= 4 (some-> {:a 3} :a inc))))

(deftest some->>-test
  (is (= :a (some->> :a)))
  (is (= 2 (some->> 1 inc)))
  (is (= 1 (some->> 1 inc dec)))
  (is (= -4 (some->> 10 inc (- 7))))

  (is (= nil (some->> {:a 3} :b (- 7))))
  (is (= 5 (some->> {:a 3} :a (- 8)))))

(deftest cond->-test
  (is (= 1 (cond-> 1)))
  (is (= 1 (cond-> 1 false inc)))
  (is (= 0 (cond-> 1
             false inc
             true dec)))
  (is (= 4 (cond-> 10
             (= :a :a) inc
             (seq [])  (* 3)
             true      (- 7)))))

(deftest cond->>-test
  (is (= 1 (cond->> 1)))
  (is (= 1 (cond->> 1 false inc)))
  (is (= 0 (cond->> 1
             false inc
             true dec)))
  (is (= 9 (cond->> 10
             (= :a :a) inc
             (seq [])  (* 3)
             true      (- 20)))))

(deftest as->-test
  (is (= 10 (as-> 10 a)))
  (is (= 7 (as-> 18 x (- x 11))))
  (is (= 9 (as-> 8 x
             {:a x :c 0}
             (:a x)
             (inc x)))))

(deftest doto-test
  (is (= #py [] (doto #py [])))
  (is (= #py [1 2 3]
         (doto #py []
           (.append 1)
           (.append 2)
           (.append 3)))))

(deftest with-in-str-test
  (is (= "Hi I'm a string" (with-in-str "\"Hi I'm a string\"" (read)))))

(deftest with-out-str-test
  (is (= "Hello, Chris!"
         (with-out-str
           (printf "Hello, %s!" "Chris"))))
  (is (= "Hello, Chris and Rich!"
         (with-out-str
           (printf "Hello, %s and %s!" "Chris" "Rich"))))
  (is (= "Hello, Chris and Rich!"
         (with-out-str
           (printf "Hello, %(first)s and %(second)s!"
                   {"first" "Chris" "second" "Rich"})))))

(deftest fn-sequential-destructuring
  (testing "destructuring first"
    (let [v [:a :b :c :d]

          f (fn [[f]]
              {:first f})
          g (fn [[f :as all]]
              {:first f :as all})]
      (is (= {:first :a}
             (f v)))
      (is (= {:first :a :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first and rest"
    (let [v [:a :b :c :d]

          f (fn [[f & r]]
              {:first f :rest r})
          g (fn [[f & r :as all]]
              {:first f :rest r :as all})]
      (is (= {:first :a :rest '(:b :c :d)}
             (f v)))
      (is (= {:first :a :rest '(:b :c :d) :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first, second, and rest"
    (let [v [:a :b :c :d]

          f (fn [[f s & r]]
              {:first f :second s :rest r})
          g (fn [[f s & r :as all]]
              {:first f :second s :rest r :as all})]
      (is (= {:first :a :second :b :rest '(:c :d)}
             (f v)))
      (is (= {:first :a :second :b :rest '(:c :d) :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first, second, third, and rest"
    (let [v [:a :b :c :d]

          f (fn [[f s t & r]]
              {:first f :second s :third t :rest r})
          g (fn [[f s t & r :as all]]
              {:first f :second s :third t :rest r :as all})]
      (is (= {:first :a :second :b :third :c :rest '(:d)}
             (f v)))
      (is (= {:first :a :second :b :third :c :rest '(:d) :as [:a :b :c :d]}
             (g v)))))

  (testing "nested destructuring"
    (let [v [[:a :b] [:c :d]]

          f (fn [[[k1 v1] [k2 v2]]]
              [k1 v1 k2 v2])
          g (fn [[[k1 v1 :as f] [k2 v2 :as s] :as orig]]
              {:all    [k1 v1 k2 v2]
               :first  f
               :second s
               :orig   orig})]
      (is (= [:a :b :c :d] (f v)))
      (is (= {:all    [:a :b :c :d]
              :first  [:a :b]
              :second [:c :d]
              :orig   [[:a :b] [:c :d]]}
             (g v))))))

(deftest fn-associative-destructuring
  (testing "destructuring simple keys"
    (let [m {:a "a" :b "b"}

          f (fn [{:keys [a]}]
              [a])
          g (fn [{:keys [a] :as m}]
              [a m])
          h (fn [{:keys [a b] :as m}]
              [a b m])]
      (is (= ["a"] (f m)))
      (is (= ["a" m] (g m)))
      (is (= ["a" "b" m] (h m))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}

          f (fn [{:keys [a c] :as m :or {c "c"}}]
              [a c m])]
      (is (= ["a" "c" m] (f m)))
      (is (= ["a" "d" m1] (f m1)))))

  (testing "destructuring simple string keys"
    (let [m {:a 1 :b "b" "a" :a "b" :b}

          f (fn [{:strs [a]}]
              [a])
          g (fn [{:strs [a] :as m}]
              [a m])
          h (fn [{:strs [a b] :as m}]
              [a b m])]
      (is (= [:a] (f m)))
      (is (= [:a m] (g m)))
      (is (= [:a :b m] (h m))))

    (let [m  {"a" :a}
          m1 {"a" :a "c" :d}

          f (fn [{:strs [a c] :as m :or {c :c}}]
              [a c m])]
      (is (= [:a :c m] (f m)))
      (is (= [:a :d m1] (f m1)))))

  (testing "destructuring simple symbol keys"
    (let [m {:a 1 :b "b" 'a :a 'b :b}

          f (fn [{:syms [a]}]
              [a])
          g (fn [{:syms [a] :as m}]
              [a m])
          h (fn [{:syms [a b] :as m}]
              [a b m])]
      (is (= [:a] (f m)))
      (is (= [:a m] (g m)))
      (is (= [:a :b m] (h m))))

    (let [m  {'a :a}
          m1 {'a :a 'c :d}

          f (fn [{:syms [a c] :as m :or {c :c}}]
              [a c m])]
      (is (= [:a :c m] (f m)))
      (is (= [:a :d m1] (f m1)))))

  (testing "destructuring namespaced keys"
    (let [m {:a   "a"
             :b   "b"
             :a/a "aa"
             :a/b "bb"
             :c/c "cc"
             :c/d "dd"}

          f (fn [{:a/keys [a b] old-a :a old-b :b}]
              [old-a old-b a b])
          g (fn [{:keys [a b] :c/keys [c d]}]
              [a b c d])]
      (is (= ["a" "b" "aa" "bb"] (f m)))
      (is (= ["a" "b" "cc" "dd"] (g m))))

    (let [m  {:a "a"}
          m1 {:a/a "aa" :a "a"}

          f (fn [{:a/keys [a] :as m :or {a :c}}]
              [a m])]
      (is (= [:c m] (f m)))
      (is (= ["aa" m1] (f m1)))))

  (testing "destructuring individual keys"
    (let [m {:a "a" :b "b"}

          f (fn [{a :a}]
              [a])
          g (fn [{a :a :as m}]
              [a m])
          h (fn [{a :a b :b :as m}]
              [a b m])]
      (is (= ["a"] (f m)))
      (is (= ["a" m] (g m)))
      (is (= ["a" "b" m] (h m))))

    (let [f (fn [{a :a/a}]
              [a])]
      (is (= ["aa"] (f {:a/a "aa" :a "a"}))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}

          f (fn [{a :a c :c :as m :or {c :c}}]
              [a c m])]
      (is (= ["a" :c m] (f m)))
      (is (= ["a" "d" m1] (f m1)))))

  (testing "keyword rest arguments"
    (let [f (fn [a b & {:keys [c]}] [a b c])]
      (is (= [:a :b "rest arg"] (f :a :b :c "rest arg")))
      (is (= [:a :b "rest arg"] (f :a :b :d "other" :c "rest arg"))))))

(deftest let-sequential-destructuring
  (testing "destructuring first"
    (let [[f] [:a :b :c :d]]
      (is (= :a f)))

    (let [[f :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= [:a :b :c :d] v)))

    (let [[f] '()]
      (is (= nil f)))

    (let [[f :as v] '()]
      (is (= nil f))
      (is (= '() v))))

  (testing "destructuring first and rest"
    (let [[f & r] [:a :b :c :d]]
      (is (= '(:b :c :d) r))
      (is (= :a f)))

    (let [[f & r :as all] [:a :b :c :d]]
      (is (= '(:b :c :d) r))
      (is (= :a f))
      (is (= [:a :b :c :d] all)))

    (let [[f & r] '()]
      (is (= nil f))
      (is (= nil r)))

    (let [[f & r :as v] '()]
      (is (= nil f))
      (is (= nil r))
      (is (= '() v))))

  (testing "destructuring first, second, and rest"
    (let [[f s & r] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= '(:c :d) r)))

    (let [[f s & r :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= '(:c :d) r))
      (is (= [:a :b :c :d] v)))

    (let [[f s & r] '()]
      (is (= nil f))
      (is (= nil s))
      (is (= nil r)))

    (let [[f s & r :as v] '()]
      (is (= nil f))
      (is (= nil s))
      (is (= nil r))
      (is (= '() v))))

  (testing "destructuring first, second, third, and rest"
    (let [[f s t & r] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= :c t))
      (is (= '(:d) r)))

    (let [[f s t & r :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= :c t))
      (is (= '(:d) r))
      (is (= [:a :b :c :d] v)))

    (let [[f s t & r] [:a]]
      (is (= :a f))
      (is (= nil s))
      (is (= nil t))
      (is (= nil r)))

    (let [[f s t & r :as v] [:a]]
      (is (= :a f))
      (is (= nil s))
      (is (= nil t))
      (is (= nil r))
      (is (= [:a] v))))

  (testing "nested destructuring"
    (let [[[k1 v1] [k2 v2]] [[:a :b] [:c :d]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= :c k2))
      (is (= :d v2)))

    (let [[[k1 v1 :as f] [k2 v2 :as s] :as all] [[:a :b] [:c :d]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= [:a :b] f))
      (is (= :c k2))
      (is (= :d v2))
      (is (= [:c :d] s))
      (is (= [[:a :b] [:c :d]] all)))

    (let [[[k1 v1] [k2 v2]] [[:a :b] [:c]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= :c k2))
      (is (= nil v2)))

    (let [[[k1 v1 :as f] [k2 v2 :as s] :as all] [[:a :b] [:c]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= [:a :b] f))
      (is (= :c k2))
      (is (= nil v2))
      (is (= [:c] s))
      (is (= [[:a :b] [:c]] all)))))

(deftest let-associative-destructuring
  (testing "destructuring simple keys"
    (let [{:keys [a b]} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b)))

    (let [{:keys [a b] :as m} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= {:a "a" :b "b"} m)))

    (let [{:keys [a b] :as m :or {b "c"}} {:a "a"}]
      (is (= "a" a))
      (is (= "c" b))
      (is (= {:a "a"} m))))

  (testing "destructuring simple string keys"
    (let [{:strs [a b]} {:a 1 :b 2 "a" :a "b" :b}]
      (is (= :a a))
      (is (= :b b)))

    (let [{:strs [a b] :as m} {:a 1 :b 2 "a" :a "b" :b}]
      (is (= :a a))
      (is (= :b b))
      (is (= {:a 1 :b 2 "a" :a "b" :b} m)))

    (let [{:strs [a b] :as m :or {b "c"}} {:a 1 :b 2 "a" :a}]
      (is (= :a a))
      (is (= "c" b))
      (is (= {:a 1 :b 2 "a" :a} m))))

  (testing "destructuring simple symbol keys"
    (let [{:syms [a b]} {:a 1 :b "b" 'a :a 'b :b}]
      (is (= :a a))
      (is (= :b b)))

    (let [{:syms [a b] :as m} {:a 1 :b "b" 'a :a 'b :b}]
      (is (= :a a))
      (is (= :b b))
      (is (= {:a 1 :b "b" 'a :a 'b :b} m)))

    (let [{:syms [a b] :as m :or {b "c"}} {:a 1 :b "b" 'a :a}]
      (is (= :a a))
      (is (= "c" b))
      (is (= {:a 1 :b "b" 'a :a} m))))

  (testing "destructuring individual keys"
    (let [{a :a b :b} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b)))

    (let [{a :a b :b :as m} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= {:a "a" :b "b"} m)))

    (let [{a :a b :b :as m :or {b "c"}} {:a "a"}]
      (is (= "a" a))
      (is (= "c" b))
      (is (= {:a "a"} m)))

    (let [{a :a/a} {:a/a "aa" :a "a"}]
      (is (= "aa" a))))

  (testing "destructuring namespaced keys"
    (let [{:a/keys [a b] old-a :a old-b :b} {:a   "a"
                                             :b   "b"
                                             :a/a "aa"
                                             :a/b "bb"
                                             :c/c "cc"
                                             :c/d "dd"}]
      (is (= "aa" a))
      (is (= "bb" b))
      (is (= "a" old-a))
      (is (= "b" old-b)))

    (let [{:keys [a b] :c/keys [c d]} {:a   "a"
                                       :b   "b"
                                       :a/a "aa"
                                       :a/b "bb"
                                       :c/c "cc"
                                       :c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "cc" c))
      (is (= "dd" d)))

    (let [{:keys [a b] :c/keys [c d] :or {c "ee"}}
          {:a "a" :b "b" :a/a "aa" :a/b "bb" :c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "ee" c))
      (is (= "dd" d))))

  (testing "nested destructuring"
    (let [{{:keys [a b] :as nested} :nested :as m} {:nested {:a "aa" :b "bb"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= "bb" b))
      (is (= {:a "aa" :b "bb"} nested))
      (is (= {:nested {:a "aa" :b "bb"} :a "a" :b "b"} m)))

    (let [{{:keys [a b] :as nested :or {b "ee"}} :nested :as m} {:nested {:a "aa"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= "ee" b))
      (is (= {:a "aa"} nested))
      (is (= {:nested {:a "aa"} :a "a" :b "b"} m)))

    (let [{{:keys [a b] :as nested} :nested :as m :or {b "ee"}} {:nested {:a "aa"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= nil b))
      (is (= {:a "aa"} nested))
      (is (= {:nested {:a "aa"} :a "a" :b "b"} m)))

    (let [{{{:keys [a b] :as nested} :nested :as middle} :middle :as m}
          {:middle {:nested {:a "aaa" :b "bbb"}
                    :a      "aa"
                    :b      "bb"}
           :a      "a"
           :b      "b"}]
      (is (= "aaa" a))
      (is (= "bbb" b))
      (is (= {:a "aaa" :b "bbb"} nested))
      (is (= {:nested {:a "aaa" :b "bbb"} :a "aa" :b "bb"} middle))
      (is (= {:middle {:nested {:a "aaa" :b "bbb"}
                       :a      "aa"
                       :b      "bb"}
              :a      "a"
              :b      "b"}
             m)))))

(deftest letfn-sequential-destructuring
  (testing "destructuring first"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f]]
                {:first f})
              (g [[f :as all]]
                {:first f :as all})]
        (is (= {:first :a}
               (f v)))
        (is (= {:first :a :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f & r]]
                {:first f :rest r})
              (g [[f & r :as all]]
                {:first f :rest r :as all})]
        (is (= {:first :a :rest '(:b :c :d)}
               (f v)))
        (is (= {:first :a :rest '(:b :c :d) :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first, second, and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f s & r]]
                {:first f :second s :rest r})
              (g [[f s & r :as all]]
                {:first f :second s :rest r :as all})]
        (is (= {:first :a :second :b :rest '(:c :d)}
               (f v)))
        (is (= {:first :a :second :b :rest '(:c :d) :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first, second, third, and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f s t & r]]
                {:first f :second s :third t :rest r})
              (g [[f s t & r :as all]]
                {:first f :second s :third t :rest r :as all})]
        (is (= {:first :a :second :b :third :c :rest '(:d)}
               (f v)))
        (is (= {:first :a :second :b :third :c :rest '(:d) :as [:a :b :c :d]}
               (g v))))))

  (testing "nested destructuring"
    (let [v [[:a :b] [:c :d]]]
      (letfn [(f [[[k1 v1] [k2 v2]]]
                [k1 v1 k2 v2])
              (g [[[k1 v1 :as f] [k2 v2 :as s] :as orig]]
                {:all    [k1 v1 k2 v2]
                 :first  f
                 :second s
                 :orig   orig})]
        (is (= [:a :b :c :d] (f v)))
        (is (= {:all    [:a :b :c :d]
                :first  [:a :b]
                :second [:c :d]
                :orig   [[:a :b] [:c :d]]}
               (g v)))))))

(deftest letfn-associative-destructuring
  (testing "destructuring simple keys"
    (let [m {:a "a" :b "b"}]
      (letfn [(f [{:keys [a]}]
                [a])
              (g [{:keys [a] :as m}]
                [a m])
              (h [{:keys [a b] :as m}]
                [a b m])]
        (is (= ["a"] (f m)))
        (is (= ["a" m] (g m)))
        (is (= ["a" "b" m] (h m)))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}]
      (letfn [(f [{:keys [a c] :as m :or {c "c"}}]
                [a c m])]
        (is (= ["a" "c" m] (f m)))
        (is (= ["a" "d" m1] (f m1))))))

  (testing "destructuring simple string keys"
    (let [m {:a 1 :b "b" "a" :a "b" :b}]
      (letfn [(f [{:strs [a]}]
                [a])
              (g [{:strs [a] :as m}]
                [a m])
              (h [{:strs [a b] :as m}]
                [a b m])]
        (is (= [:a] (f m)))
        (is (= [:a m] (g m)))
        (is (= [:a :b m] (h m)))))

    (let [m  {"a" :a}
          m1 {"a" :a "c" :d}]
      (letfn [(f [{:strs [a c] :as m :or {c :c}}]
                [a c m])]
        (is (= [:a :c m] (f m)))
        (is (= [:a :d m1] (f m1))))))

  (testing "destructuring simple symbol keys"
    (let [m {:a 1 :b "b" 'a :a 'b :b}]
      (letfn [(f [{:syms [a]}]
                [a])
              (g [{:syms [a] :as m}]
                [a m])
              (h [{:syms [a b] :as m}]
                [a b m])]
        (is (= [:a] (f m)))
        (is (= [:a m] (g m)))
        (is (= [:a :b m] (h m)))))

    (let [m  {'a :a}
          m1 {'a :a 'c :d}]
      (letfn [(f [{:syms [a c] :as m :or {c :c}}]
                [a c m])]
        (is (= [:a :c m] (f m)))
        (is (= [:a :d m1] (f m1))))))

  (testing "destructuring namespaced keys"
    (let [m {:a   "a"
             :b   "b"
             :a/a "aa"
             :a/b "bb"
             :c/c "cc"
             :c/d "dd"}]
      (letfn [(f [{:a/keys [a b] old-a :a old-b :b}]
                [old-a old-b a b])
              (g [{:keys [a b] :c/keys [c d]}]
                [a b c d])]
        (is (= ["a" "b" "aa" "bb"] (f m)))
        (is (= ["a" "b" "cc" "dd"] (g m)))))

    (let [m  {:a "a"}
          m1 {:a/a "aa" :a "a"}]
      (letfn [(f [{:a/keys [a] :as m :or {a :c}}]
                [a m])]
        (is (= [:c m] (f m)))
        (is (= ["aa" m1] (f m1))))))

  (testing "destructuring individual keys"
    (let [m {:a "a" :b "b"}]
      (letfn [(f [{a :a}]
                [a])
              (g [{a :a :as m}]
                [a m])
              (h [{a :a b :b :as m}]
                [a b m])]
        (is (= ["a"] (f m)))
        (is (= ["a" m] (g m)))
        (is (= ["a" "b" m] (h m)))))

    (letfn [(f [{a :a/a}]
              [a])]
      (is (= ["aa"] (f {:a/a "aa" :a "a"}))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}]
      (letfn [(f [{a :a c :c :as m :or {c :c}}]
                [a c m])]
        (is (= ["a" :c m] (f m)))
        (is (= ["a" "d" m1] (f m1))))))

  (testing "keyword rest arguments"
    (letfn [(f [a b & {:keys [c]}] [a b c])]
      (is (= [:a :b "rest arg"] (f :a :b :c "rest arg")))
      (is (= [:a :b "rest arg"] (f :a :b :d "other" :c "rest arg"))))))

(deftest loop-sequential-destructuring
  (testing "destructuring first"
    (is (= :a (loop [[f] [:a :b :c :d]] f)))

    (is (= nil (loop [[f] '()] f)))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f :as v] [:a :b :c :d]
                  orig-all  v
                  accum     []]
             (if f
               (recur (rest v) orig-all (conj accum f))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil '()]
           (loop [[f :as v] '()]
             [f v]))))

  (testing "destructuring first and rest"
    (is (= "abcd"
           (loop [[f & r] [:a :b :c :d]
                  accum   []]
             (if f
               (recur r (conj accum f))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f & r :as all] [:a :b :c :d]
                  orig-all        all
                  accum           []]
             (if f
               (recur r orig-all (conj accum f))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil]
           (loop [[f & r] '()]
             [f r])))

    (is (= [nil nil '()]
           (loop [[f & r :as v] '()]
             [f r v]))))

  (testing "destructuring first, second, and rest"
    (is (= "abcd"
           (loop [[f s & r] [:a :b :c :d]
                  accum     []]
             (if f
               (recur r (conj accum f s))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f s & r :as all] [:a :b :c :d]
                  orig-all          all
                  accum             []]
             (if f
               (recur r orig-all (conj accum f s))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil nil]
           (loop [[f s & r] '()]
             [f s r])))

    (is (= [nil nil nil '()]
           (loop [[f s & r :as v] '()]
             [f s r v]))))

  (testing "destructuring first, second, third, and rest"
    (is (= "abcdef"
           (loop [[f s t & r] [:a :b :c :d :e :f]
                  accum       []]
             (if f
               (recur r (conj accum f s t))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d :e :f] "abcdef"]
           (loop [[f s t & r :as all] [:a :b :c :d :e :f]
                  orig-all            all
                  accum               []]
             (if f
               (recur r orig-all (conj accum f s t))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil nil nil]
           (loop [[f s t & r] '()]
             [f s t r])))

    (is (= [nil nil nil nil '()]
           (loop [[f s t & r :as v] '()]
             [f s t r v]))))

  (testing "nested destructuring"
    (is (= 10
           (loop [[[v1 v2] & r] [[1 2] [3 4] [5 6]]
                  accum         0]
             (if (>= accum 10)
               accum
               (recur r (+ accum v1 v2))))))

    (is (= [10 [[1 2] [3 4]] [[1 2] [3 4] [5 6]]]
           (loop [[[v1 v2 :as pair] & r :as all] [[1 2] [3 4] [5 6]]
                  orig-all              all
                  pairs                 []
                  accum                 0]
             (if (>= accum 10)
               [accum pairs orig-all]
               (recur r orig-all (conj pairs pair) (+ accum v1 v2))))))))

(deftest loop-associative-destructuring
  (testing "destructuring simple keys"
    (is (= [[{:a "a" :b "b"} {:a "c" :b "d"} {:a "e"}] "abcdee"]
           (loop [items                           [{:a "a" :b "b"} {:a "c" :b "d"} {:a "e"}]
                  {:keys [a b] :as m :or {b "e"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring simple string keys"
    (is (= [[{:a "a" :b "b" "a" "1" "b" "2"}
             {:a "c" :b "d" "a" "3" "b" "4"}
             {"a" "5"}]
            "123455"]
           (loop [items                           [{:a "a" :b "b" "a" "1" "b" "2"}
                                                   {:a "c" :b "d" "a" "3" "b" "4"}
                                                   {"a" "5"}]
                  {:strs [a b] :as m :or {b "5"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring simple symbol keys"
    (is (= [[{:a "a" :b "b" 'a "1" 'b "2"}
             {:a "c" :b "d" 'a "3" 'b "4"}
             {'a "5"}]
            "123455"]
           (loop [items                           [{:a "a" :b "b" 'a "1" 'b "2"}
                                                   {:a "c" :b "d" 'a "3" 'b "4"}
                                                   {'a "5"}]
                  {:syms [a b] :as m :or {b "5"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring individual keys"
    (is (= [[{:a/a "A" :a "a" :b "b"}
             {:a/a "C" :a "c" :b "d"}
             {:a/a "E"}]
            "AbCdEe"]
           (loop [items                           [{:a/a "A" :a "a" :b "b"}
                                                   {:a/a "C" :a "c" :b "d"}
                                                   {:a/a "E"}]
                  {a :a/a b :b :as m :or {b "e"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring namespaced keys"
    (is (= [[{:a/a "A" :a "a" :b "b"}
             {:a/a "C" :a "c" :b "d"}
             {:a "e" :b "e"}]
            "AbCdZe"]
           (loop [items                                [{:a/a "A" :a "a" :b "b"}
                                                        {:a/a "C" :a "c" :b "d"}
                                                        {:a "e" :b "e"}]
                  {:a/keys [a] b :b :as m :or {a "Z"}} (first items)
                  coll                                 []
                  accum                                []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "nested destructuring"
    (is (= [[{:nested {:a "A"} :a "a" :b "b"}
             {:nested {:a "C"} :a "c" :b "d"}
             {:a "e" :b "e"}]
            "AbCdnile"]
           (loop [items [{:nested {:a "A"} :a "a" :b "b"}
                         {:nested {:a "C"} :a "c" :b "d"}
                         {:a "e" :b "e"}]

                  {{:keys [a] :as nested} :nested b :b :as m :or {a "Z"}}
                  (first items)

                  coll  []
                  accum []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)]))))))
