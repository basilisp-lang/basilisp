(ns tests.basilisp.test-core-macros
  (:import asyncio contextlib inspect os socket tempfile)
  (:require
   [basilisp.string :as str]
   [basilisp.test :refer [deftest is are testing]]))

(deftest fn-decorators-test
  (testing "decorators"
    (testing "in form meta"
      (let [add-5% #(fn [] (+ (%) 5))
            f1  ^{:decorators [add-5%]} (fn [] 7)]
        (is (= 12 (f1)))))

    (testing "in fn name meta"
      (let [add-5% #(fn [] (+ (%) 5))
            f2  (fn ^{:decorators [add-5%]} f2 [] 13)]
        (is (= 18 (f2)))))

    (testing "with single arg"
      (let [add-x% (fn [x] #(fn [] (+ (%) x)))
            f3  (fn ^{:decorators [(add-x% 10)]} f3 [] 7)]
        (is (= 17 (f3)))))

    (testing "order"
      (let [add-5% #(fn [] (+ (%) 5))
            mult-x% (fn [x] #(fn [] (* (%) x)))
            fvar  (defn f4 {:decorators [add-5% (mult-x% -1)]} [] 9)]
        (is (= -4 (f4)))))))

(deftest defn-test
  (testing "single arity defn"
    (testing "simple"
      (let [fvar  (defn f1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'f1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn f2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'f2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn f3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'f3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn f4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'f4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defn"
    (testing "simple"
      (let [fvar  (defn f5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'f5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn f6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn f7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn f8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'f8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta))))))

  (testing "meta"
    (let [fvar  (defn ^{:abc 9} f9 [] :kw)
          vmeta (meta fvar)]
      (is (= 'f9 (:name vmeta)))
      (is (= '([]) (:arglists vmeta)))
      (is (= 9 (:abc vmeta)))))

  (testing "attr-map? and meta"
    (let [fvar  (defn ^{:abc 9 :lmn 15} f10 {:abc 10 :xyz 11} [] :kw)
          vmeta (meta fvar)]
      (is (= 'f10 (:name vmeta)))
      (is (= '([]) (:arglists vmeta)))
      (is (= {:abc 10 :lmn 15 :xyz 11} (select-keys vmeta [:abc :lmn :xyz])))))

  (testing "macroexpand with attr-map?"
    (is (macroexpand '(defn fx {:abc 10} [] :kw))))

  (testing "decorators"
    (let [add-5% #(fn [] (+ (%) 5))
          mult-x% (fn [x] #(fn [] (* (%) x)))
          fvar  (defn f12 {:decorators [add-5% (mult-x% -1)]} [] 9)]
      (is (= -4 (f12))))))

(deftest defasync-test
  (testing "single arity defasync"
    (testing "simple"
      (let [fvar  (defasync af1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'af1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af1))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defasync af2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'af2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af2))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defasync af3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'af3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af3))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defasync af4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'af4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af4))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defasync"
    (testing "simple"
      (let [fvar  (defasync af5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'af5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af5))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defasync af6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af6))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defasync af7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af7))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defasync af8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'af8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (:async vmeta))
        (is (inspect/iscoroutinefunction af8))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta)))))

    (testing "async decorators"
      (testing "single"
        (let [add-5% #(fn ^:async _ [] (+ (await (%)) 5))
              fvar   (defasync ^{:decorators [add-5%]} af9 [] 7)]
          (is (= 12 (asyncio/run (af9))))))

      (testing "single with arg"
        (let [add-x% (fn [x] #(fn ^:async _ [] (+ (await (%)) x)))
              fvar   (defasync ^{:decorators [(add-x% 10)]} af10 [] 7)]
          (is (= 17 (asyncio/run (af10))))))

      (testing "order"
        (let [add-5% #(fn ^:async _ [] (+ (await (%)) 5))
              mult-x% (fn [x] #(fn ^:async _ [] (* (await (%)) x)))
              fvar   (defasync af11 {:decorators [add-5% (mult-x% -1)]} [] 9)]
          (is (= -4 (asyncio/run (af11)))))))))

(deftest defn-private-test
  (testing "single arity defn-"
    (testing "simple"
      (let [fvar  (defn- pf1 [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf1 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn- pf2 "a docstring" [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf2 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "a docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn- pf3 {:added "0.1"} [] :kw)
            vmeta (meta fvar)]
        (is (= 'pf3 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn- pf4
                    "another docstring"
                    {:added "0.1"}
                    []
                    :kw)
            vmeta (meta fvar)]
        (is (= 'pf4 (:name vmeta)))
        (is (= '([]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another docstring" (:doc vmeta))))))

  (testing "multi arity defn"
    (testing "simple"
      (let [fvar  (defn- pf5 ([] :kw) ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf5 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "with docstring"
      (let [fvar  (defn- pf6
                    "multi-arity docstring"
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf6 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "multi-arity docstring" (:doc vmeta)))))

    (testing "with attr-map"
      (let [fvar  (defn- pf7
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf7 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (not (contains? vmeta :doc)))))

    (testing "attr-map and docstring"
      (let [fvar  (defn- pf8
                    "another multi-arity docstring"
                    {:added "0.1"}
                    ([] :kw)
                    ([a] a))
            vmeta (meta fvar)]
        (is (= 'pf8 (:name vmeta)))
        (is (= '([] [a]) (:arglists vmeta)))
        (is (= true (:private vmeta)))
        (is (= "0.1" (:added vmeta)))
        (is (= "another multi-arity docstring" (:doc vmeta)))))))

(deftest defonce-test
  (testing "defonce will not rebind bound Var"
    (defonce defonce-value :defonce-value-1)
    (is (= :defonce-value-1 defonce-value))
    (defonce defonce-value :defonce-value-2)
    (is (= :defonce-value-1 defonce-value)))

  (testing "defonce can bind an unbound Var"
    (def defonce-unbound)
    (is (not (.-is-bound (var defonce-unbound))))
    (defonce defonce-unbound :defonce-bound-now)
    (is (= :defonce-bound-now defonce-unbound)))

  (testing "defonce will not rebind bound Var by regular def"
    (def defonce-bound :defonce-bound-first)
    (is (= :defonce-bound-first defonce-bound))
    (defonce defonce-bound :defounce-rebinding)
    (is (= :defonce-bound-first defonce-bound))))

(deftest fn-meta-test
  (testing "fn has no meta to start"
    (is (nil? (meta (fn* []))))
    (is (nil? (meta (fn []))))
    (is (nil? (meta (fn* ([]) ([a] a)))))
    (is (nil? (meta (fn ([]) ([a] a))))))

  (testing "single arity fn retains meta after macro"
    (is (= {:meta-kw true} (meta ^:meta-kw (fn* []))))
    (is (= {:meta-kw true} (meta ^:meta-kw (fn []))))
    (is (= {:meta-kw true :other-kw true}
           (meta ^:meta-kw ^:other-kw (fn [])))))

  (testing "multi arity fn retains meta after macro"
    (is (= {:meta-kw true}
           (meta ^:meta-kw (fn* ([]) ([a] a)))))
    (is (= {:meta-kw true}
           (meta ^:meta-kw (fn ([]) ([a] a)))))
    (is (= {:meta-kw true :other-kw true}
           (meta ^:meta-kw ^:other-kw (fn ([]) ([a] a)))))))

(deftest amap-test
  (let [l #py []]
    (is (= #py [] (amap l idx ret (+ idx (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= #py [1 3 5] (amap l idx ret (+ idx (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= #py [6 11 20] (amap l idx ret (apply + ret))))))

(deftest areduce-test
  (let [l #py []]
    (is (= 0 (areduce l idx ret 0 (+ ret (aget l idx))))))

  (let [l #py [1 2 3]]
    (is (= 6 (areduce l idx ret 0 (+ ret (aget l idx)))))))

(defmacro case-with-seq
  []
  `(case :val
     ~(seq [:val]) :found))

(deftest case-test
  (is (= "yes" (case :a :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "nope" (case :b :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "mega nope" (case :c :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "nerp" (case "da" :b "nope" :c "mega nope" :a "yes" "nerp")))
  (is (= "duh" (case "yes" :a "no" b "also no" "duh")))
  (is (= "also no" (case 'b :a "no" b "also no" "duh")))
  (is (= "also no" (case 'b :a "no" (b c d) "also no" "duh")))
  (is (= "also no" (case 'c :a "no" (b c d) "also no" "duh")))
  (is (= "also no" (case 'd :a "no" (b c d) "also no" "duh")))
  (is (= "duh" (case 'e :a "no" (b c d) "also no" "duh")))
  (is (= 0 (case 1 0)))
  (is (= :found (case-with-seq)))
  (let [out* (atom [])]
    (is (= 2 (case :2
               :1 (do (swap! out* conj 1) 1)
               :2 (do (swap! out* conj 2) 2)
               :3 (do (swap! out* conj 3) 3)
               (do (swap! out* conj 4) 4))))
    (is (= [2] @out*)))
  (is (thrown? python/ValueError
               (case "da" :b "nope" :c "mega nope" :a "yes"))))

(deftest condp-test
  (testing "condp result value"
    (is (= :a (condp = "a" :a)))
    (is (= :a (condp = "a"
                "b" :b
                :a)))
    (is (= :a (condp = "a"
                "b" :b
                "c" :c
                :a)))
    (is (nil? (condp = "a"
                "b" :b
                "a" nil
                "c" :c
                :a)))
    (is (thrown? python/ValueError
                 (condp = "a"
                   "b" :b
                   "c" :c))))

  (testing "condp result function"
    (is (= :a (condp some [1 8 10 12]
                #{2 4 6} :>> inc
                :a)))
    (is (= 0 (condp some [1 8 10 12]
               #{2 4 6} :>> inc
               #{1 3 5} :>> dec
               :a)))))

(deftest lazy-cat-test
  (is (= '(1 2 3 4 5 6) (lazy-cat [1 2 3] [4 5 6])))

  (testing "laziness"
    (let [a (atom nil)]
      (is (= '(1 2 3 4 5)
             (take 5
                   (lazy-cat [1 2 3 4 5 6]
                             (map #(reset! a %) [7 8 9 0])))))
      (is (nil? @a))
      (is (= [1 2 3 4 5 6 7 8 9 0]
             (lazy-cat [1 2 3 4 5]
                       (map #(reset! a %) [6 7 8 9 0]))))
      (is (zero? @a)))))

(deftest for-test
  (testing "no recursion error"
    (is (= 10000 (count (for [x (range 100), y (range 100)] [x y])))))

  (testing "basic for comprehensions"
    (is (= [1 2 3 4] (for [x [1 2 3 4]] x)))

    (testing "for comprehension with :let modifier"
      (is (= [[0 1] [1 2] [2 3] [3 4] [4 5]]
             (for [x    (range 5)
                   :let [y (inc x)]]
               [x y]))))

    (testing "for comprehension with :when modifier"
      (is (= [1 3 5]
             (for [x     (range 6)
                   :when (odd? x)]
               x))))

    (testing "for comprehension with :while modifier"
      (is (= [1 3 5]
             (for [x      [1 3 5 6 8 10]
                   :while (odd? x)]
               x)))))

  (testing "nested for comprehension"
    (is (= [[0 :a] [0 :b] [0 :c]
            [1 :a] [1 :b] [1 :c]
            [2 :a] [2 :b] [2 :c]]
           (for [x (range 3)
                 y [:a :b :c]]
             [x y])))

    (testing "for comprehension with :let modifier"
      (is (= [[0 :a 0] [0 :b 0] [0 :c 0]
              [1 :a 2] [1 :b 2] [1 :c 2]
              [2 :a 4] [2 :b 4] [2 :c 4]]
             (for [x    (range 3)
                   :let [z (* 2 x)]
                   y    [:a :b :c]]
               [x y z]))))

    (testing "for comprehension with :when modifier"
      (is (= [[0 :a] [0 :b] [0 :c]
              [2 :a] [2 :b] [2 :c]]
             (for [x     (range 3)
                   y     [:a :b :c]
                   :when (even? x)]
               [x y])))
      (is (= [[0 :b] [1 :b] [2 :b]]
             (for [x     (range 3)
                   y     [:a :b :c]
                   :when (= y :b)]
               [x y]))))

    (testing "for comprehension with :while modifier"
      (is (= [[0 :a] [0 :b] [0 :c]
              [2 :a] [2 :b] [2 :c]]
             (for [x      (range 3)
                   y      [:a :b :c]
                   :while (even? x)]
               [x y])))
      (is (= []
             (for [x      (range 3)
                   y      [:a :b :c]
                   :while (= y :b)]
               [x y])))))

  (testing "destructuring"
    (is (= [[1 15 5 6] [1 15 7 8]
            [2 15 5 6] [2 15 7 8]]
             (for [{:keys [a]} [{:a 1} {:a 2}]
                   b [15 16]
                   :while (= b 15)
                   [x y] [[5 6] [7 8]]]
               [a b x y])))))

(deftest comment-test
  (is (= nil (comment 1)))
  (is (= nil (comment [1 2 3]))))

(deftest double-dot-test
  (is (= "abc" (.. "abc")))
  (is (= "ABC" (.. "abc" (upper))))
  (is (not (.. "abc" (upper) (islower))))
  (is (= #py ["A" "B" "C"] (.. "a,b,c" upper (split ",")))))

(deftest with-test
  (testing "basic"
    (let [[fh filename] (tempfile/mkstemp)]
      (try
        (with-open [file (python/open filename "w")]
          (.write file "Testing text"))
        (with-open [file (python/open filename)]
          (is (= "Testing text" (.read file))))
        (finally
          (os/close fh)
          (os/unlink filename)))))

  (testing "with multiple body forms"
    (let [v* (volatile! nil)]
      (is (= 2 (with [_ (contextlib/nullcontext)]
                     (vreset! v* 5) (vswap! v* inc) 2)))
      (is (= 6 @v*)))

    (let [v* (volatile! nil)]
      (is (= 3 (with [_ (contextlib/nullcontext)
                      _ (contextlib/nullcontext)]
                     (vreset! v* 6) (vswap! v* inc) 3)))
      (is (= 7 @v*))))

  (testing "exceptions"
    (is (thrown? python/FloatingPointError
                 (with [sock (socket/socket socket/AF_INET socket/SOCK_STREAM)]
                       (throw python/FloatingPointError))))))

(deftest time-test
  (is (str/includes? (with-out-str (time 123)) "msecs")))

(deftest if-let-test
  (is (= :a (if-let [a :a] a :b)))
  (is (= 2 (if-let [a 1] (inc a) :b)))
  (is (= :b (if-let [a nil] a :b)))
  (is (= :b (if-let [a false] a :b)))
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-let [a nil] a a))))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macro expansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-let [a nil b :something] a :b)))))

(deftest if-some-test
  (is (= :a (if-some [a :a] a :b)))
  (is (= 2 (if-some [a 1] (inc a) :b)))
  (is (= :b (if-some [a nil] a :b)))
  (is (= false (if-some [a false] a :b)))
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-some [a nil] a a))))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(if-some [a nil b :something] a :b)))))

(deftest when-let-test
  (is (= :a (when-let [a :a] a)))
  (is (= 2 (when-let [a 1] (inc a))))
  (is (nil? (when-let [a nil] a)))
  (is (nil? (when-let [a false] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-let [a nil b :something] a)))))

(deftest when-first-test
  (is (= :a (when-first [a [:a false nil]] a)))
  (is (= 2 (when-first [a [1 false nil]] (inc a))))
  (is (nil? (when-first [a []] a)))
  (is (nil? (when-first [a (map odd? [2 3 5])] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-first [a [:a :b :c]
                                   b (map odd? [1 2 3])]
                        a)))))

(deftest when-some-test
  (is (= :a (when-some [a :a] a)))
  (is (= 2 (when-some [a 1] (inc a))))
  (is (nil? (when-some [a nil] a)))
  (is (= false (when-some [a false] a)))

  ;; ExceptionInfo is thrown and wrapped in a CompilerException
  ;; during macroexpansion
  (is (thrown? basilisp.lang.compiler/CompilerException
               (eval '(when-some [a nil b :something] a)))))

(deftest dotimes-test
  (let [a (atom [])]
    (is (nil? (dotimes [n 5]
                (swap! a conj n))))
    (is (= [0 1 2 3 4] @a))))

(deftest while-test
  (let [a (atom 0)]
    (is (nil? (while (<= @a 10)
                (swap! a inc))))
    (is (= 11 @a))))

(def non-dynamic-var :b)
(def ^:dynamic *dynamic-var* :a)

(deftest binding-test
  (is (= *dynamic-var* :a))
  (is (= (binding [*dynamic-var* :b]
           *dynamic-var*)
         :b))
  (is (= (binding [*dynamic-var* :b]
           [*dynamic-var*
            (binding [*dynamic-var* :c]
              *dynamic-var*)])
         [:b :c]))
  (is (thrown? basilisp.lang.runtime/RuntimeException
               (push-thread-bindings {#'non-dynamic-var :c}))))

(deftest ->-test
  (is (= :a (-> :a)))
  (is (= 2 (-> 1 inc)))
  (is (= 1 (-> 1 inc dec)))
  (is (= 4 (-> 10 inc (- 7))))
  (is (= "HI" (-> "hi" .upper)))
  (is (= "Hi" (-> "HI" .lower .capitalize))))

(deftest ->>-test
  (is (= :a (->> :a)))
  (is (= 2 (->> 1 inc)))
  (is (= 1 (->> 1 inc dec)))
  (is (= 14 (->> [1 2 3 4]
                 (map inc)
                 (reduce +)))))

(deftest some->-test
  (is (= :a (some-> :a)))
  (is (= 2 (some-> 1 inc)))
  (is (= 1 (some-> 1 inc dec)))
  (is (= 4 (some-> 10 inc (- 7))))
  (is (= "the-key" (some-> (:key {:key :the-key}) (name))))

  (is (= nil (some-> {:a 3} :b inc)))
  (is (= 4 (some-> {:a 3} :a inc)))
  (is (= nil (some-> (:key {}) (name)))))

(deftest some->>-test
  (is (= :a (some->> :a)))
  (is (= 2 (some->> 1 inc)))
  (is (= 1 (some->> 1 inc dec)))
  (is (= -4 (some->> 10 inc (- 7))))
  (is (= "the-key" (some->> (:key {:key :the-key}) (name))))

  (is (= nil (some->> {:a 3} :b (- 7))))
  (is (= 5 (some->> {:a 3} :a (- 8))))
  (is (= nil (some->> (:key {}) (name)))))

(deftest cond->-test
  (is (= 1 (cond-> 1)))
  (is (= 1 (cond-> 1 false inc)))
  (is (= 0 (cond-> 1
             false inc
             true dec)))
  (is (= 4 (cond-> 10
             (= :a :a) inc
             (seq [])  (* 3)
             true      (- 7)))))

(deftest cond->>-test
  (is (= 1 (cond->> 1)))
  (is (= 1 (cond->> 1 false inc)))
  (is (= 0 (cond->> 1
             false inc
             true dec)))
  (is (= 9 (cond->> 10
             (= :a :a) inc
             (seq [])  (* 3)
             true      (- 20)))))

(deftest as->-test
  (is (= 10 (as-> 10 a)))
  (is (= 7 (as-> 18 x (- x 11))))
  (is (= 9 (as-> 8 x
             {:a x :c 0}
             (:a x)
             (inc x)))))

(deftest doto-test
  (is (= #py [] (doto #py [])))
  (is (= #py [1 2 3]
         (doto #py []
           (.append 1)
           (.append 2)
           (.append 3)))))

(deftest with-in-str-test
  (is (= "Hi I'm a string" (with-in-str "\"Hi I'm a string\"" (read)))))

(deftest with-out-str-test
  (is (= "Hello, Chris!"
         (with-out-str
           (printf "Hello, %s!" "Chris"))))
  (is (= "Hello, Chris and Rich!"
         (with-out-str
           (printf "Hello, %s and %s!" "Chris" "Rich"))))
  (is (= "Hello, Chris and Rich!"
         (with-out-str
           (printf "Hello, %(first)s and %(second)s!"
                   {"first" "Chris" "second" "Rich"})))))

(deftest fn-sequential-destructuring
  (testing "destructuring first"
    (let [v [:a :b :c :d]

          f (fn [[f]]
              {:first f})
          g (fn [[f :as all]]
              {:first f :as all})]
      (is (= {:first :a}
             (f v)))
      (is (= {:first :a :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first and rest"
    (let [v [:a :b :c :d]

          f (fn [[f & r]]
              {:first f :rest r})
          g (fn [[f & r :as all]]
              {:first f :rest r :as all})]
      (is (= {:first :a :rest '(:b :c :d)}
             (f v)))
      (is (= {:first :a :rest '(:b :c :d) :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first, second, and rest"
    (let [v [:a :b :c :d]

          f (fn [[f s & r]]
              {:first f :second s :rest r})
          g (fn [[f s & r :as all]]
              {:first f :second s :rest r :as all})]
      (is (= {:first :a :second :b :rest '(:c :d)}
             (f v)))
      (is (= {:first :a :second :b :rest '(:c :d) :as [:a :b :c :d]}
             (g v)))))

  (testing "destructuring first, second, third, and rest"
    (let [v [:a :b :c :d]

          f (fn [[f s t & r]]
              {:first f :second s :third t :rest r})
          g (fn [[f s t & r :as all]]
              {:first f :second s :third t :rest r :as all})]
      (is (= {:first :a :second :b :third :c :rest '(:d)}
             (f v)))
      (is (= {:first :a :second :b :third :c :rest '(:d) :as [:a :b :c :d]}
             (g v)))))

  (testing "nested destructuring"
    (let [v [[:a :b] [:c :d]]

          f (fn [[[k1 v1] [k2 v2]]]
              [k1 v1 k2 v2])
          g (fn [[[k1 v1 :as f] [k2 v2 :as s] :as orig]]
              {:all    [k1 v1 k2 v2]
               :first  f
               :second s
               :orig   orig})]
      (is (= [:a :b :c :d] (f v)))
      (is (= {:all    [:a :b :c :d]
              :first  [:a :b]
              :second [:c :d]
              :orig   [[:a :b] [:c :d]]}
             (g v))))))

(deftest fn-associative-destructuring
  (testing "ignore non-associative types"
    (let [f (fn [{:keys [a]}]
              a)]
      (are [v] (nil? (f v))
        nil
        []
        [:a 5]
        ""
        "abc"
        5
        5.5))

    (testing "with defaults"
      (let [f (fn [{:keys [a] :or {a :not-defined}}]
                a)]
        (are [v] (= :not-defined (f v))
          nil
          []
          [:a 5]
          ""
          "abc"
          5
          5.5))))

  (testing "falsey values not overridden by default values"
    (let [f (fn [{:keys [a] :or {a :not-defined}}]
              a)]
      (are [v] (= v (f {:a v}))
        nil
        false)))

  (testing "destructuring simple keys"
    (let [m {:a "a" :b "b"}

          f (fn [{:keys [a]}]
              [a])
          g (fn [{:keys [a] :as m}]
              [a m])
          h (fn [{:keys [a b] :as m}]
              [a b m])]
      (is (= ["a"] (f m)))
      (is (= ["a" m] (g m)))
      (is (= ["a" "b" m] (h m))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}
          m2 '(:a "a" :c "d")
          m3 (list m1)

          f (fn [{:keys [a c] :as m :or {c "c"}}]
              [a c m])]
      (is (= ["a" "c" m] (f m)))
      (is (= ["a" "d" m1] (f m1)))
      (is (= ["a" "d" (apply hash-map m2)] (f m2)))
      (is (= ["a" "d" m1] (f m3)))))

  (testing "destructuring simple string keys"
    (let [m {:a 1 :b "b" "a" :a "b" :b}

          f (fn [{:strs [a]}]
              [a])
          g (fn [{:strs [a] :as m}]
              [a m])
          h (fn [{:strs [a b] :as m}]
              [a b m])]
      (is (= [:a] (f m)))
      (is (= [:a m] (g m)))
      (is (= [:a :b m] (h m))))

    (let [m  {"a" :a}
          m1 {"a" :a "c" :d}

          f (fn [{:strs [a c] :as m :or {c :c}}]
              [a c m])]
      (is (= [:a :c m] (f m)))
      (is (= [:a :d m1] (f m1)))))

  (testing "destructuring simple symbol keys"
    (let [m {:a 1 :b "b" 'a :a 'b :b}

          f (fn [{:syms [a]}]
              [a])
          g (fn [{:syms [a] :as m}]
              [a m])
          h (fn [{:syms [a b] :as m}]
              [a b m])]
      (is (= [:a] (f m)))
      (is (= [:a m] (g m)))
      (is (= [:a :b m] (h m))))

    (let [m  {'a :a}
          m1 {'a :a 'c :d}

          f (fn [{:syms [a c] :as m :or {c :c}}]
              [a c m])]
      (is (= [:a :c m] (f m)))
      (is (= [:a :d m1] (f m1)))))

  (testing "destructuring namespaced keys"
    (let [m {:a   "a"
             :b   "b"
             :a/a "aa"
             :a/b "bb"
             :c/c "cc"
             :c/d "dd"}

          f (fn [{:a/keys [a b] old-a :a old-b :b}]
              [old-a old-b a b])
          g (fn [{:keys [a b] :c/keys [c d]}]
              [a b c d])]
      (is (= ["a" "b" "aa" "bb"] (f m)))
      (is (= ["a" "b" "cc" "dd"] (g m))))

    (let [m  {:a "a"}
          m1 {:a/a "aa" :a "a"}

          f (fn [{:a/keys [a] :as m :or {a :c}}]
              [a m])]
      (is (= [:c m] (f m)))
      (is (= ["aa" m1] (f m1)))))

  (testing "destructuring namespaced symbols"
    (let [m {'a   "a"
             'b   "b"
             'a/a "aa"
             'a/b "bb"
             'c/c "cc"
             'c/d "dd"}

          f (fn [{:a/syms [a] :syms [b]}]
              [a b])
          g (fn [{:syms [a b] :c/syms [c d]}]
              [a b c d])]
      (is (= ["aa" "b"] (f m)))
      (is (= ["a" "b" "cc" "dd"] (g m))))

    (let [m  {'a "a"}
          m1 {'a/a "aa" 'a "a"}

          f (fn [{:a/syms [a] :as m :or {a :c}}]
              [a m])]
      (is (= [:c m] (f m)))
      (is (= ["aa" m1] (f m1)))))

  (testing "destructuring individual keys"
    (let [m {:a "a" :b "b" 3 "three" "key" "string-key"}

          f (fn [{a :a three 3 s "key"}]
              [a three s])
          g (fn [{a :a :as m}]
              [a m])
          h (fn [{a :a b :b :as m}]
              [a b m])]
      (is (= ["a" "three" "string-key"] (f m)))
      (is (= ["a" m] (g m)))
      (is (= ["a" "b" m] (h m))))

    (let [f (fn [{a :a/a}]
              [a])]
      (is (= ["aa"] (f {:a/a "aa" :a "a"}))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}

          f (fn [{a :a c :c :as m :or {c :c}}]
              [a c m])]
      (is (= ["a" :c m] (f m)))
      (is (= ["a" "d" m1] (f m1)))))

  (testing "destructuring sequential values nested in associative vals"
    (let [v1 [{:a 1 :b 2 :c 3 :vec [4 5 6 7 8]}]
          v2 [{:a 1 :b 2 :vec [4 5 6 7 8]}]
          v3 [{:a 1 :vec [4]}]

          f (fn [[{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}}]]
              [a b c d e f v])]
      (is (= [1 2 3 4 5 '(6 7 8) [4 5 6 7 8]] (f v1)))
      (is (= [1 2 34 4 5 '(6 7 8) [4 5 6 7 8]] (f v2)))
      (is (= [1 14 34 4 nil nil [4]] (f v3)))))

  (testing "keyword rest arguments"
    (let [f (fn [a b & {:keys [c]}] [a b c])]
      (is (= [:a :b "rest arg"] (f :a :b :c "rest arg")))
      (is (= [:a :b "rest arg"] (f :a :b :d "other" :c "rest arg")))))

  (testing "trailing map keyword args"
    (let [f (fn [a b & {:keys [c d] :as kwargs}]
              [a b c d kwargs])]
      (is (= [:a :b 1 2 {:c 1 :d 2}] (f :a :b :c 1 :d 2)))
      (is (= [:a :b 1 2 {:c 1 :d 2}] (f :a :b :c 1 {:d 2})))
      (is (= [:a :b 1 2 {:c 1 :d 2}] (f :a :b {:c 1 :d 2})))
      (is (= [:a :b 3 2 {:c 3 :d 2}] (f :a :b :c 1 {:c 3 :d 2})))
      (is (= [:a :b nil 2 {:d 2}] (f :a :b :d 2)))
      (is (= [:a :b nil 2 {:d 2}] (f :a :b {:d 2})))
      (is (= [:a :b 1 nil {:c 1}] (f :a :b :c 1)))
      (is (= [:a :b 1 nil {:c 1}] (f :a :b {:c 1})))
      (is (= [:a :b nil nil nil] (f :a :b))))))

(deftest let-sequential-destructuring
  (testing "destructuring first"
    (let [[f] [:a :b :c :d]]
      (is (= :a f)))

    (let [[f :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= [:a :b :c :d] v)))

    (let [[f] '()]
      (is (= nil f)))

    (let [[f :as v] '()]
      (is (= nil f))
      (is (= '() v))))

  (testing "destructuring first and rest"
    (let [[f & r] [:a :b :c :d]]
      (is (= '(:b :c :d) r))
      (is (= :a f)))

    (let [[f & r :as all] [:a :b :c :d]]
      (is (= '(:b :c :d) r))
      (is (= :a f))
      (is (= [:a :b :c :d] all)))

    (let [[f & r] '()]
      (is (= nil f))
      (is (= nil r)))

    (let [[f & r :as v] '()]
      (is (= nil f))
      (is (= nil r))
      (is (= '() v))))

  (testing "destructuring first, second, and rest"
    (let [[f s & r] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= '(:c :d) r)))

    (let [[f s & r :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= '(:c :d) r))
      (is (= [:a :b :c :d] v)))

    (let [[f s & r] '()]
      (is (= nil f))
      (is (= nil s))
      (is (= nil r)))

    (let [[f s & r :as v] '()]
      (is (= nil f))
      (is (= nil s))
      (is (= nil r))
      (is (= '() v))))

  (testing "destructuring first, second, third, and rest"
    (let [[f s t & r] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= :c t))
      (is (= '(:d) r)))

    (let [[f s t & r :as v] [:a :b :c :d]]
      (is (= :a f))
      (is (= :b s))
      (is (= :c t))
      (is (= '(:d) r))
      (is (= [:a :b :c :d] v)))

    (let [[f s t & r] [:a]]
      (is (= :a f))
      (is (= nil s))
      (is (= nil t))
      (is (= nil r)))

    (let [[f s t & r :as v] [:a]]
      (is (= :a f))
      (is (= nil s))
      (is (= nil t))
      (is (= nil r))
      (is (= [:a] v))))

  (testing "nested destructuring"
    (let [[[k1 v1] [k2 v2]] [[:a :b] [:c :d]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= :c k2))
      (is (= :d v2)))

    (let [[[k1 v1 :as f] [k2 v2 :as s] :as all] [[:a :b] [:c :d]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= [:a :b] f))
      (is (= :c k2))
      (is (= :d v2))
      (is (= [:c :d] s))
      (is (= [[:a :b] [:c :d]] all)))

    (let [[[k1 v1] [k2 v2]] [[:a :b] [:c]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= :c k2))
      (is (= nil v2)))

    (let [[[k1 v1 :as f] [k2 v2 :as s] :as all] [[:a :b] [:c]]]
      (is (= :a k1))
      (is (= :b v1))
      (is (= [:a :b] f))
      (is (= :c k2))
      (is (= nil v2))
      (is (= [:c] s))
      (is (= [[:a :b] [:c]] all)))))

(deftest let-associative-destructuring
  (testing "ignore non-associative types"
    (are [v] (nil? (let [{:keys [a]} v] a))
      nil
      []
      [:a 5]
      ""
      "abc"
      5
      5.5)

    (testing "with defaults"
      (are [v] (= :not-defined (let [{:keys [a] :or {a :not-defined}} v] a))
        nil
        []
        [:a 5]
        ""
        "abc"
        5
        5.5)))

  (testing "falsey values not overridden by default values"
    (are [v] (= v (let [{:keys [a] :or {a :not-defined}} {:a v}]
                    a))
      nil
      false))

  (testing "destructuring simple keys"
    (let [{:keys [a b]} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b)))

    (let [{:keys [a b] :as m} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= {:a "a" :b "b"} m)))

    (let [{:keys [a b] :as m :or {b "c"}} {:a "a"}]
      (is (= "a" a))
      (is (= "c" b))
      (is (= {:a "a"} m)))

    (let [{:keys [a b] :as m :or {b "c"}} '(:a "a")]
      (is (= "a" a))
      (is (= "c" b))
      (is (= {:a "a"} m)))

    (let [{:keys [a b] :as m :or {b "c"}} '({:a "a" :b "b"})]
      (is (= "a" a))
      (is (= "b" b))
      (is (= {:a "a" :b "b"} m))))

  (testing "destructuring simple string keys"
    (let [{:strs [a b]} {:a 1 :b 2 "a" :a "b" :b}]
      (is (= :a a))
      (is (= :b b)))

    (let [{:strs [a b] :as m} {:a 1 :b 2 "a" :a "b" :b}]
      (is (= :a a))
      (is (= :b b))
      (is (= {:a 1 :b 2 "a" :a "b" :b} m)))

    (let [{:strs [a b] :as m :or {b "c"}} {:a 1 :b 2 "a" :a}]
      (is (= :a a))
      (is (= "c" b))
      (is (= {:a 1 :b 2 "a" :a} m))))

  (testing "destructuring simple symbol keys"
    (let [{:syms [a b]} {:a 1 :b "b" 'a :a 'b :b}]
      (is (= :a a))
      (is (= :b b)))

    (let [{:syms [a b] :as m} {:a 1 :b "b" 'a :a 'b :b}]
      (is (= :a a))
      (is (= :b b))
      (is (= {:a 1 :b "b" 'a :a 'b :b} m)))

    (let [{:syms [a b] :as m :or {b "c"}} {:a 1 :b "b" 'a :a}]
      (is (= :a a))
      (is (= "c" b))
      (is (= {:a 1 :b "b" 'a :a} m))))

  (testing "destructuring individual keys"
    (let [{a :a b :b three 3 s "key"} {:a "a"
                                       :b "b"
                                       3 "three"
                                       "key" "string-key"}]
      (is (= [a b three s] ["a" "b" "three" "string-key"])))

    (let [{a :a b :b :as m} {:a "a" :b "b"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= {:a "a" :b "b"} m)))

    (let [{a :a b :b :as m :or {b "c"}} {:a "a"}]
      (is (= "a" a))
      (is (= "c" b))
      (is (= {:a "a"} m)))

    (let [{a :a/a} {:a/a "aa" :a "a"}]
      (is (= "aa" a))))

  (testing "destructuring namespaced keys"
    (let [{:a/keys [a b] old-a :a old-b :b} {:a   "a"
                                             :b   "b"
                                             :a/a "aa"
                                             :a/b "bb"
                                             :c/c "cc"
                                             :c/d "dd"}]
      (is (= "aa" a))
      (is (= "bb" b))
      (is (= "a" old-a))
      (is (= "b" old-b)))

    (let [{:keys [a b] :c/keys [c d]} {:a   "a"
                                       :b   "b"
                                       :a/a "aa"
                                       :a/b "bb"
                                       :c/c "cc"
                                       :c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "cc" c))
      (is (= "dd" d)))

    (let [{:keys [a b] :c/keys [c d] :or {c "ee"}}
          {:a "a" :b "b" :a/a "aa" :a/b "bb" :c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "ee" c))
      (is (= "dd" d))))

(testing "destructuring namespaced symbols"
    (let [{:a/syms [a b] old-a 'a old-b 'b} {'a   "a"
                                             'b   "b"
                                             'a/a "aa"
                                             'a/b "bb"
                                             'c/c "cc"
                                             'c/d "dd"}]
      (is (= "aa" a))
      (is (= "bb" b))
      (is (= "a" old-a))
      (is (= "b" old-b)))

    (let [{:syms [a b] :c/syms [c d]} {'a   "a"
                                       'b   "b"
                                       'a/a "aa"
                                       'a/b "bb"
                                       'c/c "cc"
                                       'c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "cc" c))
      (is (= "dd" d)))

    (let [{:syms [a b] :c/syms [c d] :or {c "ee"}}
          {'a "a" 'b "b" 'a/a "aa" 'a/b "bb" 'c/d "dd"}]
      (is (= "a" a))
      (is (= "b" b))
      (is (= "ee" c))
      (is (= "dd" d))))

  (testing "nested destructuring"
    (let [{{:keys [a b] :as nested} :nested :as m} {:nested {:a "aa" :b "bb"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= "bb" b))
      (is (= {:a "aa" :b "bb"} nested))
      (is (= {:nested {:a "aa" :b "bb"} :a "a" :b "b"} m)))

    (let [{{:keys [a b] :as nested :or {b "ee"}} :nested :as m} {:nested {:a "aa"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= "ee" b))
      (is (= {:a "aa"} nested))
      (is (= {:nested {:a "aa"} :a "a" :b "b"} m)))

    (let [{{:keys [a b] :as nested} :nested :as m :or {b "ee"}} {:nested {:a "aa"} :a "a" :b "b"}]
      (is (= "aa" a))
      (is (= nil b))
      (is (= {:a "aa"} nested))
      (is (= {:nested {:a "aa"} :a "a" :b "b"} m)))

    (let [{{{:keys [a b] :as nested} :nested :as middle} :middle :as m}
          {:middle {:nested {:a "aaa" :b "bbb"}
                    :a      "aa"
                    :b      "bb"}
           :a      "a"
           :b      "b"}]
      (is (= "aaa" a))
      (is (= "bbb" b))
      (is (= {:a "aaa" :b "bbb"} nested))
      (is (= {:nested {:a "aaa" :b "bbb"} :a "aa" :b "bb"} middle))
      (is (= {:middle {:nested {:a "aaa" :b "bbb"}
                       :a      "aa"
                       :b      "bb"}
              :a      "a"
              :b      "b"}
             m))))

  (testing "destructuring sequential values nested in associative vals"
    (let [v1 [{:a 1 :b 2 :c 3 :vec [4 5 6 7 8]}]
          v2 [{:a 1 :b 2 :vec [4 5 6 7 8]}]
          v3 [{:a 1 :vec [4]}]]
      (let [[{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}}] v1]
        (is (= [1 2 3 4 5 '(6 7 8) [4 5 6 7 8]] [a b c d e f v])))
      (let [[{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}}] v2]
        (is (= [1 2 34 4 5 '(6 7 8) [4 5 6 7 8]] [a b c d e f v])))
      (let [[{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}}] v3]
        (is (= [1 14 34 4 nil nil [4]] [a b c d e f v]))))))

(deftest letfn-sequential-destructuring
  (testing "destructuring first"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f]]
                {:first f})
              (g [[f :as all]]
                {:first f :as all})]
        (is (= {:first :a}
               (f v)))
        (is (= {:first :a :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f & r]]
                {:first f :rest r})
              (g [[f & r :as all]]
                {:first f :rest r :as all})]
        (is (= {:first :a :rest '(:b :c :d)}
               (f v)))
        (is (= {:first :a :rest '(:b :c :d) :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first, second, and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f s & r]]
                {:first f :second s :rest r})
              (g [[f s & r :as all]]
                {:first f :second s :rest r :as all})]
        (is (= {:first :a :second :b :rest '(:c :d)}
               (f v)))
        (is (= {:first :a :second :b :rest '(:c :d) :as [:a :b :c :d]}
               (g v))))))

  (testing "destructuring first, second, third, and rest"
    (let [v [:a :b :c :d]]
      (letfn [(f [[f s t & r]]
                {:first f :second s :third t :rest r})
              (g [[f s t & r :as all]]
                {:first f :second s :third t :rest r :as all})]
        (is (= {:first :a :second :b :third :c :rest '(:d)}
               (f v)))
        (is (= {:first :a :second :b :third :c :rest '(:d) :as [:a :b :c :d]}
               (g v))))))

  (testing "nested destructuring"
    (let [v [[:a :b] [:c :d]]]
      (letfn [(f [[[k1 v1] [k2 v2]]]
                [k1 v1 k2 v2])
              (g [[[k1 v1 :as f] [k2 v2 :as s] :as orig]]
                {:all    [k1 v1 k2 v2]
                 :first  f
                 :second s
                 :orig   orig})]
        (is (= [:a :b :c :d] (f v)))
        (is (= {:all    [:a :b :c :d]
                :first  [:a :b]
                :second [:c :d]
                :orig   [[:a :b] [:c :d]]}
               (g v)))))))

(deftest letfn-associative-destructuring
  (testing "ignore non-associative types"
    (letfn [(f [{:keys [a]}]
              a)]
      (are [v] (nil? (f v))
        nil
        []
        [:a 5]
        ""
        "abc"
        5
        5.5))

    (testing "with defaults"
      (letfn [(f [{:keys [a] :or {a :not-defined}}]
                a)]
        (are [v] (= :not-defined (f v))
          nil
          []
          [:a 5]
          ""
          "abc"
          5
          5.5))))

  (testing "falsey values not overridden by default values"
    (letfn [(f [{:keys [a] :or {a :not-defined}}]
              a)]
      (are [v] (= v (f {:a v}))
        nil
        false)))

  (testing "destructuring simple keys"
    (let [m {:a "a" :b "b"}]
      (letfn [(f [{:keys [a]}]
                [a])
              (g [{:keys [a] :as m}]
                [a m])
              (h [{:keys [a b] :as m}]
                [a b m])]
        (is (= ["a"] (f m)))
        (is (= ["a" m] (g m)))
        (is (= ["a" "b" m] (h m)))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}
          m2 '(:a "a" :c "d")
          m3 (list m1)]
      (letfn [(f [{:keys [a c] :as m :or {c "c"}}]
                [a c m])]
        (is (= ["a" "c" m] (f m)))
        (is (= ["a" "d" m1] (f m1)))
        (is (= ["a" "d" (apply hash-map m2)] (f m2)))
        (is (= ["a" "d" m1] (f m3))))))

  (testing "destructuring simple string keys"
    (let [m {:a 1 :b "b" "a" :a "b" :b}]
      (letfn [(f [{:strs [a]}]
                [a])
              (g [{:strs [a] :as m}]
                [a m])
              (h [{:strs [a b] :as m}]
                [a b m])]
        (is (= [:a] (f m)))
        (is (= [:a m] (g m)))
        (is (= [:a :b m] (h m)))))

    (let [m  {"a" :a}
          m1 {"a" :a "c" :d}]
      (letfn [(f [{:strs [a c] :as m :or {c :c}}]
                [a c m])]
        (is (= [:a :c m] (f m)))
        (is (= [:a :d m1] (f m1))))))

  (testing "destructuring simple symbol keys"
    (let [m {:a 1 :b "b" 'a :a 'b :b}]
      (letfn [(f [{:syms [a]}]
                [a])
              (g [{:syms [a] :as m}]
                [a m])
              (h [{:syms [a b] :as m}]
                [a b m])]
        (is (= [:a] (f m)))
        (is (= [:a m] (g m)))
        (is (= [:a :b m] (h m)))))

    (let [m  {'a :a}
          m1 {'a :a 'c :d}]
      (letfn [(f [{:syms [a c] :as m :or {c :c}}]
                [a c m])]
        (is (= [:a :c m] (f m)))
        (is (= [:a :d m1] (f m1))))))

  (testing "destructuring namespaced keys"
    (let [m {:a   "a"
             :b   "b"
             :a/a "aa"
             :a/b "bb"
             :c/c "cc"
             :c/d "dd"}]
      (letfn [(f [{:a/keys [a b] old-a :a old-b :b}]
                [old-a old-b a b])
              (g [{:keys [a b] :c/keys [c d]}]
                [a b c d])]
        (is (= ["a" "b" "aa" "bb"] (f m)))
        (is (= ["a" "b" "cc" "dd"] (g m)))))

    (let [m  {:a "a"}
          m1 {:a/a "aa" :a "a"}]
      (letfn [(f [{:a/keys [a] :as m :or {a :c}}]
                [a m])]
        (is (= [:c m] (f m)))
        (is (= ["aa" m1] (f m1))))))

  (testing "destructuring namespaced symbols"
    (let [m {'a   "a"
             'b   "b"
             'a/a "aa"
             'a/b "bb"
             'c/c "cc"
             'c/d "dd"}]
      (letfn [(f [{:a/syms [a b] old-a 'a old-b 'b}]
                [old-a old-b a b])
              (g [{:syms [a b] :c/syms [c d]}]
                [a b c d])]
        (is (= ["a" "b" "aa" "bb"] (f m)))
        (is (= ["a" "b" "cc" "dd"] (g m)))))

    (let [m  {'a "a"}
          m1 {'a/a "aa" 'a "a"}]
      (letfn [(f [{:a/syms [a] :as m :or {a :c}}]
                [a m])]
        (is (= [:c m] (f m)))
        (is (= ["aa" m1] (f m1))))))

  (testing "destructuring individual keys"
    (let [m {:a "a" :b "b" 3 "three" "key" "string-key"}]
      (letfn [(f [{a :a three 3 s "key"}]
                [a three s])
              (g [{a :a :as m}]
                [a m])
              (h [{a :a b :b :as m}]
                [a b m])]
        (is (= ["a" "three" "string-key"] (f m)))
        (is (= ["a" m] (g m)))
        (is (= ["a" "b" m] (h m)))))

    (letfn [(f [{a :a/a}]
              [a])]
      (is (= ["aa"] (f {:a/a "aa" :a "a"}))))

    (let [m  {:a "a"}
          m1 {:a "a" :c "d"}]
      (letfn [(f [{a :a c :c :as m :or {c :c}}]
                [a c m])]
        (is (= ["a" :c m] (f m)))
        (is (= ["a" "d" m1] (f m1))))))

  (testing "destructuring sequential values nested in associative vals"
    (let [v1 [{:a 1 :b 2 :c 3 :vec [4 5 6 7 8]}]
          v2 [{:a 1 :b 2 :vec [4 5 6 7 8]}]
          v3 [{:a 1 :vec [4]}]]
      (letfn [(f [[{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}}]]
                [a b c d e f v])]
        (is (= [1 2 3 4 5 '(6 7 8) [4 5 6 7 8]] (f v1)))
        (is (= [1 2 34 4 5 '(6 7 8) [4 5 6 7 8]] (f v2)))
        (is (= [1 14 34 4 nil nil [4]] (f v3))))))

  (testing "keyword rest arguments"
    (letfn [(f [a b & {:keys [c]}] [a b c])]
      (is (= [:a :b "rest arg"] (f :a :b :c "rest arg")))
      (is (= [:a :b "rest arg"] (f :a :b :d "other" :c "rest arg"))))))

(deftest loop-sequential-destructuring
  (testing "destructuring first"
    (is (= :a (loop [[f] [:a :b :c :d]] f)))

    (is (= nil (loop [[f] '()] f)))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f :as v] [:a :b :c :d]
                  orig-all  v
                  accum     []]
             (if f
               (recur (rest v) orig-all (conj accum f))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil '()]
           (loop [[f :as v] '()]
             [f v]))))

  (testing "destructuring first and rest"
    (is (= "abcd"
           (loop [[f & r] [:a :b :c :d]
                  accum   []]
             (if f
               (recur r (conj accum f))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f & r :as all] [:a :b :c :d]
                  orig-all        all
                  accum           []]
             (if f
               (recur r orig-all (conj accum f))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil]
           (loop [[f & r] '()]
             [f r])))

    (is (= [nil nil '()]
           (loop [[f & r :as v] '()]
             [f r v]))))

  (testing "destructuring first, second, and rest"
    (is (= "abcd"
           (loop [[f s & r] [:a :b :c :d]
                  accum     []]
             (if f
               (recur r (conj accum f s))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d] "abcd"]
           (loop [[f s & r :as all] [:a :b :c :d]
                  orig-all          all
                  accum             []]
             (if f
               (recur r orig-all (conj accum f s))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil nil]
           (loop [[f s & r] '()]
             [f s r])))

    (is (= [nil nil nil '()]
           (loop [[f s & r :as v] '()]
             [f s r v]))))

  (testing "destructuring first, second, third, and rest"
    (is (= "abcdef"
           (loop [[f s t & r] [:a :b :c :d :e :f]
                  accum       []]
             (if f
               (recur r (conj accum f s t))
               (apply str (map name accum))))))

    (is (= [[:a :b :c :d :e :f] "abcdef"]
           (loop [[f s t & r :as all] [:a :b :c :d :e :f]
                  orig-all            all
                  accum               []]
             (if f
               (recur r orig-all (conj accum f s t))
               [orig-all (apply str (map name accum))]))))

    (is (= [nil nil nil nil]
           (loop [[f s t & r] '()]
             [f s t r])))

    (is (= [nil nil nil nil '()]
           (loop [[f s t & r :as v] '()]
             [f s t r v]))))

  (testing "nested destructuring"
    (is (= 10
           (loop [[[v1 v2] & r] [[1 2] [3 4] [5 6]]
                  accum         0]
             (if (>= accum 10)
               accum
               (recur r (+ accum v1 v2))))))

    (is (= [10 [[1 2] [3 4]] [[1 2] [3 4] [5 6]]]
           (loop [[[v1 v2 :as pair] & r :as all] [[1 2] [3 4] [5 6]]
                  orig-all              all
                  pairs                 []
                  accum                 0]
             (if (>= accum 10)
               [accum pairs orig-all]
               (recur r orig-all (conj pairs pair) (+ accum v1 v2))))))))

(deftest loop-associative-destructuring
  (testing "ignore non-associative types"
    (is (= []
           (loop [items       [nil [] [:a 5] "" "abc" 5 5.5]
                  {:keys [a]} (first items)
                  accum       []]
             (if (seq items)
               (recur (rest items)
                      (first (rest items))
                      (cond-> accum a (conj a)))
               accum))))

    (testing "with defaults"
      (is (= (vec (repeat 7 :not-defined))
             (loop [items                            [nil [] [:a 5] "" "abc" 5 5.5]
                    {:keys [a] :or {a :not-defined}} (first items)
                    accum                            []]
               (if (seq items)
                 (recur (rest items)
                        (first (rest items))
                        (cond-> accum a (conj a)))
                 accum))))))

  (testing "falsey values not overridden by default values"
    (is (= [nil false]
           (loop [items                                  (map #(hash-map :a %) [nil false])
                  {:keys [a] :as m :or {a :not-defined}} (first items)
                  accum                                  []]
             (if (seq items)
               (recur (rest items)
                      (first (rest items))
                      (conj accum a))
               accum)))))

  (testing "destructuring simple keys"
    (is (= [[{:a "a" :b "b"} {:a "c" :b "d"} {:a "e"} {:a "f"} {:a "g" :b "h"}] "abcdeefegh"]
           (loop [items                           [{:a "a" :b "b"} {:a "c" :b "d"} {:a "e"} '(:a "f") '({:a "g" :b "h"})]
                  {:keys [a b] :as m :or {b "e"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring simple string keys"
    (is (= [[{:a "a" :b "b" "a" "1" "b" "2"}
             {:a "c" :b "d" "a" "3" "b" "4"}
             {"a" "5"}]
            "123455"]
           (loop [items                           [{:a "a" :b "b" "a" "1" "b" "2"}
                                                   {:a "c" :b "d" "a" "3" "b" "4"}
                                                   {"a" "5"}]
                  {:strs [a b] :as m :or {b "5"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring simple symbol keys"
    (is (= [[{:a "a" :b "b" 'a "1" 'b "2"}
             {:a "c" :b "d" 'a "3" 'b "4"}
             {'a "5"}]
            "123455"]
           (loop [items                           [{:a "a" :b "b" 'a "1" 'b "2"}
                                                   {:a "c" :b "d" 'a "3" 'b "4"}
                                                   {'a "5"}]
                  {:syms [a b] :as m :or {b "5"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring individual keys"
    (is (= [[{:a/a "A" :a "a" :b "b"}
             {:a/a "C" :a "c" :b "d"}
             {:a/a "E"}]
            "AbCdEe"]
           (loop [items                           [{:a/a "A" :a "a" :b "b"}
                                                   {:a/a "C" :a "c" :b "d"}
                                                   {:a/a "E"}]
                  {a :a/a b :b :as m :or {b "e"}} (first items)
                  coll                            []
                  accum                           []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring namespaced keys"
    (is (= [[{:a/a "A" :a "a" :b "b"}
             {:a/a "C" :a "c" :b "d"}
             {:a "e" :b "e"}]
            "AbCdZe"]
           (loop [items                                [{:a/a "A" :a "a" :b "b"}
                                                        {:a/a "C" :a "c" :b "d"}
                                                        {:a "e" :b "e"}]
                  {:a/keys [a] b :b :as m :or {a "Z"}} (first items)
                  coll                                 []
                  accum                                []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring namespaced syms"
    (is (= [[{'a/a "A" 'a "a" 'b "b"}
             {'a/a "C" 'a "c" 'b "d"}
             {'a "e" 'b "e"}]
            "AbCdZe"]
           (loop [items                                [{'a/a "A" 'a "a" 'b "b"}
                                                        {'a/a "C" 'a "c" 'b "d"}
                                                        {'a "e" 'b "e"}]
                  {:a/syms [a] b 'b :as m :or {a "Z"}} (first items)
                  coll                                 []
                  accum                                []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "nested destructuring"
    (is (= [[{:nested {:a "A"} :a "a" :b "b"}
             {:nested {:a "C"} :a "c" :b "d"}
             {:a "e" :b "e"}]
            "AbCde"]
           (loop [items [{:nested {:a "A"} :a "a" :b "b"}
                         {:nested {:a "C"} :a "c" :b "d"}
                         {:a "e" :b "e"}]

                  {{:keys [a] :as nested} :nested b :b :as m :or {a "Z"}}
                  (first items)

                  coll  []
                  accum []]
             (if m
               (recur (rest items)
                      (first (rest items))
                      (conj coll m)
                      (conj accum a b))
               [coll (apply str accum)])))))

  (testing "destructuring sequential values nested in associative vals"
    (let [colls [[{:a 1 :b 2 :c 3 :vec [4 5 6 7 8]}]
                 [{:a 1 :b 2 :vec [4 5 6 7 8]}]
                 [{:a 1 :vec [4]}]]]
      (is (= [colls
              [[1 2 3 4 5 '(6 7 8) [4 5 6 7 8]]
               [1 2 34 4 5 '(6 7 8) [4 5 6 7 8]]
               [1 14 34 4 nil nil [4]]]]
             (loop [items                                                         colls
                    [{a :a b :b c :c [d e & f :as v] :vec :or {b 14 c 34}} :as m] (first items)
                    coll                                                          []
                    accum                                                         []]
               (if m
                 (recur (rest items)
                        (first (rest items))
                        (conj coll m)
                        (conj accum [a b c d e f v]))
                 [coll accum])))))))

(deftest fn-pre-and-post-condition-test
  (testing "fn with map as body member does not count as condition map"
    (let [f (fn [v]
              {:pre  [v]
               :post [:nothin]})]
      (is (= {:pre [1] :post [:nothin]} (f 1)))))

  (testing "pre-condition only"
    (testing "empty pre-condition vec"
      (let [f (fn [x]
                {:pre []}
                (* x x))]
        (is (= 1 (f 1)))
        (is (= 100 (f 10)))
        (is (= 0 (f 0)))
        (is (= 25 (f -5)))))

    (testing "single pre-condition"
      (let [f (fn [x]
                {:pre [(pos? x)]}
                (* x x))]
        (is (= 1 (f 1)))
        (is (= 100 (f 10)))
        (is (thrown? python/AssertionError
                     (f 0)))
        (is (thrown? python/AssertionError
                     (f -5)))))

    (testing "multiple pre-condition"
      (let [f (fn [x]
                {:pre [(pos? x) (even? x)]}
                (* x x))]
        (is (= 4 (f 2)))
        (is (= 100 (f 10)))
        (is (thrown? python/AssertionError
                     (f 1)))
        (is (thrown? python/AssertionError
                     (f 0)))
        (is (thrown? python/AssertionError
                     (f -5)))
        (is (thrown? python/AssertionError
                     (f -6))))))

  (testing "post-condition only"
    (testing "empty post-condition vec"
      (let [f (fn [x]
                {:post []}
                (* x x))]
        (is (= 1 (f 1)))
        (is (= 100 (f 10)))
        (is (= 0 (f 0)))
        (is (= 25 (f -5)))))

    (testing "single post-condition"
      (let [f (fn [x]
                {:post [(> % 16)]}
                (* x x))]
        (is (= 25 (f 5)))
        (is (= 100 (f 10)))
        (is (thrown? python/AssertionError
                     (f 1)))
        (is (thrown? python/AssertionError
                     (f -3)))))

    (testing "multiple post-condition"
      (let [f (fn [x]
                {:post [(> % 16) (< % 225)]}
                (* x x))]
        (is (= 25 (f 5)))
        (is (= 25 (f -5)))
        (is (= 196 (f 14)))
        (is (thrown? python/AssertionError
                     (f 1)))
        (is (thrown? python/AssertionError
                     (f 0)))
        (is (thrown? python/AssertionError
                     (f 15)))
        (is (thrown? python/AssertionError
                     (f 100))))))

  (testing "pre- and post-conditions"
    (let [f (fn [x]
              {:pre  [(pos? x)]
               :post [(> % 16) (< % 225)]}
              (* x x))]
      (is (= 25 (f 5)))
      (is (= 196 (f 14)))
      (is (thrown? python/AssertionError
                   (f 1)))
      (is (thrown? python/AssertionError
                   (f 0)))
      (is (thrown? python/AssertionError
                   (f 15)))
      (is (thrown? python/AssertionError
                   (f 100)))
      (is (thrown? python/AssertionError
                   (f -5))))))

(defmacro ^:private variadic-fn []
  `(fn [& r#] r#))

(deftest macro-variadic-fn
  (testing "defining variadic fn with ampersand"
    (is (= '(2 3 4) ((variadic-fn) 2 3 4)))))
