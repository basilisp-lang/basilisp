(ns tests.basilisp.core-fns-test
  (:require
   [basilisp.test :refer [deftest are is testing]]))

(deftest reduce-kv-test
  (testing "reduce-kv does not execute f if no elems in coll"
    (let [a (atom false)]
      (is (= {:init true}
             (reduce-kv (fn [_ _ _]
                          (reset! a true))
                        {:init true}
                        [])))))

  (testing "reduce-kv"
    (is (= {1 :a, 2 :b, 3 :c}
           (reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2 :c 3})))))

(deftest every-pred-test
  (is (= true ((every-pred odd?) 3 5 9)))
  (is (= true ((every-pred odd? int?) 3 5 9 17)))
  (is (= false ((every-pred odd? neg? int?) -3 -2)))
  (is (= false ((every-pred odd? neg? int?) -3 -1 7)))
  (is (= false ((every-pred odd? neg? int?) -3 -1 -3.0))))

(deftest some-fn-test
  (is (= 1 ((some-fn :a) {:a 1 :c 2})))
  (is (= 1 ((some-fn :a :b) {:a 1 :c 2})))
  (is (= 2 ((some-fn :a :b :c) {:d 4} {:c 2})))
  (is (= nil ((some-fn :a :b :c) {})))
  (is (= nil ((some-fn :a :b :c) {:e 5} {:d 4})))
  (is (= nil ((some-fn :a :b :c) {:e 5 :d 4} {}))))

(deftest keep-test
  (is (= '() (keep identity [])))
  (is (= '(:a :b :c) (keep identity [:a :b :c])))
  (is (= '(:a :b :c) (keep identity [:a :b nil :c])))
  (is (= '(:a :b :c) (keep identity [:a :b nil nil :c])))
  (is (= '(:a :b :c :d) (keep identity [:a :b nil :c nil nil :d]))))

(deftest keep-indexed-test
  (let [f (fn [i v] v)]
    (is (= '() (keep-indexed f [])))
    (is (= '(:a :b :c) (keep-indexed f [:a :b :c])))
    (is (= '(:a :b :c) (keep-indexed f [:a :b nil :c])))
    (is (= '(:a :b :c) (keep-indexed f [:a :b nil nil :c])))
    (is (= '(:a :b :c :d) (keep-indexed f [:a :b nil :c nil nil :d])))))

(deftest interleave-test
  (is (= '() (interleave)))
  (is (= '(1 2 3) (interleave [1 2 3])))
  (is (= '(1 :a 2 :b 3 :c) (interleave [1 2 3] [:a :b :c])))
  (is (= '(1 :a d 2 :b e 3 :c f)
         (interleave [1 2 3] [:a :b :c] ['d 'e 'f])))
  (is (= '(1 :a d 2 :b e)
         (interleave [1 2 3] [:a :b] ['d 'e 'f]))))

(deftest distinct-test
  (are [x y] (= x (distinct y))
    '() []
    '(:a) [:a]
    '(:a :b) [:a :b]
    '(:a :b :c) [:a :b :c]
    '(:a :b :c) [:a :a :a :b :c]
    '(:a :b :c) [:a :a :a :b :c :a]))

(deftest dedupe-test
  (are [x y] (= x (dedupe y))
    '() []
    '(:a) [:a]
    '(:a :b) [:a :b]
    '(:a :b :c) [:a :b :c]
    '(:a :b :c) [:a :a :a :b :c]
    '(:a :b :c :a) [:a :a :a :b :c :a]
    '(:a :b :c :a) [:a :a :a :b :c :c :a]))

(deftest flatten-test
  (are [x y] (= x (flatten y))
    '() 1
    '() :a
    '() ""
    '() "a string"
    '(1) [1]
    '(1) [[1]]
    '(1) [[[1]]]
    '(1 2 3) [[[1]] 2 [3]]))

(deftest reverse-test
  (are [x y] (= x (reverse y))
    '() []
    '(1) [1]
    '(2 1) [1 2]
    '(1 2 3 4 5) [5 4 3 2 1]
    '(4 3 2 1) (range 1 5)))

(deftest subvec-test
  (is (= [] (subvec [] 0)))
  (is (thrown? python/IndexError (subvec [] 3)))
  (is (thrown? python/IndexError (subvec [1 2 3 4 5] 6)))
  (is (= [:l :o :w :o :r :l :d] (subvec [:h :e :l :l :o :w :o :r :l :d] 3)))
  (is (thrown? python/IndexError (subvec [:h :e :l :l :o :w :o :r :l :d] 3 12)))
  (is (= [:l :o :w :o] (subvec [:h :e :l :l :o :w :o :r :l :d] 3 7)))
  (is (thrown? python/IndexError (subvec [:h :e :l :l :o :w :o :r :l :d] 12 3))))

(deftest min-key-test
  (is (= "dsd" (max-key count "asd" "bsd" "dsd")))
  (is (= "long word" (max-key count "asd" "bsd" "dsd" "long word")))
  (is (= "long word" (max-key count "long word" "asd" "bsd" "dsd"))))

(deftest max-key-test
  (is (= "dsd" (min-key count "asd" "bsd" "dsd")))
  (is (= "dsd" (min-key count "asd" "bsd" "dsd" "long word")))
  (is (= "a" (min-key count "a" "bsd" "dsd" "long word"))))

(deftest sort-by-test
  (testing "no cmp function"
    (is (= '() (sort-by count [])))
    (is (= '([:a] [5 5] [1 2 3])
           (sort-by count [[1 2 3] [:a] [5 5]]))))

  (testing "with cmp function"
    (let [cmp (fn [v1 v2] (- v2 v1))]
      (is (= '() (sort-by count cmp [])))
      (is (= '([1 2 3] [5 5] [:a])
             (sort-by count cmp [[1 2 3] [:a] [5 5]]))))))

(deftest zipmap-test
  (are [x y z] (= x (zipmap y z))
    {} [] []
    {} [:a] []
    {} [] [1]
    {:a 1} [:a] [1]
    {:a 1 :b 2} [:a :b] [1 2]
    {:a 1 :b 2} [:a :b :c] [1 2]
    {:a 1 :b 2} [:a :b] [1 2]
    {:a 0 :b 1} [:a :b] (range)))

(deftest trampoline-test
  (let [a (atom [])]
    (trampoline (fn [v]
                  (swap! a conj :a)
                  (fn []
                    (swap! a conj :b)))
                "idiot")
    (is (= [:a :b] @a))))

(deftest replace-test
  (is (= '(This is the code ZERO ONE TWO ZERO)
         (replace '{0 ZERO, 1 ONE, 2 TWO} '(This is the code 0 1 2 0))))
  (is (= [:four :two :four :two]
         (replace {2 :two, 4 :four} [4 2 3 4 5 6 2])))
  (is (= [10 8 6]
         (replace [10 9 8 7 6] [0 2 4])))
  (is (= [:zeroth :second :fourth :zeroth]
         (replace [:zeroth :first :second :third :fourth] [0 2 4 0]))))

(deftest subs-test
  (is (= "" (subs "" 0)))
  (is (thrown? python/IndexError (subs "" 3)))
  (is (thrown? python/IndexError (subs "hello" 6)))
  (is (= "lo world" (subs "hello world" 3)))
  (is (thrown? python/IndexError (subs "hello world" 3 12)))
  (is (= "lo w" (subs "hello world" 3 7)))
  (is (thrown? python/IndexError (subs "hello world" 12 3))))
