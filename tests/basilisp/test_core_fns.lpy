(ns tests.basilisp.test-core-fns
  (:import datetime
           os
           shutil
           time)
  (:require
   [basilisp.io :as bio]
   [basilisp.set :as set]
   [basilisp.test :refer [deftest are is testing]]))

(deftest keyword-test
  (testing "name only"
    (are [res name] (= res (keyword name))
      (keyword "") ""
      :name        "name"
      :ns/name     :ns/name
      :ns/name     'ns/name)

    (are [v] (thrown? python/TypeError (keyword v))
      nil
      #'basilisp.core/map))

  (testing "name and namespace"
    (are [res ns name] (= res (keyword ns name))
      (keyword "" "") ""          ""
      :name           nil         "name"
      :ns/name        "ns"        "name"
      :dotted.ns/name "dotted.ns" "name")

    (are [ns name] (thrown? python/TypeError (keyword ns name))
      nil nil
      :kw :kw
      'sym 'sym)))

(deftest symbol-test
  (testing "name only"
    (are [res name] (= res (symbol name))
      (symbol "")        ""
      'name              "name"
      'ns/name           :ns/name
      'ns/name           'ns/name
      'basilisp.core/map #'basilisp.core/map)

    (are [v] (thrown? python/TypeError (symbol v))
      nil))

  (testing "name and namespace"
    (are [res ns name] (= res (symbol ns name))
      (symbol "" "") ""          ""
      'name           nil         "name"
      'ns/name        "ns"        "name"
      'dotted.ns/name "dotted.ns" "name")

    (are [ns name] (thrown? python/TypeError (symbol ns name))
      nil  nil
      :kw  :kw
      'sym 'sym)))

(deftest rationalize-test
  (are [res v] (= res (rationalize v))
    0    0
    0    0.0
    1    1
    1    1.0
    -1   -1
    -1   -1.0
    2    4/2
    -2   -4/2
    3/2  1.5
    -3/2 -1.5
    3/2  6/4
    -3/2 -6/4))

(deftest vary-meta-test
  (testing "with lists"
    (let [l  '(:list)
          lm (with-meta '(:list) {:list true})]
      (is (nil? (meta l)))
      (is (= {:list true} (meta lm)))

      (let [l1 (vary-meta lm assoc :tag list)]
        (is (= lm l1))
        (is (= {:list true :tag list} (meta l1)))

        (let [l2 (vary-meta l1 dissoc :list)]
          (is (= l1 l2))
          (is (= {:tag list} (meta l2)))))))

  (testing "with maps"
    (let [m {:map true}
          mm ^:map {:map true}]
      (is (nil? (meta m)))
      (is (= {:map true} (meta mm)))

      (let [m1 (vary-meta mm assoc :tag map)]
        (is (= mm m1))
        (is (= {:map true :tag map} (meta m1)))

        (let [m2 (vary-meta m1 dissoc :map)]
          (is (= m1 m2))
          (is (= {:tag map} (meta m2)))))))

  (testing "with sets"
    (let [s  #{:set}
          sm ^:set #{:set}]
      (is (nil? (meta s)))
      (is (= {:set true} (meta sm)))

      (let [s1 (vary-meta sm assoc :tag set)]
        (is (= sm s1))
        (is (= {:set true :tag set} (meta s1)))

        (let [s2 (vary-meta s1 dissoc :set)]
          (is (= s1 s2))
          (is (= {:tag set} (meta s2)))))))

  (testing "with symbols"
    (let [s  'sym
          sm (with-meta 'sym {:symbol true})]
      (is (nil? (meta s)))
      (is (= {:symbol true} (meta sm)))

      (let [s1 (vary-meta sm assoc :tag symbol)]
        (is (= sm s1))
        (is (= {:symbol true :tag symbol} (meta s1)))

        (let [s2 (vary-meta s1 dissoc :symbol)]
          (is (= s1 s2))
          (is (= {:tag symbol} (meta s2)))))))

  (testing "with vectors"
    (let [v  [:vec]
          vm ^:vector [:vec]]
      (is (nil? (meta v)))
      (is (= {:vector true} (meta vm)))

      (let [v1 (vary-meta vm assoc :tag vector)]
        (is (= vm v1))
        (is (= {:tag vector :vector true} (meta v1)))

        (let [v2 (vary-meta v1 dissoc :vector)]
          (is (= v1 v2))
          (is (= {:tag vector} (meta v2))))))))

(deftest boolean-test
  (testing "logical false values"
    (are [v] (false? (boolean v))
      false
      nil))

  (testing "logical true values"
    (are [v] (true? (boolean v))
      true
      1
      0
      -1
      1.0
      0.0
      -1.0
      ""
      "false"
      []
      [false]
      #{}
      #{false}
      {}
      {false false}
      '()
      '(false false)
      :kw
      :ns/kw
      'sym
      'ns/sym)))

(deftest compare-test
  (testing "nil"
    (are [res x y] (= res (compare x y))
      0  nil nil
      -1 nil "a"
      1  "a" nil))

  (testing "boolean"
    (are [res x y] (= res (compare x y))
      0  true  true
      0  false false
      -1 false true
      1  true  false))

  (testing "numbers"
    (are [res x y] (= res (compare x y))
      1  ##NaN nil
      -1 nil   ##NaN

      0 ##NaN ##NaN
      0 ##NaN 1
      0 ##NaN 3.14
      0 ##NaN 22/7
      0 ##NaN 3.07M
      0 3.07M ##NaN
      0 1     ##NaN
      0 3.14  ##NaN
      0 3.14  ##NaN
      0 22/7  ##NaN

      0 1    1
      0 1    1.0
      0 1    1M
      0 2    10/5
      0 1.0  1
      0 1.0  1M
      0 1.0  1.0
      0 2.0  10/5
      0 1M   1M
      0 1M   1
      0 1M   1.0
      0 2M   10/5
      0 10/5 2
      0 10/5 2.0
      0 10/5 2M
      0 10/5 10/5

      1 3     1
      1 3     1.07
      1 3     2/5
      1 3     1.07M
      1 3.33  1.07
      1 3.33  1
      1 3.33  2/5
      1 3.33  1.07M
      1 3.33M 1.07M
      1 3.33M 1
      1 3.33M 1.07
      1 3.33M 10/5
      1 10/5  1
      1 10/5  1.0
      1 10/5  1.07M
      1 10/5  2/5

      -1 1     3
      -1 1.07  3
      -1 2/5   3
      -1 1.07M 3
      -1 1.07  3.33
      -1 1     3.33
      -1 2/5   3.33
      -1 1.07M 3.33
      -1 1.07M 3.33M
      -1 1     3.33M
      -1 1.07  3.33M
      -1 10/5  3.33M
      -1 1     10/5
      -1 1.07  10/5
      -1 1.07M 10/5
      -1 2/5   10/5))

  (testing "strings"
    (are [res x y] (= res (compare x y))
      0  "a" "a"
      -1 "a" "b"
      1  "b" "a"))

  (testing "keywords"
    (are [res x y] (= res (compare x y))
      0  :a :a
      -1 :a :b
      1  :b :a

      1  :a/b :b
      -1 :b   :a/b

      -1 :a/b :a/c
      -1 :a/b :b/b
      0  :a/b :a/b
      1  :a/c :a/b
      1  :b/b :a/b))

  (testing "symbols"
    (are [res x y] (= res (compare x y))
      0  'a 'a
      -1 'a 'b
      1  'b 'a

      1  'a/b 'b
      -1 'b   'a/b

      -1 'a/b 'a/c
      -1 'a/b 'b/b
      0  'a/b 'a/b
      1  'a/c 'a/b
      1  'b/b 'a/b))

  (testing "vectors"
    (are [res x y] (= res (compare x y))
      0  []  []
      -1 []  [1]
      1  [1] []

      0  [0 1 2] [0 1 2]
      -1 [0 1 2] [1 1 2]
      1  [2 55] [1 99]
      1  [1 1 2] [0 1 2]))

  (testing "un-comparables"
    (are [x y] (thrown? python/TypeError (compare x y))
      :a  'a
      :a  "a"
      'a  "a"
      'a  :a
      "a" 'a
      "a" :a

      [] '()

      '()      '()
      '(1 2 3) '(1 2 3)
      '(1 2 3) '(4 5 6)

      #{}      #{}
      #{1 2 3} #{1 2 3}
      #{1 2 3} #{4 5 6}

      {}          {}
      {:a 1 :b 2} {:a 1 :b 2}
      {:a 1 :b 2} {:c 3 :d 4})))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(deftest fnext-test
  (is (= nil (fnext [])))
  (is (= nil (fnext [1])))
  (is (= nil (fnext [1 nil])))

  (is (= 2 (fnext [1 2])))
  (is (= [2] (fnext [1 [2] 3]))))

(deftest bounded-count-test
  (are [x n y] (= x (bounded-count n y))
    0 5 []
    0 5 '()
    0 5 {}
    0 5 #{}

    1 5 [:a]
    1 5 '(:a)
    1 5 {:a 1}
    1 5 #{:a}
    5 5 (range 5)

    4 2 [:a :b :c :d]
    2 2 '(:a :b :c :d)
    4 2 {:a 1 :b 2 :c 3 :d 4}
    4 2 #{:a :b :c :d}
    2 2 (range 5)))

(deftest not-empty-test
  (are [x] (nil? (not-empty x))
    []
    '()
    #{}
    {})
  (are [x] (= x (not-empty x))
    [:a]
    [:a :b :c]
    '(:a)
    '(:a :b :c)
    #{:a}
    #{:a :b :c}
    {:a 1}
    {:a 1 :b 2 :c :3}))

(deftest peek-test
  (are [x] (nil? (peek x))
    []
    '())
  (are [x y] (= x (peek y))
    :a '(:a)
    :a '(:a :b :c)
    :a [:a]
    :c [:a :b :c]))

(deftest pop-test
  (is (thrown? python/IndexError (pop '())))
  (is (thrown? python/IndexError (pop [])))
  (are [x y] (= x (pop y))
    '() '(:a)
    '(:b :c) '(:a :b :c)
    [] [:a]
    [:a :b] [:a :b :c]))

(deftest reverse-test
  (are [x y] (= x (reverse y))
    '() []
    '(1) [1]
    '(2 1) [1 2]
    '(1 2 3 4 5) [5 4 3 2 1]
    '(4 3 2 1) (range 1 5)))

(deftest reversible?-test
  (is (reversible? []))
  (is (reversible? [1 2 3 4]))
  (are [x] (not (reversible? x))
    '()
    '(1 2 3 4)
    #{}
    #{1 2 3 4}
    {}
    {:a 1 :b 2}))

(deftest rseq-test
  (are [x] (thrown? python/AttributeError (rseq x))
    '()
    '(1 2 3 4)
    #{}
    #{1 2 3 4}
    {}
    {:a 1 :b 2})
  (are [x y] (= x (rseq y))
    '() []
    '(1) [1]
    '(2 1) [1 2]
    '(3 2 1) [1 2 3]
    '(4 3 2 1) [1 2 3 4]
    '(:d :c :b :a) [:a :b :c :d]))

(deftest subvec-test
  (is (= [] (subvec [] 0)))
  (is (thrown? python/IndexError (subvec [] 3)))
  (is (thrown? python/IndexError (subvec [1 2 3 4 5] 6)))
  (is (= [:l :o :w :o :r :l :d] (subvec [:h :e :l :l :o :w :o :r :l :d] 3)))
  (is (thrown? python/IndexError (subvec [:h :e :l :l :o :w :o :r :l :d] 3 12)))
  (is (= [:l :o :w :o] (subvec [:h :e :l :l :o :w :o :r :l :d] 3 7)))
  (is (thrown? python/IndexError (subvec [:h :e :l :l :o :w :o :r :l :d] 12 3))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transient Collections ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(deftest transient-map-test
  (testing "always boolean true"
    (are [x] (true? (boolean (transient x)))
      {}
      {:a 1 :c 2}))

  (testing "callable"
    (are [x y z] (= z ((transient x) y))
      {}          :a nil
      {:a 1 :c 2} :a 1)

    (is (= :e ((transient {:a 1 :b 2}) :c :e))))

  (testing "count"
    (let [trx (volatile! (transient {:a 1 :b 2 :c 3}))]
      (is (= 3 (count @trx)))
      (vswap! trx dissoc! :b)
      (is (= 2 (count @trx)))
      (vswap! trx assoc! :e 5 :f 6)
      (is (= 4 (count @trx)))))

  (testing "equality"
    (let [src {:a 1 :b 2}
          trx (transient src)]
      (is (not (= src trx)))
      (is (not (= trx src)))
      (is (not (= trx (transient src))))
      (is (= trx trx))

      (let [prx (persistent! trx)]
        (is (= src prx))
        (is (not (identical? src prx))))))

  (testing "get"
    (are [x y z] (= z (get (transient x) y))
      {}          :a nil
      {:a 1 :c 2} :a 1)

    (is (= :e (get (transient {:a 1 :b 2}) :c :e))))

  (testing "not seqable"
    (is (thrown? python/TypeError (seq (transient {}))))))

(deftest transient-set-test
  (testing "always boolean true"
    (are [x] (true? (boolean (transient x)))
      #{}
      #{:a :b :c}))

  (testing "callable"
    (are [x y z] (= z ((transient x) y))
      #{}         :a nil
      #{:a :b :c} :a :a)

    (is (= :e ((transient #{:a :b :c}) :d :e))))

  (testing "count"
    (let [trx (volatile! (transient #{:a :b :c}))]
      (is (= 3 (count @trx)))
      (vswap! trx disj! :b)
      (is (= 2 (count @trx)))
      (vswap! trx conj! :e :f)
      (is (= 4 (count @trx)))))

  (testing "equality"
    (let [src #{:a :b :c}
          trx (transient src)]
      (is (not (= src trx)))
      (is (not (= trx src)))
      (is (not (= trx (transient src))))
      (is (= trx trx))

      (let [prx (persistent! trx)]
        (is (= src prx))
        (is (not (identical? src prx))))))

  (testing "get"
    (are [x y z] (= z (get (transient x) y))
      #{}         :a nil
      #{:a :b :c} :a :a)

    (is (= :e (get (transient #{:a :b :c}) :d :e))))

  (testing "not seqable"
    (is (thrown? python/TypeError (seq (transient #{}))))))

(deftest transient-vector-test
  (testing "always boolean true"
    (are [x] (true? (boolean (transient x)))
      []
      [:a :b :c]))

  (testing "count"
    (let [trx (volatile! (transient [:a :b :c]))]
      (is (= 3 (count @trx)))
      (vswap! trx pop!)
      (is (= 2 (count @trx)))
      (vswap! trx conj! :e :f)
      (is (= 4 (count @trx)))))

  (testing "equality"
    (let [src [:a :b :c]
          trx (transient src)]
      (is (not (= src trx)))
      (is (not (= trx src)))
      (is (not (= trx (transient src))))
      (is (= trx trx))

      (let [prx (persistent! trx)]
        (is (= src prx))
        (is (not (identical? src prx))))))

  (testing "get"
    (are [x y z] (= z (get (transient x) y))
      []         1  nil
      [:a :b :c] 1 :b)

    (is (= :e (get (transient [:a :b :c]) 4 :e))))

  (testing "not seqable"
    (is (thrown? python/TypeError (seq (transient []))))))

(deftest assoc!-test
  (testing "maps"
    (let [tm (transient {})]
      (is (= {:a 1 :b 2 :c 3}
             (-> (assoc! tm :a 1)
                 (assoc! :b 2 :c 3)
                 (persistent!))))))

  (testing "vectors"
    (let [tv (transient [:a :b :c])]
      (is (= [:c :a :b :d]
             (-> (assoc! tv 0 :c)
                 (assoc! 1 :a 2 :b)
                 (assoc! 3 :d)
                 (persistent!)))))))

(deftest conj!-test
  (is (= [] (persistent! (conj!))))

  (testing "maps"
    (let [tm (transient {})]
      (is (= {:a 1 :b 2 :c 3 :d 4 :e 5}
             (-> (conj! tm {:a 1})
                 (conj! {:a 1} #py {:b 2})
                 (conj! [:c 3] nil (map-entry :d 4))
                 (conj! #py (:e 5))
                 (persistent!)))))

    (is (thrown? python/ValueError (conj! (transient {}) :a))))

  (testing "sets"
    (let [ts (transient #{:a :b :c})]
      (is (= #{:a :b :c :d :e :f}
             (-> (conj! ts :a)
                 (conj! :c :d)
                 (conj! :e :f)
                 (persistent!))))))

  (testing "vectors"
    (let [ts (transient [:a])]
      (is (= [:a :a :c :d :e :f]
             (-> (conj! ts :a)
                 (conj! :c :d)
                 (conj! :e :f)
                 (persistent!)))))))

(deftest disj!-test
  (is (= #{:a} (persistent! (disj! (transient #{:a})))))

  (let [ts (transient #{:a :b :c})]
    (is (= #{:c} (-> (disj! ts :e)
                     (disj! :b)
                     (disj! :a :g)
                     (persistent!))))))

(deftest dissoc!-test
  (let [tm (transient {:a 1 :b 2 :c 3})]
    (is (= {:c 3} (-> (dissoc! tm :e)
                      (dissoc! :b)
                      (dissoc! :a :g)
                      (persistent!))))))

(deftest pop!-test
  (let [tv (transient [:a :b :c])]
    (is (= [:a] (-> (pop! tv)
                    (pop!)
                    (persistent!)))))

  (is (thrown? python/IndexError (pop! (transient [])))))

;;;;;;;;;;;;;;;
;; Volatiles ;;
;;;;;;;;;;;;;;;

(deftest volatile-test
  (let [v (volatile! :a)]
    (is (not (volatile? :a)))
    (is (not (volatile? (atom :a))))
    (is (volatile? v))
    (is (= :a @v))
    (is (= :b (vreset! v :b)))
    (is (= :b @v))
    (is (= :b/a (vswap! v #(keyword (name %) "a"))))
    (is (= :b/a @v))))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transducer Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

(deftest reduced-test
  (is (not (reduced? [])))
  (is (reduced? (reduced [])))
  (is (= [] @(reduced [])))

  (testing "ensure-reduced"
    (is (reduced? (ensure-reduced [])))
    (is (reduced? (ensure-reduced (reduced []))))
    (is (not (reduced? @(ensure-reduced (reduced []))))))

  (testing "unreduced"
    (is (not (reduced? (unreduced (reduced [])))))
    (is (= [] (unreduced (reduced []))))))

;;;;;;;;;;;;;;;;;;;;
;; Lazy Sequences ;;
;;;;;;;;;;;;;;;;;;;;

(def primes
  (remove
   (fn [x] (some #(zero? (mod x %)) primes))
   (iterate inc 2)))

(deftest lazy-seq-test
  (testing "is collection"
    (are [x] (coll? x)
      (lazy-seq)
      (empty (lazy-seq))
      (cons nil (lazy-seq))
      (cons nil (empty (lazy-seq)))
      (empty (cons nil (lazy-seq)))))

  (testing "conj"
    (are [expected form] (= expected form)
      '()          (lazy-seq)
      '()          (conj (lazy-seq))
      '(0 1 2)     (conj (lazy-seq '(2)) 1 0)
      '(0 1 2)     (conj (conj (lazy-seq '(2)) 1) 0)
      '(1 2 3)     (conj (lazy-seq) 3 2 1)
      '(0 1 2 3 4) (conj (lazy-seq '(1 2 3 4)) 0)))

  (testing "corecursion"
    ;; here we're just generally checking that we don't blow the stack, so
    ;; 50 is an arbitrarily chosen limit which hopefully tests that adequately
    (is (= '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229)
           (take 50 primes)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher Order and Collection Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(deftest run!-test
  (testing "empty collection"
    (let [a (atom 0)]
      (run! #(swap! a + %) [])
      (is (= @a 0))))

  (testing "non-empty collection"
    (let [a (atom 0)]
      (run! #(swap! a + %) (range 5))
      (is (= @a 10)))))

(deftest partial-test
  (testing "no arguments"
    (let [f-no-args (fn [] :no-args)]
      (is (identical? f-no-args (partial f-no-args)))))

  (testing "with arguments"
    (let [f ^{:meta-tag :value}
          (fn
            ([] :no-args)
            ([a b] [a b])
            ([a b c d & rest]
             [a b c d rest]))]
      (is (= #{0 2 4 :rest} (.-arities f)))
      (is (= {:meta-tag :value} (meta f)))

      (let [new-f      (partial f :a)
            new-f-meta (with-meta new-f {:different-tag :yes})]
        (is (= #{1 3 :rest} (.-arities new-f)))
        (is (nil? (meta new-f)))
        (is (= {:different-tag :yes} (meta new-f-meta)))
        (is (= [:a :c] (new-f-meta :c)))

        (let [partial-of-partial (partial new-f-meta :b)]
          (is (= #{2 :rest} (.-arities partial-of-partial)))
          (is (nil? (meta partial-of-partial)))
          (is (= [:a :b :e :f '(:g :h)] (partial-of-partial :e :f :g :h))))))))

(deftest reduce-test
  (testing "with no init"
    (are [coll f res] (= res (reduce f coll))
      nil                               + 0
      []                                + 0
      [1]                               + 1
      [1 2 3]                           + 6
      (filter odd? [1 2 3 4 5 6 7 8 9]) + 25))

  (testing "with an init"
    (are [coll f init res] (= res (reduce f init coll))
      nil                               + 45 45
      []                                + 45 45
      [1]                               + 45 46
      [1 2 3]                           + 45 51
      (filter odd? [1 2 3 4 5 6 7 8 9]) + 25 50))

  (testing "return early"
    (let [f (fn []
              (let [idx (volatile! 0)]
                (fn
                  ([x] x)
                  ([x y]
                   (let [new-idx (vswap! idx inc)]
                     (if (> new-idx 3)
                       (reduced x)
                       (+ x y)))))))]
      (is (= 6 (reduce (f) (range))))
      (is (= 9 (reduce (f) 6 (range)))))))

(deftest reduce-kv-test
  (testing "reduce-kv does not execute f if no elems in coll"
    (let [a (atom false)]
      (is (= {:init true}
             (reduce-kv (fn [_ _ _]
                          (reset! a true))
                        {:init true}
                        [])))))

  (testing "reduce-kv"
    (is (= {1 :a, 2 :b, 3 :c}
           (reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2 :c 3}))))

  (testing "return early"
    (let [idx (volatile! 0)
          f   (fn
                [m k v]
                (let [new-idx (vswap! idx inc)]
                  (if (> new-idx 3)
                    (reduced m)
                    (assoc m k v))))]
      (is (= 3 (count (reduce-kv f {} {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6}))))))

  (testing "works on vectors as well"
    (is (= {:ks [0 1 2] :vs [:a :b :c]}
           (reduce-kv
             (fn [acc i v]
               (-> acc
                   (update :ks conj i)
                   (update :vs conj v)))
             {:ks [] :vs []}
             [:a :b :c])))))

(deftest fnil-test
  (let [f (fnil (fn [x] x) :yes)]
    (is (= :yes (f nil)))
    (is (= :no (f :no))))

  (let [f (fnil (fn [x y] [x y]) :yes :no)]
    (is (= [:yes :yes] (f nil :yes)))
    (is (= [:no :no] (f :no nil)))
    (is (= [:yes :no] (f nil nil))))

  (let [f (fnil (fn [x y z] [x y z]) :yes :no :maybe)]
    (is (= [:yes :yes :yes] (f nil :yes :yes)))
    (is (= [:yes :no :yes] (f nil nil :yes)))
    (is (= [:no :no :no] (f :no nil :no)))
    (is (= [:no :no :maybe] (f :no nil nil)))
    (is (= [:maybe :maybe :maybe] (f :maybe :maybe nil)))
    (is (= [:yes :maybe :maybe] (f nil :maybe nil)))
    (is (= [:yes :no :maybe] (f nil nil nil))))

  (let [f (fnil (fn [x & rest] [x rest]) :a)]
    (is (= [:a '(:b :c)] (f nil :b :c))))

  (let [f (fnil (fn [x y & rest] [x y rest]) :a :b)]
    (is (= [:a :b '(:c :d)] (f nil nil :c :d))))

  (let [f (fnil (fn [x y z & rest] [x y z rest]) :a :b :c)]
    (is (= [:a :b :c '(:d :e)] (f nil nil nil :d :e)))))

(deftest every-pred-test
  (is (= true ((every-pred odd?) 3 5 9)))
  (is (= true ((every-pred odd? int?) 3 5 9 17)))
  (is (= false ((every-pred odd? neg? int?) -3 -2)))
  (is (= false ((every-pred odd? neg? int?) -3 -1 7)))
  (is (= false ((every-pred odd? neg? int?) -3 -1 -3.0))))

(deftest some-fn-test
  (is (= 1 ((some-fn :a) {:a 1 :c 2})))
  (is (= 1 ((some-fn :a :b) {:a 1 :c 2})))
  (is (= 2 ((some-fn :a :b :c) {:d 4} {:c 2})))
  (is (= nil ((some-fn :a :b :c) {})))
  (is (= nil ((some-fn :a :b :c) {:e 5} {:d 4})))
  (is (= nil ((some-fn :a :b :c) {:e 5 :d 4} {}))))

(deftest map-test
  (testing "transducer"
    (are [res input] (= res (into [] (map inc) input))
      []           []
      [6 7 8 9 10] (range 5 10))

    (is (= '([1 4] [2 5] [3 6])
           (vec (sequence (map vector) [1 2 3] [4 5 6])))))

  (testing "higher order function"
    (are [res s] (= res s)
      '()      (map identity [])
      '(1 2 3) (map identity [1 2 3])
      '(2 3 4) (map inc [1 2 3])
      '(5 7 9) (map + [1 2 3] [4 5 6])
      '(5 7 9) (map + [1 2 3] (range 4 10)))))

(deftest map-indexed-test
  (testing "transducer"
    (= [[0 1] [1 2] [2 3]]
       (into [] (map-indexed vector) [1 2 3])))

  (testing "higher order function"
    (is (= '([0 1] [1 2] [2 3]) (map-indexed vector [1 2 3])))))

(deftest mapcat-test
  (testing "transducer"
    (are [res input] (= res (into [] (mapcat #(vector % (inc %))) input))
      []            []
      [1 2 2 3 3 4] [1 2 3])

    #_(is (= '(1 4 7 2 5 8 3 6 9)
           (sequence (mapcat vector) [1 2 3] [4 5 6] [7 8 9]))))

  (testing "higher order function"
    (are [res input] (= res (mapcat #(vector % (inc %)) input))
      '()            []
      '(1 2 2 3 3 4) [1 2 3])

    (is (= [1 4 2 5 3 6] (mapcat vector [1 2 3] [4 5 6])))))

(deftest filter-test
  (testing "transducer"
    (are [res f input] (= res (into [] (filter f) input))
      [1 3 5] odd? [1 2 3 4 5]
      [1 3 5] odd? [1 2 3 4 5 6]))

  (testing "higher order function"
    (are [res f input] (= res (filter f input))
      '()        identity []
      '(1 2 3 4) identity [1 2 3 4]
      '(1 3)     odd?     [1 2 3 4]
      '(1 3 5)   odd?     [1 2 3 4 5])))

(deftest remove-test
  (testing "transducer"
    (are [res f input] (= res (into [] (remove f) input))
      [2 4]   odd? [1 2 3 4 5]
      [2 4 6] odd? [1 2 3 4 5 6]))

  (testing "higher order function"
    (are [res f input] (= res (remove f input))
      '()      identity []
      '()      identity [1 2 3 4]
      '(2 4)   odd?     [1 2 3 4]
      '(2 4 6) odd?     [1 2 3 4 5 6])))

(deftest keep-test
  (let [transform (fn [x] (when x (-> x name symbol)))]
    (testing "transducer"
      (are [res input] (= res (into [] (keep transform) input))
        '[]        []
        '[a b c]   [:a :b :c]
        '[a b c]   [:a :b nil :c]
        '[a b c]   [:a :b nil nil :c]
        '[a b c d] [:a :b nil :c nil nil :d]))

    (testing "higher order function"
      (are [res input] (= res (keep transform input))
        '()        []
        '(a b c)   [:a :b :c]
        '(a b c)   [:a :b nil :c]
        '(a b c)   [:a :b nil nil :c]
        '(a b c d) [:a :b nil :c nil nil :d]))

    (testing "lazy"
      (let [counter (atom 0)
            vals    (keep (partial swap! counter +) (repeat 1 10))]
        (is (= 0 @counter))
        (seq vals)
        (is (= 10 @counter))))))

(deftest keep-indexed-test
  (let [f (fn [i x] (when x [i (-> x name symbol)]))]
    (testing "transducer"
      (are [res input] (= res (into [] (keep-indexed f) input))
        '[]                        []
        '[[0 a] [1 b] [2 c]]       [:a :b :c]
        '[[0 a] [1 b] [3 c]]       [:a :b nil :c]
        '[[0 a] [1 b] [4 c]]       [:a :b nil nil :c]
        '[[0 a] [1 b] [3 c] [6 d]] [:a :b nil :c nil nil :d]))

    (testing "higher order function"
      (are [res input] (= res (keep-indexed f input))
        '()                        []
        '([0 a] [1 b] [2 c])       [:a :b :c]
        '([0 a] [1 b] [3 c])       [:a :b nil :c]
        '([0 a] [1 b] [4 c])       [:a :b nil nil :c]
        '([0 a] [1 b] [3 c] [6 d]) [:a :b nil :c nil nil :d]))

    (testing "lazy"
      (let [counter (atom 0)
            vals    (keep-indexed (fn [i x] (swap! counter + x)) (repeat 1 10))]
        (is (= 0 @counter))
        (seq vals)
        (is (= 10 @counter))))))

(deftest take-test
  (testing "transducer"
    (are [res n input] (= res (into [] (take n) input))
      []      3 []
      []      0 [1 2 3]
      [1]     1 [1 2 3]
      [1 2]   2 [1 2 3]
      [1 2 3] 3 [1 2 3]))

  (testing "higher order function"
    (are [res n input] (= res (take n input))
      '()      3 []
      '()      0 [1 2 3]
      '(1)     1 [1 2 3]
      '(1 2)   2 [1 2 3]
      '(1 2 3) 3 [1 2 3])))

(deftest take-while-test
  (testing "transducer"
    (are [res f input] (= res (into [] (take-while f) input))
      []        odd?  []
      []        even? [1 3 5 7]
      []        odd?  [2 3 5 7]
      [1 3 5]   odd?  [1 3 5 2]
      [1 3 5 7] odd?  [1 3 5 7]
      [1]       odd?  [1 2 3 4]))

  (testing "higher order function"
    (are [res f input] (= res (take-while f input))
      '()        odd?  []
      '()        even? [1 3 5 7]
      '()        odd?  [2 3 5 7]
      '(1 3 5)   odd?  [1 3 5 2]
      '(1 3 5 7) odd?  [1 3 5 7]
      '(1)       odd?  [1 2 3 4])))

(deftest drop-test
  (testing "transducer"
    (are [res n input] (= res (into [] (drop n) input))
      []      3 []
      []      3 [1 2 3]
      [1 2 3] 0 [1 2 3]
      [2 3]   1 [1 2 3]
      [3]     2 [1 2 3]
      [4]     3 [1 2 3 4]))

  (testing "higher order function"
    (are [res n input] (= res (drop n input))
      '()      3 []
      '()      3 [1 2 3]
      '(1 2 3) 0 [1 2 3]
      '(2 3)   1 [1 2 3]
      '(3)     2 [1 2 3]
      '(4)     3 [1 2 3 4])))

(deftest drop-while-test
  (testing "transducer"
    (are [res input] (= res (into [] (drop-while odd?) input))
      []        []
      []        [1 3 5 7]
      [2]       [1 3 5 2]
      [2 3 4]   [1 2 3 4]
      [2 4 6 8] [2 4 6 8]))

  (testing "higher order function"
    (are [res input] (= res (drop-while odd? input))
      '()        []
      '()        [1 3 5 7]
      '(2)       [1 3 5 2]
      '(2 3 4)   [1 2 3 4]
      '(2 4 6 8) [2 4 6 8])))

(deftest take-nth-test
  (testing "transducer"
    (are [res n input] (= res (into [] (take-nth n) input))
      []          0 []
      [1]         0 [1]
      [1]         0 [1 2 3]
      [1 2 3 4 5] 1 [1 2 3 4 5]
      [1 3 5]     2 [1 2 3 4 5]
      [1 4]       3 [1 2 3 4 5]))

  (testing "higher order function"
    (are [res input] (= res (take 1 (take-nth 0 input)))
      '()  []
      '(1) [1]
      '(1) [1 2 3])
    (are [res n input] (= res (take-nth n input))
      '(1 2 3 4 5) 1 [1 2 3 4 5]
      '(1 3 5)     2 [1 2 3 4 5]
      '(1 4)       3 [1 2 3 4 5])))

(deftest frequencies-test
  (are [res input] (= res (frequencies input))
    {}               '()
    {}               []
    {:a 1}           '(:a)
    {:a 1}           [:a]
    {:a 3 :b 1}      '(:a :a :a :b)
    {:a 3 :b 1}      [:a :a :a :b]
    {:a 4 :b 1 :c 2} '(:a :a :a :b :c :c :a)
    {:a 4 :b 1 :c 2} [:a :a :a :b :c :c :a]))

(deftest interpose-test
  (testing "transducer"
    (are [input sep res] (= res (into [] (interpose sep) input))
      []             "," []
      ["hi"]         "," ["hi"]
      ["hi" "there"] "," ["hi" "," "there"]))

  (testing "higher order function"
    (are [input sep res] (= res (interpose sep input))
      []             "," '()
      ["hi"]         "," '("hi")
      ["hi" "there"] "," '("hi" "," "there"))))

(deftest interleave-test
  (is (= '() (interleave)))
  (is (= '(1 2 3) (interleave [1 2 3])))
  (is (= '(1 :a 2 :b 3 :c) (interleave [1 2 3] [:a :b :c])))
  (is (= '(1 :a d 2 :b e 3 :c f)
         (interleave [1 2 3] [:a :b :c] ['d 'e 'f])))
  (is (= '(1 :a d 2 :b e)
         (interleave [1 2 3] [:a :b] ['d 'e 'f]))))

(deftest partition-all-test
  (testing "transducer"
    (are [res input] (= res (into [] (partition-all 3) input))
      [[1]]                 [1]
      [[0 1 2] [3 4 5]]     (range 6)
      [[0 1 2] [3 4 5] [6]] (range 7)))

  (testing "no step"
    (are [res n coll] (= res (partition-all n coll))
      '((1 2) (3 4) (5 6)) 2 (range 1 7)
      '((1 2 3) (4 5 6))   3 (range 1 7)))

  (testing "with step"
    (are [res n step coll] (= res (partition-all n step coll))
      '((1 2 3 4 5) (11 12 13 14 15) (21 22 23)) 5 10 (range 1 24)
      '((1 2 3 4 5) (11 12 13 14 15) (21 22 23 24 25) 5 10 (range 1 26)))))

(deftest partition-by-test
  (testing "transducer"
    (are [res input] (= res (into [] (partition-by odd?) input))
      [[1]]                 [1]
      [[1 3 5 7 9 11]]      [1 3 5 7 9 11]
      [[1 1 1] [2 2] [3 3]] [1 1 1 2 2 3 3]))

  (testing "higher order function"
    (are [res coll] (= res (partition-by odd? coll))
      '()                    []
      '((1 1 1) (2 2) (3 3)) [1 1 1 2 2 3 3])))

(deftest distinct-test
  (testing "transducer"
    (are [res input] (= res (into [] (distinct) input))
      []         []
      [:a]       [:a]
      [:a :b]    [:a :b]
      [:a :b :c] [:a :b :c]
      [:a :b :c] [:a :a :a :b :c]
      [:a :b :c] [:a :a :a :b :c :a]))

  (testing "higher order function"
    (are [res input] (= res (distinct input))
      '()         []
      '(:a)       [:a]
      '(:a :b)    [:a :b]
      '(:a :b :c) [:a :b :c]
      '(:a :b :c) [:a :a :a :b :c]
      '(:a :b :c) [:a :a :a :b :c :a])))

(deftest dedupe-test
  (testing "transducer"
    (are [res input] (= res (into [] (dedupe) input))
      []            []
      [:a]          [:a]
      [:a :b]       [:a :b]
      [:a :b :c]    [:a :b :c]
      [:a :b :c]    [:a :a :a :b :c]
      [:a :b :c :a] [:a :a :a :b :c :a]
      [:a :b :c :a] [:a :a :a :b :c :c :a]))

  (testing "higher order function"
    (are [res input] (= res (dedupe input))
      '()            []
      '(:a)          [:a]
      '(:a :b)       [:a :b]
      '(:a :b :c)    [:a :b :c]
      '(:a :b :c)    [:a :a :a :b :c]
      '(:a :b :c :a) [:a :a :a :b :c :a]
      '(:a :b :c :a) [:a :a :a :b :c :c :a])))

(deftest flatten-test
  (are [x y] (= x (flatten y))
    '() 1
    '() :a
    '() ""
    '() "a string"
    '(1) [1]
    '(1) [[1]]
    '(1) [[[1]]]
    '(1 2 3) [[[1]] 2 [3]]))

(deftest take-last-test
  (are [res n coll] (= res (take-last n coll))
    [:c :d] 2  [:a :b :c :d]
    [:a]    2  [:a]
    nil     2  []
    nil     2  nil
    nil     0  [:a]
    nil     -1 [:a]))

(deftest min-key-test
  (is (= "dsd" (max-key count "asd" "bsd" "dsd")))
  (is (= "long word" (max-key count "asd" "bsd" "dsd" "long word")))
  (is (= "long word" (max-key count "long word" "asd" "bsd" "dsd"))))

(deftest max-key-test
  (is (= "dsd" (min-key count "asd" "bsd" "dsd")))
  (is (= "dsd" (min-key count "asd" "bsd" "dsd" "long word")))
  (is (= "a" (min-key count "a" "bsd" "dsd" "long word"))))

(deftest sort-test
  (testing "no cmp function"
    (is (= '() (sort [])))
    (is (= '(1 2 3 4 5) (sort [5 3 4 1 2])))
    (is (= '([:a] [5 5] [1 2 3])
           (sort [[1 2 3] [:a] [5 5]]))))

  (testing "with cmp function"
    (let [cmp (fn [v1 v2] (< v2 v1))]
      (is (= '() (sort cmp [])))
      (is (= '([1 2 3] [5 5] [:a])
             (sort cmp [[1 2 3] [:a] [5 5]]))))

    ;; taken from clojuredocs
    (is (= '(:d :c :b :a) (sort #(compare %2 %1) '(:a :b :c :d)))))

  (testing "sorting vectors"
    (are [res v] (= res (sort v))
      '([1] [3] [1 2]) [[1] [1 2] [3]]
      '([1] [1 2] [1 3]) [[1 3] [1] [1 2]]
      '([1] [0 1] [0 1]) [[0 1] [1] [0 1] ]))

  (testing "sorting sequences"
    (are [res v] (= res (sort v))
      '() (seq [])
      '(1 2 3) (seq [2 3 1])))

  (testing "sorting maps"
    (are [res v] (= res (sort v))
      '() {}
      '([:3 18] [:5 28] [:9 23]) {:9 23 :3 18 :5 28})))

(deftest sort-by-test
  (testing "no cmp function"
    (is (= '() (sort-by count [])))
    (is (= '([:a] [5 5] [1 2 3])
           (sort-by count [[1 2 3] [:a] [5 5]]))))

  (testing "with cmp function"
    (let [cmp (fn [v1 v2] (- v2 v1))]
      (is (= '() (sort-by count cmp [])))
      (is (= '([1 2 3] [5 5] [:a])
             (sort-by count cmp [[1 2 3] [:a] [5 5]])))))

  (testing "sorting vectors"
    (are [res v] (= res (sort-by identity v))
      '([1] [3] [1 2]) [[1] [1 2] [3]]
      '([1] [1 2] [1 3]) [[1 3] [1] [1 2]]
      '([1] [0 1] [0 1]) [[0 1] [1] [0 1] ])

    ;; taken from clojuredocs
    (is (= '([1 2] [2 2] [2 3]) (sort-by first [[1 2] [2 2] [2 3]])))
    (is (= '([2 2] [2 3] [1 2]) (sort-by first > [[1 2] [2 2] [2 3]]) )))

  (testing "sorting seqs"
    (are [res v] (= res (sort-by second > v))
      '() (seq [])
      '([1 7] [3 4] [2 1]) (seq [[2 1] [3 4] [1 7]])))

  (testing "sorting maps"
    (are [res v] (= res (sort-by identity v))
      '() {}
      '([:3 18] [:5 28] [:9 23]) {:9 23 :3 18 :5 28})

    ;; taken from clojuredocs
    (is (= '({:rank 1} {:rank 2} {:rank 3}) (sort-by :rank [{:rank 2} {:rank 3} {:rank 1}])))
    (let [x [{:foo 2 :bar 11}
             {:bar 99 :foo 1}
             {:bar 55 :foo 2}
             {:foo 1 :bar 77}]
          order [55 77 99 11]]
      (is (= '({:foo 1, :bar 77} {:bar 99, :foo 1} {:foo 2, :bar 11} {:bar 55, :foo 2})
             (sort-by (juxt :foo :bar) x)))
      (is (= '({:bar 55, :foo 2} {:foo 1, :bar 77} {:bar 99, :foo 1} {:foo 2, :bar 11})
             (sort-by
              #((into {} (map-indexed (fn [i e] [e i]) order)) (:bar %))
              x))))
    (is (= '([:foo 7] [:baz 5] [:bar 3]) (sort-by val > {:foo 7, :bar 3, :baz 5})))
    (is (= '({:value 1, :label "a"} {:value 2, :label "b"} {:value 3, :label "c"})
           (sort-by :value [{:value 1 :label "a"} {:value 3 :label "c"} {:value 2 :label "b"}])))
    (is (= '({:value 3 :label "c"} {:value 2, :label "b"} {:value 1, :label "a"})
           (sort-by :value #(> %1 %2) [{:value 1 :label "a"} {:value 3 :label "c"} {:value 2 :label "b"}])))
    (is (= '({:label "c"} {:value 1, :label "a"} {:value 2, :label "b"})
           (sort-by :value [{:value 1 :label "a"} {:label "c"} {:value 2 :label "b"}])))))

(deftest zipmap-test
  (are [x y z] (= x (zipmap y z))
    {} [] []
    {} [:a] []
    {} [] [1]
    {:a 1} [:a] [1]
    {:a 1 :b 2} [:a :b] [1 2]
    {:a 1 :b 2} [:a :b :c] [1 2]
    {:a 1 :b 2} [:a :b] [1 2]
    {:a 0 :b 1} [:a :b] (range)))

(deftest merge-with-test
  (is (= nil (merge-with conj)))
  (is (= nil (merge-with str nil)))
  (is (= {:a 0 :b "235" :c "46" :d 7 :z 8} (merge-with str {:a 0 :b 2} {:b 3 :c 4 :z 8} {:b 5 :c 6 :d 7})))
  (is (= {:a 0 :b [2 5] :c 7} (merge-with conj {:a 0 :b [2]} nil {:b 5 :c 7}))))

(deftest trampoline-test
  (let [a (atom [])]
    (trampoline (fn [v]
                  (swap! a conj :a)
                  (fn []
                    (swap! a conj :b)))
                "idiot")
    (is (= [:a :b] @a))))

(deftest tree-seq-test
  (are [res branch? children root] (= res (tree-seq branch? children root))
    '(((1 2 (3)) (4)) (1 2 (3)) 1 2 (3) 3 (4) 4)                             seq? identity '((1 2 (3)) (4))
    '((:A (:B (:D) (:E)) (:C (:F))) (:B (:D) (:E)) (:D) (:E) (:C (:F)) (:F)) next rest     '(:A (:B (:D) (:E)) (:C (:F)))))

(deftest memoize-test
  (testing "single args"
    (let [m1 (memoize (fn [a] (str a (random-uuid))))
          a1 (m1 :a)
          a2 (m1 :b)
          an (m1 nil)]
      (is (= a1 (m1 :a)))
      (is (= a2 (m1 :b)))
      (is (= an (m1 nil)))
      (is (distinct? a1 a2 an))))

  (testing "variadic"
    (let [m1 (memoize (fn [& more] (str more (random-uuid))))
          a0 (m1)
          a1 (m1 :a)
          a2 (m1 :a '(xyz))
          an (m1 nil)]
      (is (= a0 (m1)))
      (is (= a1 (m1 :a)))
      (is (= a2 (m1 :a '(xyz))))
      (is (= an (m1 nil)))
      (is (distinct? a0 a1 a2 an)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Associative Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(deftest replace-test
  (testing "transducer"
    (are [smap input res] (= res (into [] (replace smap) input))
      '{0 ZERO, 1 ONE, 2 TWO}                 '(This is the code 0 1 2 0) '[This is the code ZERO ONE TWO ZERO]
      {2 :two, 4 :four}                       [4 2 3 4 5 6 2]             [:four :two 3 :four 5 6 :two]
      [10 9 8 7 6]                            [0 2 4]                     [10 8 6]
      [:zeroth :first :second :third :fourth] [0 2 4 0]                   [:zeroth :second :fourth :zeroth]))

  (testing "higher order function"
    (are [smap input res] (= res (replace smap input))
      '{0 ZERO, 1 ONE, 2 TWO}                 '(This is the code 0 1 2 0) '(This is the code ZERO ONE TWO ZERO)
      {2 :two, 4 :four}                       [4 2 3 4 5 6 2]             [:four :two 3 :four 5 6 :two]
      [10 9 8 7 6]                            [0 2 4]                     [10 8 6]
      [:zeroth :first :second :third :fourth] [0 2 4 0]                   [:zeroth :second :fourth :zeroth])))

(deftest update-keys-test
  (are [res start] (and (= res (update-keys start name))
                        (= (meta res) (meta start)))
    {}                                             {}
    ^:cool {}                                      ^:cool {}
    {"a" "a"}                                      {:a "a"}
    ^:neat {"a" "a"}                               ^:neat {:a "a"}
    {"a" "a" "b" 2}                                {:a "a" 'b 2}
    ^{:good :yes :great :also-yes} {"a" "a" "b" 2} ^{:good :yes :great :also-yes} {:a "a" 'b 2}))

(deftest update-vals-test
  (are [res start] (and (= res (update-vals start #(cond-> % (string? %) (.upper))))
                        (= (meta res) (meta start)))
    {}                                           {}
    ^:cool {}                                    ^:cool {}
    {:a "A"}                                     {:a "a"}
    ^:neat {:a "A"}                              ^:neat {:a "a"}
    {:a "A" 'b 2}                                {:a "a" 'b 2}
    ^{:good :yes :great :also-yes} {:a "A" 'b 2} ^{:good :yes :great :also-yes} {:a "a" 'b 2}))

;;;;;;;;;;;;;;;;;;;;;;
;; String Functions ;;
;;;;;;;;;;;;;;;;;;;;;;

(deftest str-test
  (is (= "" (str nil)))
  (is (= "ab" (str "a" nil "b"))))

(deftest subs-test
  (is (= "" (subs "" 0)))
  (is (thrown? python/IndexError (subs "" 3)))
  (is (thrown? python/IndexError (subs "hello" 6)))
  (is (= "lo world" (subs "hello world" 3)))
  (is (thrown? python/IndexError (subs "hello world" 3 12)))
  (is (= "lo w" (subs "hello world" 3 7)))
  (is (thrown? python/IndexError (subs "hello world" 12 3))))

;;;;;;;;;;;;;
;; Futures ;;
;;;;;;;;;;;;;

(def ^:dynamic *thread-value* 4)

(deftest futures-test
  (testing "successful future"
    (let [fut (future 1)]
      (is (= 1 @fut))
      (is (= 1 @fut))
      (is (= false (future-cancel fut)))
      (is (= false (future-cancelled? fut)))
      (is (= true (future-done? fut)))
      (is (= true (realized? fut)))))

  (testing "timed deref of future"
    (let [fut (future (time/sleep 3))]
      (is (= :timed-out (deref fut 0.01 :timed-out)))
      (is (= false (future-cancelled? fut)))
      (is (= false (future-done? fut)))
      ;; can't always cancel a sleep-ed Future
      (future-cancel fut)))

  (testing "binding conveyance"
    (let [fut (future *thread-value*)]
      (is (= 4 @fut)))

    (let [fut (binding [*thread-value* 3]
                (future *thread-value*))]
      (is (= 3 @fut)))))

(deftest pmap-test
  (binding [*pmap-cpu-count* 2]
    (let [slow (fn slow [x]
                 (time/sleep 0.5)
                 (+ x 10))]
      (is (= [] (vec (pmap slow []))))
      (is (= [11] (vec (pmap slow [1]))))
      (is (= [11 12 13 14 15 16 17 18 19]
             (vec (pmap slow (range 1 10))))))))

(deftest pcalls-test
  (binding [*pmap-cpu-count* 2]
    (let [slow (fn slow [x]
                 (time/sleep 0.5)
                 (+ x 10))]
      (is (= [] (vec (pcalls))))
      (is (= [11] (vec (pcalls #(slow 1)))))
      (is (= [11 12 13 14]
             (vec (pcalls #(slow 1)
                          #(slow 2)
                          #(slow 3)
                          #(slow 4))))))))

(deftest pvalues-test
  (binding [*pmap-cpu-count* 2]
    (let [slow (fn slow [x]
                 (time/sleep 0.5)
                 (+ x 10))]
      (is (= [] (vec (pvalues))))
      (is (= [11] (vec (pvalues (slow 1)))))
      (is (= [11 12 13 14]
             (vec (pvalues (slow 1)
                           (slow 2)
                           (slow 3)
                           (slow 4))))))))

;;;;;;;;;;;;
;; Arrays ;;
;;;;;;;;;;;;

(deftest to-array-test
  (is (= #py [] (to-array [])))
  (is (= #py [] (to-array '())))
  (is (= #py [1] (to-array [1])))
  (is (= #py [1 2 3] (to-array [1 2 3])))
  (is (= #py [1] (to-array '(1))))
  (is (= #py [1 2 3] (to-array '(1 2 3)))))

(deftest to-array-2d-test
  (is (= #py [] (to-array-2d [])))
  (is (= #py [] (to-array-2d '())))

  (is (= #py [#py [] #py []] (to-array-2d [[] ()])))
  (is (= #py [#py [] #py []] (to-array-2d '([] ()))))

  (is (= #py [#py [1 2 3] #py [:a :b :c]]
         (to-array-2d [[1 2 3] '(:a :b :c)])))

  (is (= #py [#py [1 2 3] #py [:a :b :c]]
         (to-array-2d '([1 2 3] (:a :b :c)))))

  (is (thrown? python/TypeError)
      (to-array-2d [[1 2 3] :b])))

(deftest into-array-test
  (testing "with no type"
    (is (= #py [] (into-array [])))
    (is (= #py [] (into-array '())))
    (is (= #py [1] (into-array [1])))
    (is (= #py [1 2 3] (into-array [1 2 3])))
    (is (= #py [1] (into-array '(1))))
    (is (= #py [1 2 3] (into-array '(1 2 3)))))

  (testing "with (ignored) type argument"
    (is (= #py [] (into-array nil [])))
    (is (= #py [] (into-array nil '())))
    (is (= #py [1] (into-array python/int [1])))
    (is (= #py [1 2 3] (into-array python/int [1 2 3])))
    (is (= #py [1] (into-array python/float '(1))))
    (is (= #py [1 2 3] (into-array python/float '(1 2 3))))))

(deftest make-array-test
  (testing "with no type"
    (is (= #py [] (make-array 0)))
    (is (= #py [nil] (make-array 1)))
    (is (= #py [nil nil nil] (make-array 3))))

  (testing "with (ignored) type argument"
    (is (= #py [] (make-array python/int 0)))
    (is (= #py [nil] (make-array python/int 1)))
    (is (= #py [nil nil nil] (make-array python/int 3))))

  (testing "multi-dimensional"
    (is (= #py [#py [] #py []]
           (make-array python/int 2 0)))
    (is (= #py [#py [nil nil nil] #py [nil nil nil]]
           (make-array python/int 2 3)))
    (is (= #py [#py [#py [nil nil] #py [nil nil]]
                #py [#py [nil nil] #py [nil nil]]]
           (make-array python/int 2 2 2)))))

(deftest object-array-tests
  (testing "only size"
    (is (= #py [] (object-array 0)))
    (is (= #py [nil] (object-array 1)))
    (is (= #py [nil nil nil] (object-array 3))))

  (testing "only seq"
    (is (= #py [] (object-array [])))
    (is (= #py [] (object-array '())))
    (is (= #py [1] (object-array [1])))
    (is (= #py [1 2 3] (object-array [1 2 3])))
    (is (= #py [1] (object-array '(1))))
    (is (= #py [1 2 3] (object-array '(1 2 3)))))

  (testing "size and init val"
    (is (= #py [] (object-array 0 :a)))
    (is (= #py [:a] (object-array 1 :a)))
    (is (= #py [:a :a :a] (object-array 3 :a))))

  (testing "size and seq"
    (is (= #py [] (object-array 0 (range 1 3))))
    (is (= #py [1 2 3] (object-array 3 (range 1 4))))
    (is (= #py [1 2 3 nil nil] (object-array 5 (range 1 4))))))

(deftest aclone-test
  (is (= #py [] (aclone [])))
  (is (= #py [] (aclone '())))
  (is (= #py [1] (aclone [1])))
  (is (= #py [1 2 3] (aclone [1 2 3])))
  (is (= #py [1] (aclone '(1))))
  (is (= #py [1 2 3] (aclone '(1 2 3)))))

(deftest alength-test
  (is (= 0 (alength #py [])))
  (is (= 1 (alength #py [1])))
  (is (= 3 (alength #py [1 2 3]))))

(deftest aget-test
  (is (thrown? python/IndexError (aget #py [] 1)))
  (is (thrown? python/IndexError (aget #py [1 2 3] 5)))
  (is (thrown? python/IndexError (aget #py [#py[1 0 6] 2 3] 0 5)))
  (is (= 1 (aget #py [1 2 3] 0)))
  (is (= :d (aget #py [#py [:a :b :c] #py [:d :e :f]] 1 0))))

(deftest aset-test
  (let [l #py [1 2 3]]
    (is (= :a (aset l 0 :a)))
    (is (= #py [:a 2 3] l))
    (is (thrown? python/IndexError (aset l 5 :f))))

  (let [l #py [#py [:a :b :c] #py [:d :e :f]]]
    (is (= 5 (aset l 0 2 5)))
    (is (= #py [#py [:a :b 5] #py [:d :e :f]] l))
    (is (thrown? python/IndexError (aset l 0 5 :cc)))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Namespace Utilities ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(def ^:redef redeffable :a)
(def not-redeffable :b)

(deftest with-redefs-test
  (testing "with-redefs cannot redef Vars without ^:redef metadata"
    (is (thrown? basilisp.lang.exception/ExceptionInfo
                 (with-redefs [not-redeffable :c]
                   not-redeffable)))
    (is (thrown? basilisp.lang.exception/ExceptionInfo
                 (with-redefs [redeffable     :d
                               not-redeffable :c]
                   not-redeffable))))

  (testing "with-redefs resets to the original root"
    (is (= :c (with-redefs [redeffable :c] redeffable)))
    (is (= :a redeffable)))

  (testing "with-redefs resets to the original root even after an exception"
    (is (thrown? basilisp.lang.exception/ExceptionInfo
                 (with-redefs [redeffable :c]
                   (throw
                    (ex-info "This is an exception" {})))))
    (is (= :a redeffable))))

(deftest requiring-resolve-test
  (is (thrown? basilisp.lang.exception/ExceptionInfo (requiring-resolve 'a-symbol)))
  (is (thrown? basilisp.lang.exception/ExceptionInfo (requiring-resolve :a-keyword)))
  (is (thrown? basilisp.lang.exception/ExceptionInfo (requiring-resolve :ns.qualified/kw)))
  (is (thrown? python/ImportError (requiring-resolve 'not.a.real.ns/sym)))
  (is (nil? (requiring-resolve 'basilisp.shell/sholl)))
  ;; this check should succeed (in spite of the missing top-level require) because
  ;; the previous assertion will import 'basilisp.shell even though 'sholl is not
  ;; a valid symbol in that namespace
  (is (= (resolve 'basilisp.shell/sh) (requiring-resolve 'basilisp.shell/sh))))

(deftest ns-resolve-test
  (is (= #'basilisp.core/apply (ns-resolve *ns* 'apply)))
  (is (nil? (ns-resolve *ns* 'xyz)))

  (is (= #'basilisp.set/union (ns-resolve *ns* 'basilisp.set/union)))
  (is (= #'basilisp.set/union (ns-resolve *ns* 'set/union)))
  (is (nil? (ns-resolve *ns* 'basilisp.set/xyz)))
  (is (nil? (ns-resolve *ns* 'set/xyz)))

  (is (= #'basilisp.test/is (ns-resolve *ns* 'is)))
  (is (nil? (ns-resolve *ns* '*test-section*)))
  (is (= #'basilisp.test/*test-section* (ns-resolve (the-ns 'basilisp.test) '*test-section*)))

  (is (nil? (ns-resolve *ns* 'if))))

(deftest intern-test
  (let [ns-sym (gensym "intern-test-ns")
        ns0 (create-ns ns-sym)]
    (testing "unbound"
      (let [sym (gensym "intern-test")
            v (intern ns0 sym)
            {:keys [name ns] :as m} (meta v)]
        (is (= ns0 ns))
        (is (= sym name))
        (is (= false (.-is-bound v)))))

    (testing "unbound ns-sym"
      (let [sym (gensym "intern-test")
            v (intern ns-sym sym)
            {:keys [name ns] :as m} (meta v)]
        (is (= ns0 ns))
        (is (= sym name))
        (is (= false (.-is-bound v)))))

    (testing "bound"
      (let [sym (gensym "intern-test")
            v (intern ns0 sym 5)
            {:keys [name ns] :as m} (meta v)]
        (is (= ns0 ns))
        (is (= sym name))
        (is (= true (.-is-bound v)))
        (is (= 5 @v))
        (is (= v (find-var (symbol (str ns0) (str sym))))))))


  (testing "ns-not-exists"
    (is (thrown? python/AttributeError (intern 'ns-non-existant 'xyz)))))

;;;;;;;;;;
;; Vars ;;
;;;;;;;;;;

(deftest var-test
  (testing "calling vars"
    (is (= '(1 2) (#'basilisp.core/list 1 2)))))

;;;;;;;;;;;;;;;;;
;; Hierarchies ;;
;;;;;;;;;;;;;;;;;

(deftest hierarchy-test
  (testing "derived with keywords"
    (let [h (-> (make-hierarchy)
                (derive ::square ::rectangle)
                (derive ::quadrilateral ::polygon)
                (derive ::rectangle ::quadrilateral)
                (derive ::trapezoid ::quadrilateral)
                (derive ::hexagon ::polygon)
                (derive ::triangle ::polygon)
                (derive ::equilateral ::triangle)
                (derive ::isosceles ::triangle)
                (derive ::scalene ::triangle)
                (derive ::square ::regular)
                (derive ::equilateral ::regular))]

      (testing "isa?"
        (are [child] (isa? h child ::polygon)
          ::triangle
          ::equilateral
          ::isosceles
          ::scalene
          ::quadrilateral
          ::rectangle
          ::square
          ::trapezoid
          ::hexagon)

        (are [child] (isa? h child ::regular)
          ::equilateral
          ::square)

        (are [child parent] (isa? h child parent)
          ::equilateral ::triangle
          ::isosceles   ::triangle
          ::scalene     ::triangle
          ::rectangle   ::quadrilateral
          ::square      ::quadrilateral
          ::square      ::rectangle
          ::trapezoid   ::quadrilateral))

      (testing "ancestors"
        (are [val res] (= res (ancestors h val))
          ::triangle      #{::polygon}
          ::equilateral   #{::triangle ::polygon ::regular}
          ::isosceles     #{::triangle ::polygon}
          ::scalene       #{::triangle ::polygon}
          ::quadrilateral #{::polygon}
          ::rectangle     #{::quadrilateral ::polygon}
          ::square        #{::rectangle ::quadrilateral ::polygon ::regular}
          ::trapezoid     #{::quadrilateral ::polygon}
          ::hexagon       #{::polygon}
          ::polygon       nil))

      (testing "descendants"
        (are [val res] (= res (descendants h val))
          ::triangle      #{::equilateral ::isosceles ::scalene}
          ::equilateral   nil
          ::isosceles     nil
          ::scalene       nil
          ::quadrilateral #{::rectangle ::square ::trapezoid}
          ::rectangle     #{::square}
          ::square        nil
          ::trapezoid     nil
          ::hexagon       nil
          ::polygon       #{::triangle
                            ::equilateral
                            ::isosceles
                            ::scalene
                            ::quadrilateral
                            ::rectangle
                            ::square
                            ::trapezoid
                            ::hexagon}
          ::regular       #{::square ::equilateral}))

      (testing "parents"
        (are [val res] (= res (parents h val))
          ::triangle      #{::polygon}
          ::equilateral   #{::triangle ::regular}
          ::isosceles     #{::triangle}
          ::scalene       #{::triangle}
          ::quadrilateral #{::polygon}
          ::rectangle     #{::quadrilateral}
          ::square        #{::rectangle ::regular}
          ::trapezoid     #{::quadrilateral}
          ::hexagon       #{::polygon}
          ::polygon       nil))

      (testing "underive"
        (let [h (-> h
                    (underive ::rectangle ::quadrilateral)
                    (underive ::isosceles ::triangle)
                    (underive ::scalene ::triangle))]
          (testing "isa?"
            (are [child] (isa? h child ::polygon)
              ::triangle
              ::equilateral
              ::hexagon)

            (are [child] (isa? h child ::regular)
              ::equilateral
              ::square)

            (are [child parent] (isa? h child parent)
              ::equilateral ::triangle
              ::square      ::rectangle
              ::trapezoid   ::quadrilateral))

          (testing "ancestors"
            (are [val res] (= res (ancestors h val))
              ::triangle      #{::polygon}
              ::equilateral   #{::triangle ::polygon ::regular}
              ::isosceles     nil
              ::scalene       nil
              ::quadrilateral #{::polygon}
              ::rectangle     nil
              ::square        #{::rectangle ::regular}
              ::trapezoid     #{::quadrilateral ::polygon}
              ::hexagon       #{::polygon}
              ::polygon       nil))

          (testing "descendants"
            (are [val res] (= res (descendants h val))
              ::triangle      #{::equilateral}
              ::equilateral   nil
              ::isosceles     nil
              ::scalene       nil
              ::quadrilateral #{::trapezoid}
              ::rectangle     #{::square}
              ::square        nil
              ::trapezoid     nil
              ::hexagon       nil
              ::polygon       #{::triangle ::equilateral ::hexagon ::quadrilateral ::trapezoid}
              ::regular       #{::square ::equilateral}))

          (testing "parents"
            (are [val res] (= res (parents h val))
              ::triangle      #{::polygon}
              ::equilateral   #{::triangle ::regular}
              ::isosceles     nil
              ::scalene       nil
              ::quadrilateral #{::polygon}
              ::rectangle     nil
              ::square        #{::rectangle ::regular}
              ::trapezoid     #{::quadrilateral}
              ::hexagon       #{::polygon}
              ::polygon       nil))))))

  (testing "derived with types"
    (let [h (-> (make-hierarchy)
                (derive python/dict ::collections)
                (derive python/list ::collections)
                (derive python/set ::collections)
                (derive python/tuple ::collections)
                (derive python/list ::sequential)
                (derive python/tuple ::sequential)
                (derive python/int ::numeric)
                (derive python/float ::numeric)
                (derive python/complex ::numeric)
                (derive ::collections ::types)
                (derive ::sequential ::types)
                (derive ::numeric ::types))]

      (testing "isa?"
        (are [child parent] (isa? h child parent)
          python/object python/object
          python/int    python/object
          python/bool   python/object
          python/bool   python/bool

          python/dict  ::collections
          python/list  ::collections
          python/set   ::collections
          python/tuple ::collections

          python/list  ::sequential
          python/tuple ::sequential

          python/int     ::numeric
          python/float   ::numeric
          python/complex ::numeric

          python/dict    ::types
          python/list    ::types
          python/set     ::types
          python/tuple   ::types
          python/int     ::types
          python/float   ::types
          python/complex ::types

          [python/int ::numeric]   [::numeric ::types]
          [python/int python/list] [::numeric ::collections]
          [::sequential ::numeric] [::types ::types]))

      (testing "ancestors"
        (are [val res] (= res (ancestors h val))
          python/dict    #{python/object ::types ::collections}
          python/list    #{python/object ::types ::collections ::sequential}
          python/set     #{python/object ::types ::collections}
          python/tuple   #{python/object ::types ::collections ::sequential}
          python/int     #{python/object ::types ::numeric}
          python/float   #{python/object ::types ::numeric}
          python/complex #{python/object ::types ::numeric}
          ::collections  #{::types}
          ::sequential   #{::types}
          ::numeric      #{::types}
          ::types        nil))

      (testing "descendants"
        (are [val] (thrown? python/TypeError (descendants h val))
          python/dict
          python/list
          python/set
          python/tuple
          python/int
          python/float
          python/complex)

        (are [val res] (= res (descendants h val))
          ::collections #{python/dict python/list python/set python/tuple}
          ::sequential  #{python/list python/tuple}
          ::numeric     #{python/int python/float python/complex}
          ::types       #{::collections
                          ::numeric
                          ::sequential
                          python/dict
                          python/list
                          python/set
                          python/tuple
                          python/int
                          python/float
                          python/complex}))

      (testing "parents"
        (are [val res] (= res (parents h val))
          python/dict    #{::collections python/object}
          python/list    #{::collections ::sequential python/object}
          python/set     #{::collections python/object}
          python/tuple   #{::collections ::sequential python/object}
          python/int     #{::numeric python/object}
          python/float   #{::numeric python/object}
          python/complex #{::numeric python/object}
          ::collections  #{::types}
          ::numeric      #{::types}
          ::types        nil))

      (testing "underive"
        (let [h (-> h
                    (underive ::collections ::types)
                    (underive python/complex ::numeric))]
          (testing "isa?"
            (are [child parent] (isa? h child parent)
              python/dict  ::collections
              python/list  ::collections
              python/set   ::collections
              python/tuple ::collections

              python/list  ::sequential
              python/tuple ::sequential

              python/int   ::numeric
              python/float ::numeric

              python/list  ::types
              python/tuple ::types
              python/int   ::types
              python/float ::types

              [python/int ::numeric]   [::numeric ::types]
              [python/int python/list] [::numeric ::collections]
              [::sequential ::numeric] [::types ::types]))

          (testing "ancestors"
            (are [val res] (= res (ancestors h val))
              python/dict    #{python/object ::collections}
              python/list    #{python/object ::types ::collections ::sequential}
              python/set     #{python/object ::collections}
              python/tuple   #{python/object ::types ::collections ::sequential}
              python/int     #{python/object ::types ::numeric}
              python/float   #{python/object ::types ::numeric}
              python/complex #{python/object}
              ::collections  nil
              ::sequential   #{::types}
              ::numeric      #{::types}
              ::types        nil))

          (testing "descendants"
            (are [val res] (= res (descendants h val))
              ::collections #{python/dict python/list python/set python/tuple}
              ::sequential  #{python/list python/tuple}
              ::numeric     #{python/int python/float}
              ::types       #{::numeric
                              ::sequential
                              python/list
                              python/tuple
                              python/int
                              python/float}))

          (testing "parents"
            (are [val res] (= res (parents h val))
              python/dict    #{::collections python/object}
              python/list    #{::collections ::sequential python/object}
              python/set     #{::collections python/object}
              python/tuple   #{::collections ::sequential python/object}
              python/int     #{::numeric python/object}
              python/float   #{::numeric python/object}
              python/complex #{python/object}
              ::collections  nil
              ::numeric      #{::types}
              ::types        nil)))))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Parsing Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

(deftest parse-double-test
  (are [x] (thrown? python/TypeError (parse-double x))
    nil
    true
    1
    11.6
    :a-keyword
    'sym
    {}
    []
    #{}
    ())

  (are [res x] (= res (parse-double x))
    nil   ""
    nil   "strang"
    nil   "--13.6"
    0.0   "0"
    0.0   "0.0"
    14.0  " 14"
    3.14  "3.14     "
    14.0  "  14  "
    -15.6 " -15.6"
    -15.6 "-15.6   "))

(deftest parse-long-test
  (are [x] (thrown? python/TypeError (parse-long x))
    nil
    true
    1
    11.6
    :a-keyword
    'sym
    {}
    []
    #{}
    ())

  (are [res x] (= res (parse-long x))
    nil   ""
    nil   "strang"
    nil   "--13"
    nil   "0.0"
    0     "0"
    14    " 14"
    83    "  83     "
    -15   " -15"
    -15   "-15    "))

(deftest parse-boolean-test
  (are [x] (thrown? python/TypeError (parse-boolean x))
    nil
    true
    1
    11.6
    :a-keyword
    'sym
    {}
    []
    #{}
    ())

  (are [res x] (= res (parse-boolean x))
    nil   ""
    nil   "1"
    nil   "strang"
    nil   "--13.6"
    nil   "True"
    nil   "False"
    nil   "TRUE"
    nil   "FALSE"
    true  "true"
    false "false"))

(deftest parse-uuid-test
  (are [x] (thrown? python/TypeError (parse-uuid x))
    nil
    true
    1
    11.6
    :a-keyword
    'sym
    {}
    []
    #{}
    ())

  (are [res x] (= res (parse-uuid x))
    nil                                          ""
    nil                                          "1"
    nil                                          "strang"
    #uuid "529f77ae-bf6e-43e0-92a4-798e3ce4d35e" "529f77ae-bf6e-43e0-92a4-798e3ce4d35e"
    nil                                          "529f77ae-bf6e-43e0-92a4-798e3ce4d35"
    nil                                          "529f77ae-bf6-43e0-92a4-798e3ce4d35e"
    #uuid "67209b54-9668-4656-8cf9-94ee70ed6ba8" "67209B54-9668-4656-8CF9-94EE70ED6BA8"
    nil                                          "67209B54-9668-4656-8CF9-94EE70ED6BA"
    nil                                          "67209B5-9668-4656-8CF9-94EE70ED6BA8"))

;;;;;;;;;;;;;;;;
;; Interfaces ;;
;;;;;;;;;;;;;;;;

(deftest gen-interface-test
  (are [x] (thrown? basilisp.lang.exception/ExceptionInfo x)
    (gen-interface :name "TestInterface"
                   :methods '[(method [thing])
                              (method [other-thing])])
    (gen-interface :name "TestInterface"
                   :methods '[(method [thing & args])
                              (method [& args])])
    (gen-interface :name "TestInterface"
                   :methods '[(method [thing1 thing2])
                              (method [& args])]))

  (is (not (nil? (gen-interface :name "TestInterface"))))

  (are [arity-names methods] (let [interface (gen-interface :name "TestInterface"
                                                            :methods methods)]
                               (set/superset? (set (python/dir interface))
                                              (set arity-names)))
    [] []

    ["method"]
    '[(method [arg])]

    ["method" "_method_arity1" "_method_arity2"]
    '[(method [arg]) (method [arg1 arg2])]

    ["method" "other" "_other_arity1" "_other_arity3" "_other_arity_rest"]
    '[(method [arg])
      (other [arg])
      (other [arg1 arg2 arg3])
      (other [arg1 arg2 arg3 & rest-arg])]))

;;;;;;;;;;;;;;;;;
;; Transducers ;;
;;;;;;;;;;;;;;;;;

(deftest eduction-test
  (is (= '(1 9 49 81)
         (seq (eduction (mapcat identity)
                        (filter odd?)
                        (map (fn [x] (* x x)))
                        (take 5)
                        [(range 5) (range 6 10)]))))
  (is (= '(1 9 25 49 81)
         (seq (eduction (map inc)
                        (filter odd?)
                        (map (fn [x] (* x x)))
                        (take 5)
                        (range)))))
  (is (= '(1 9 49 81 121)
         (seq (eduction (mapcat identity)
                        (filter odd?)
                        (map (fn [x] (* x x)))
                        (take 5)
                        [(range 5) (range 6 10) (range 11 20)]))))
  (is (= '(1 9 49 81 121 169 225 289 361)
         (seq (eduction (mapcat identity)
                        (filter odd?)
                        (map (fn [x] (* x x)))
                        [(range 5) (range 6 10) (range 11 20)])))))

(deftest halt-when-test
  (is (= 5 (transduce (comp (map inc)
                            (halt-when #(>= % 5)))
                      +
                      0
                      (range))))
  (is (= 10 (transduce (comp (map inc)
                             (halt-when #(>= % 5)
                                        (fn [result _] result)))
                       +
                       0
                       (range)))))

(deftest sequence-test
  (testing "single arity"
    (are [x y] (= x (sequence y))
      '() '()
      '() []
      '() #{}
      '() {}
      '(0 1 2 3) [0 1 2 3]
      '(0 1 2 3) '(0 1 2 3)
      '(0 1 2 3) (range 4)))

  (testing "tranducer with one coll"
    (is (= '(1 2 3 4 5 6 7 8 9)
           (sequence (comp (mapcat vector) cat) [[1 2 3] [4 5 6] [7 8 9]])))
    (is (= '(1 2 3 4 5 6 7 8 9)
           (sequence (mapcat identity) [[1 2 3] [4 5 6] [7 8 9]])))
    (is (= '(1 9 25 49 81)
           (sequence (comp (map inc)
                           (filter odd?)
                           (map (fn [x] (* x x)))
                           (take 5))
                     (range))))
    (is (= '(1 9 49 81)
           (sequence (comp  (mapcat identity)
                            (filter odd?)
                            (map (fn [x] (* x x)))
                            (take 5))
                     [(range 5) (range 6 10)]))))

  (testing "transducer with multiple colls"
    (is (= '([1 4 7] [2 5 8] [3 6 9])
           (sequence (map vector) [1 2 3] [4 5 6] [7 8 9])))
    (is (= '(1 4 7 2 5 8 3 6 9)
           (sequence (mapcat vector) [1 2 3] [4 5 6] [7 8 9])))
    (is (= '(1 49 9 81)
           (sequence (comp  (mapcat vector)
                            (filter odd?)
                            (map (fn [x] (* x x)))
                            (take 5))
                     (range 5)
                     (range 6 10))))
    (is (= '(121 1 49 169 9)
           (sequence (comp  (mapcat vector)
                            (filter odd?)
                            (map (fn [x] (* x x)))
                            (take 5))
                     (range 5)
                     (range 6 10)
                     (range 11 16))))))

;;;;;;;;;;;;;;;;;;;;;;;;
;; Stateful Iteration ;;
;;;;;;;;;;;;;;;;;;;;;;;;

(deftest iteration-test
  (letfn [(range-chunk [n]
            (vec (range n (+ n 3))))]
    (is (= '([0 1 2] [2 3 4])
           (take 2 (iteration range-chunk :kf last :initk 0))))
    (is (= '([5 6 7] [7 8 9] [9 10 11])
           (take 3 (iteration range-chunk :kf last :initk 5))))
    (is (= '(5 7 9)
           (take 3 (iteration range-chunk :vf first :kf last :initk 5))))
    (is (= '(18 24 30)
           (take 3 (iteration range-chunk :vf (partial apply +) :kf last :initk 5))))
    (is (= '(0 1 2 3 4 5 6 7 8)
           (sequence
            cat
            (iteration range-chunk :somef (partial some #(< % 7)) :kf (comp inc last) :initk 0))))))

;;;;;;;;;;
;; Taps ;;
;;;;;;;;;;

(deftest tap-test
  (let [tap-queue (var-get (find-var 'basilisp.core/tap-queue))

        def-atom (atom [])
        a1-atom  (atom [])
        a2-atom  (atom [])
        b-atom   (atom [])

        def-fn   #(swap! def-atom conj %)
        a1-fn    #(swap! a1-atom conj [:a1 %])
        a2-fn    #(swap! a2-atom conj [:a2 %])
        b-fn     #(swap! b-atom conj %)]
    (add-tap def-fn)
    (remove-tap b-fn)  ;; not an error
    (tap> "this is a test")

    ;; Wait for the tap thread to drain
    (.join tap-queue)

    (remove-tap def-fn)
    (tap> "this is not a test")

    (is (= ["this is a test"] @def-atom))
    (is (= [] @a1-atom))
    (is (= [] @a2-atom))
    (is (= [] @b-atom))

    (add-tap :a a1-fn)
    (add-tap :a a2-fn)
    (tap> :a "all a's get this value")
    (tap> :a "and this one!")
    (.join tap-queue)
    (remove-tap :a a2-fn)
    (tap> :a "but this is just for the top a")
    (.join tap-queue)

    (is (= ["this is a test"] @def-atom))
    (is (= [[:a1 "all a's get this value"]
            [:a1 "and this one!"]
            [:a1 "but this is just for the top a"]]
           @a1-atom))
    (is (= [[:a2 "all a's get this value"]
            [:a2 "and this one!"]]
           @a2-atom))
    (is (= [] @b-atom))))


;;;;;;;;;;
;; Eval ;;
;;;;;;;;;;

(deftest eval-test
  (testing "can ns after in-ns"
    (binding [*ns* *ns*]
      (eval '(in-ns 'test-core-fns.ns-after-in-ns))
      (eval '(ns test-core-fns.ns-after-in-ns))
      (is (= *ns* (the-ns 'test-core-fns.ns-after-in-ns)))))

  (testing "eval ns with import aliases"
    (binding [*ns* *ns*]
      (eval '(ns test-core-fns.ns-with-import (:import [time :as time-alias])))
      (is (= *ns* (the-ns 'test-core-fns.ns-with-import)))
      (is (= "Thu Jan  1 00:00:01 1970" (eval '(time-alias/asctime (time-alias/gmtime 1))))))))


;;;;;;;;;;
;; Load ;;
;;;;;;;;;;

(deftest load-test

  (let [load-dir-test "tests/basilisp/corpus"
        load-dir-filepath (str load-dir-test "/core_load_1.lpy")]
    (try
      (when (bio/exists? load-dir-test)
        (shutil/rmtree load-dir-test))
      (bio/make-parents load-dir-filepath)
      (spit load-dir-filepath "(print :core-load-1)")

      (testing "relative load path"
        (let [output (with-out-str (load "corpus/core-load-1"))]
          (is (= ":core-load-1" output))))

      (testing "absolute (/) load path"
        ;; pytest add the top basilisp directory to the classpath
        (let [output (with-out-str (load "/tests/basilisp/corpus/core-load-1"))]
          (is (= ":core-load-1" output))))

      (testing "non-existent load path"
        (is (thrown? python/FileNotFoundError (load "corpus/core-load-99"))))

      (finally
        (when (bio/exists? load-dir-test)
          (shutil/rmtree load-dir-test))))))

;;;;;;;;;;;;;;
;; Printing ;;
;;;;;;;;;;;;;;

(deftest pr-test
  (testing "is dynamic"
    (is (= '(1) (binding [pr (fn [& more] more)] (pr 1)))))

  (testing "with *print-namespace-maps*"
    (is (= "#py {:a/x 5}" (binding [*print-namespace-maps* false] (pr-str #py {:a/x 5}))))
    (is (= "#py #:a{:x 5}" (binding [*print-namespace-maps* true] (pr-str #py {:a/x 5}))))

    (are [res m b] (contains? res (binding [*print-namespace-maps* b] (pr-str m)))
      #{"{:a/x 5}"} {:a/x 5} false
      #{"#:a{:x 5}"} {:a/x 5} true
      #{"{:x 5}"} {:x 5} true
      #{"{1 2}"} {1 2} false
      #{"{1 2}"} {1 2} true
      #{"{:a/y 6 :a/x 5}" "{:a/x 5 :a/y 6}"} {:a/x 5 :a/y 6} false
      #{"#:a{:y 6 :x 5}" "#:a{:x 5 :y 6}"} {:a/x 5 :a/y 6} true
      #{"{6 6 :a/x 5}" "{:a/x 5 6 6}"} {:a/x 5 6 6} false
      #{"{6 6 :a/x 5}" "{:a/x 5 6 6}"} {:a/x 5 6 6} true
      #{"{:a/x 5 :b/y 6}" "{:b/y 6 :a/x 5}"} {:a/x 5 :b/y 6} true
      #{"#:a{y 6 x 5}" "#:a{x 5 y 6}"} {'a/x 5 'a/y 6} true
      #{"#:a{y 6 :x 5}" "#:a{:x 5 y 6}"} {:a/x 5 'a/y 6} true
      #{"{y 6 :a/x 5}" "{:a/x 5 y 6}"} {:a/x 5 'y 6} true)

    (are [res m pnm pm] (= res (binding [*print-namespace-maps* pnm
                                         *print-meta*           pm]
                                 (pr-str m)))
      "^{:m 1} {:a/x 5}"     ^{:m 1} {:a/x 5}   false true
      "^{:m 1} #:a{:x 5}"    ^{:m 1} {:a/x 5}   true true
      "^#:l{:m 1} #:a{:x 5}" ^{:l/m 1} {:a/x 5} true true)

    (are [res m pl] (= res (binding [*print-namespace-maps* true
                                     *print-meta*           true
                                     *print-level* pl]
                             (pr-str m)))
      "#"                                ^{:m 1} {:a/x 5} 0
      "^{:m 1} #:a{:x 5}"                ^{:m 1} {:a/x 5} 1
      "^{:m 1} #:a{:x #}"                ^{:m 1} {:a/x ^{:x 22} {:b 36}} 1
      "^{:m 1} #:a{:x ^{:x 22} {:b 36}}" ^{:m 1} {:a/x ^{:x 22} {:b 36}} 2)))

(defn- bio-write
  "Helper fn to write the ``strings`` to the ByteIO buffer ``bio``
  and return the contents of the buffer."
  [bio & strings]
  (.write bio (python/bytes (apply str strings) "UTF-8"))
  (.getvalue bio))

(deftest flush-on-newline-test
  ;; :line-buffering false :newline ""
  ;;
  ;;   the above options instruct the TextIOWrapper to internally
  ;;   disable (1) flushing on newlines and (2) universal newlines
  ;;   mode.

  (testing "prn newline flushing"
    (let [bio      (io/BytesIO)
          expected (io/BytesIO)]
      (binding [*out* (io/TextIOWrapper bio ** :line-buffering false :newline "")
                *flush-on-newline* true]
        (prn)
        (is (= (bio-write expected os/linesep) (.getvalue bio)))
        (prn "ab")
        (is (= (bio-write expected "\"ab\"" os/linesep) (.getvalue bio)))
        (prn "ab" 1)
        (is (= (bio-write expected "\"ab\"" " " 1 os/linesep) (.getvalue bio))))))

  (testing "prn newline not flushing"
    (let [bio      (io/BytesIO)
          expected (io/BytesIO)]
      (binding [*out* (io/TextIOWrapper bio ** :line-buffering false :newline "")
                *flush-on-newline* false]
        (prn)
        (is (= #b "" (.getvalue bio)))
        (prn "ab")
        (is (= #b "" (.getvalue bio)))
        (prn "ab" 1)
        (is (= #b "" (.getvalue bio)))
        (.flush *out*)
        (is (= (bio-write expected os/linesep "\"ab\"" os/linesep "\"ab\"" " " 1 os/linesep)
               (.getvalue bio))))))

  (testing "println newline flushing"
    (let [bio      (io/BytesIO)
          expected (io/BytesIO)]
      (binding [*out* (io/TextIOWrapper bio ** :line-buffering false :newline "")
                *flush-on-newline* true]
        (println)
        (is (= (bio-write expected os/linesep) (.getvalue bio)))
        (println "ab")
        (is (= (bio-write expected "ab" os/linesep) (.getvalue bio)))
        (println "ab" 1)
        (is (= (bio-write expected "ab" " " 1 os/linesep) (.getvalue bio))))))

  (testing "println newline not flushing"
    (let [bio      (io/BytesIO)
          expected (io/BytesIO)]
      (binding [*out* (io/TextIOWrapper bio ** :line-buffering false :newline "")
                *flush-on-newline* false]
        (println)
        (is (= #b "" (.getvalue bio)))
        (println "ab")
        (is (= #b "" (.getvalue bio)))
        (println "ab" 1)
        (is (= #b "" (.getvalue bio)))
        (.flush *out*)
        (is (= (bio-write expected os/linesep "ab" os/linesep "ab" " " 1 os/linesep)
               (.getvalue bio)))))))

;;;;;;;;;;;;;;;;
;; Arithmetic ;;
;;;;;;;;;;;;;;;;

(deftest arithmetic-equality-test
  (testing "int and float type equality"
    (is (not= 1 1.00001))
    (is (= 1 1.0000000000000000000000009)))

  (testing "== is an alias of ="
    (let [f 1.0000000000000000000000009]
      (is (= 1 f))
      (is (== 1 f)))))

;;;;;;;;;;;
;; Insts ;;
;;;;;;;;;;;

(deftest inst?-test
  (is (inst? (datetime.datetime/now)))
  (is (not (inst? (datetime.date/today))))
  (is (not (inst? (datetime/time))))
  (is (not (inst? (python/object)))))

(deftest inst-ms-test
  (is (= 0 (inst-ms
            (datetime.datetime/fromtimestamp 0 datetime.timezone/utc))))
  (is (= 1723235558968
         (inst-ms #inst "2024-08-09T20:32:38.968-00:00"))))
