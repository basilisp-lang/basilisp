(in-ns 'basilisp.core)

(def list
  (fn* list [& args] args))

(def
  ^{:doc "If o is a Seq, return the first element from o. If o is nil, return
          nil. Otherwise, coerces o to a Seq and returns the first."}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc "If o is a Seq, return the elements after the first in o. If o is nil,
          returns an empty seq. Otherwise, coerces o to a seq and returns the rest."}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc "Calls rest on o. If o returns an empty sequence or nil, returns nil.
          Otherwise, returns the elements after the first in o."}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc "Returns the second element in a Seq."}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc "Creates a new sequence where o is the first element and seq is the rest.
    If seq is nil, return a list containing o. If seq is not a Seq, attempt
    to coerce it to a Seq and then cons o onto the resulting sequence."}
  cons
  (fn* cons [v seq] (basilisp.lang.runtime/cons v seq)))

(def meta
  (fn* meta [o]
       (.-meta o)))

(def with-meta
  (fn* with-meta [o meta]
       (.with-meta o meta)))

(def ^:macro let
  (fn* let [&form & decl]
       (cons 'let* decl)))

(def ^:macro fn
  (fn* fn [&form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def identity
  (fn identity [v] v))

(def
  ^{:doc "Return true if obj is an instance of class."}
  instance?
  (fn instance? [class obj]
    (builtins/isinstance obj class)))

(def
  ^{:doc "Return true if obj is a string."}
  string?
  (fn string? [o]
    (instance? builtins/str o)))

(def
  ^{:doc "Return true if o is a list."}
  list?
  (fn list? [o]
    (instance? basilisp.lang.list/List o)))

(def
  ^{:doc "Return true if o is a map."}
  map?
  (fn map? [o]
    (instance? basilisp.lang.map/Map o)))

(def
  ^{:doc "Return true if o is a set."}
  set?
  (fn set? [o]
    (instance? basilisp.lang.set/Set o)))

(def
  ^{:doc "Return true if o is a vector."}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.vector/Vector o)))

(def seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def print
  (fn print [& args]
    (apply builtins/print args)))

(def count
  (fn count [coll]
    (try
      (builtins/len coll)
      (catch TypeError _
        (count (apply vector coll))))))

(def
  ^{:doc "Returns a basilisp.lang.exception/ExceptionInfo instance with
          the given message and data."}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:macro true
    :doc   "Define a new function."}
  defn
  (fn defn [&form name & body]
    (let [body (concat body)
          doc  (if (string? (first body))
                 (first body)
                 nil)
          fname (if doc
                  (with-meta name {:doc doc})
                  name)
          body (rest body)
          args (if (vector? (first body))
                 (first body)
                 nil)  ;; Should throw here!
          body (rest body)]
      `(def ~fname
         (fn* ~fname ~args
              ~@body)))))

(defn print-string
  "Print a string!"
  [s]
  (print s)
  (print (string? s)))
