(in-ns 'basilisp.core)

(def list
  (fn* list [& args] args))

(def
  ^{:doc "If o is a Seq, return the first element from o. If o is nil, return
          nil. Otherwise, coerces o to a Seq and returns the first."}
  first
  (fn* first [seq] (basilisp.lang.runtime/first seq)))

(def
  ^{:doc "If o is a Seq, return the elements after the first in o. If o is nil,
          returns an empty seq. Otherwise, coerces o to a seq and returns the rest."}
  rest
  (fn* rest [seq] (basilisp.lang.runtime/rest seq)))

(def
  ^{:doc "Calls rest on o. If o returns an empty sequence or nil, returns nil.
          Otherwise, returns the elements after the first in o."}
  next
  (fn* next [seq] (basilisp.lang.runtime/next seq)))

(def
  ^{:doc "Returns the second element in a Seq."}
  second
  (fn* second [seq] (first (rest seq))))

(def
  ^{:doc "Creates a new sequence where o is the first element and seq is the rest.
    If seq is nil, return a list containing o. If seq is not a Seq, attempt
    to coerce it to a Seq and then cons o onto the resulting sequence."}
  cons
  (fn* cons [v seq] (basilisp.lang.runtime/cons v seq)))

(def meta
  (fn* meta [o]
       (.-meta o)))

(def with-meta
  (fn* with-meta [o meta]
       (.with-meta o meta)))

(def ^:macro let
  (fn* let [&form & decl]
       (cons 'let* decl)))

(def ^:macro fn
  (fn* fn [&form & decl]
       (with-meta
         (cons 'fn* decl)
         (meta &form))))

(def identity
  (fn identity [v] v))

(def
  ^{:doc "Return true if obj is an instance of class."}
  instance?
  (fn instance? [class obj]
    (builtins/isinstance obj class)))

(def
  ^{:doc "Return true if obj is a string."}
  string?
  (fn string? [o]
    (instance? builtins/str o)))

(def
  ^{:doc "Return true if obj is a symbol."}
  symbol?
  (fn symbol? [o]
    (instance? basilisp.lang.symbol/Symbol o)))

(def
  ^{:doc "Return true if obj is a keyword."}
  keyword?
  (fn keyword? [o]
    (instance? basilisp.lang.keyword/Keyword o)))

(def
  ^{:doc "Return true if o is a list."}
  list?
  (fn list? [o]
    (instance? basilisp.lang.list/List o)))

(def
  ^{:doc "Return true if o is a map."}
  map?
  (fn map? [o]
    (instance? basilisp.lang.map/Map o)))

(def
  ^{:doc "Return true if o is a set."}
  set?
  (fn set? [o]
    (instance? basilisp.lang.set/Set o)))

(def
  ^{:doc "Return true if o is a vector."}
  vector?
  (fn vector? [o]
    (instance? basilisp.lang.vector/Vector o)))

(def seq
  (fn seq [o]
    (basilisp.lang.runtime/to-seq o)))

(def apply
  (fn apply [f & args]
    (basilisp.lang.runtime/apply f args)))

(def concat
  (fn concat [& seqs]
    (apply basilisp.lang.runtime/concat seqs)))

(def hash-map
  (fn hash-map [& kvs]
    (apply basilisp.lang.map/hash-map kvs)))

(def hash-set
  (fn hash-set [& members]
    (apply basilisp.lang.set/s members)))

(def vector
  (fn vector [& elems]
    (apply basilisp.lang.vector/v elems)))

(def print
  (fn print [& args]
    (apply builtins/print args)))

(def count
  (fn count [coll]
    (try
      (builtins/len coll)
      (catch TypeError _
        (count (apply vector coll))))))

(def
  ^{:doc "Returns a basilisp.lang.exception/ExceptionInfo instance with
          the given message and data."}
  ex-info
  (fn ex-info [msg data]
    (basilisp.lang.exception/ExceptionInfo msg data)))

(def
  ^{:macro true
    :doc   "Define a new function with an optional docstring."}
  defn
  (fn defn [&form name & body]
    (if (symbol? name)
      nil  ;; Do nothing!
      (throw (ex-info "First argument to defn must be a symbol"
                      {:found name :type (builtins/type name)})))
    (let [body   (concat body)
          doc    (if (string? (first body))
                   (first body)
                   nil)
          fname  (if doc
                   (with-meta name {:doc doc})
                   name)
          body   (if doc
                   (rest body)
                   body)
          multi? (list? (first body))
          body   (if multi?
                   body
                   (cons
                    (if (vector? (first body))
                      (first body)
                      (throw
                       (ex-info "Expected an argument vector"
                                {:found (first body)})))
                    (rest body)))]
      `(def ~fname
         (fn* ~fname
              ~@body)))))

(defn nth
  "Returns the ith element of coll (0-indexed), if it exists.
  nil otherwise."
  [coll i]
  (basilisp.lang.runtime/nth coll i))

(defn nthnext
  "Returns the nth next sequence of coll.

  (nthnext nil 1)           ;=> nil
  (nthnext [] 1)            ;=> nil
  (nthnext [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthnext coll i))

(defn nthrest
  "Returns the nth rest sequence of coll, or coll if i is 0.

  (nthrest nil 1)           ;=> nil
  (nthrest [] 1)            ;=> []
  (nthrest [1 2 3 4 5 6] 4) ;=> (5 6)"
  [coll i]
  (basilisp.lang.runtime/nthrest coll i))

(defn last
  "Return the last item in a seq, or nil if the seq is empty."
  [s]
  (if (seq (rest s))
    (recur (rest s))
    (first s)))

(defn +
  "Sum the arguments together. If no arguments given, returns 0."
  ([] 0)
  ([x] x)
  ([x & args]
   (if (seq (rest args))
     (recur (operator/add x (first args)) (rest args))
     (operator/add x (first args)))))
